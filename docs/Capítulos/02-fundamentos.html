<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-BR" xml:lang="pt-BR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Linguagem R - 2&nbsp; Fundamentos da Linguagem R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 1em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Capítulos/03-tidyverse.html" rel="next">
<link href="../Capítulos/01-nocoes-basicas.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Capítulos/01-nocoes-basicas.html">Introduzindo a Linguagem R</a></li><li class="breadcrumb-item"><a href="../Capítulos/02-fundamentos.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Fundamentos da Linguagem R</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introdução à Linguagem R</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo escuro"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Procurar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefácio</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Introduzindo a Linguagem R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/01-nocoes-basicas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Noções Básicas do R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/02-fundamentos.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Fundamentos da Linguagem R</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Importando, organizando e transformando dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/03-tidyverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduzindo o universo do <code>tidyverse</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/03-importacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Importando e exportando dados com <code>readr</code>, <code>readxl</code> e <code>haven</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/04-transformacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Transformando dados com <code>dplyr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/06-dados-relacionais.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introdução a base de dados relacionais com <code>dplyr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/07-tidy-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><em>Tidy Data</em>: uma abordagem para organizar os seus dados com <code>tidyr</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Visualizando seus dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/08-ggplot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Visualização de dados com <code>ggplot2</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/09-theme-ggplot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Configurando componentes estéticos do gráfico no <code>ggplot2</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Ferramentas para tipos específicos de dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/10-strings.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Manipulação e transformação de <em>strings</em> com <code>stringr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/11-factors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Introduzindo fatores (<em>factor</em>’s) com <code>forcats</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/12-variaveis-tempo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introdução à variáveis de tempo com <code>lubridate</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Funções e Loops: construindo os seus próprios programas e automatizando tarefas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/13-controle-fluxo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Controle condicional de fluxo</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/05-funcoes-loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Funções</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/17-loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title"><em>Loops</em></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/18-purrr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title"><em>Functional programming</em> com <code>purrr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/15-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title"><em>Debugging</em> - Resolvendo <em>bugs</em> em suas funções</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/16-environments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title"><em>Environments</em> ou ambientes no R</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
 <span class="menu-text">Apêndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercícios</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências bibliográficas</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Índice</h2>
   
  <ul>
  <li><a href="#sec:fundamentos_R" id="toc-sec:fundamentos_R" class="nav-link active" data-scroll-target="#sec\:fundamentos_R"><span class="header-section-number">2.1</span> Introdução</a></li>
  <li><a href="#mais-detalhes-sobre-objetos" id="toc-mais-detalhes-sobre-objetos" class="nav-link" data-scroll-target="#mais-detalhes-sobre-objetos"><span class="header-section-number">2.2</span> Mais detalhes sobre objetos</a></li>
  <li><a href="#como-o-r-organiza-e-interpreta-os-seus-dados" id="toc-como-o-r-organiza-e-interpreta-os-seus-dados" class="nav-link" data-scroll-target="#como-o-r-organiza-e-interpreta-os-seus-dados"><span class="header-section-number">2.3</span> Como o R organiza e interpreta os seus dados</a></li>
  <li><a href="#sec:estruturas_dados" id="toc-sec:estruturas_dados" class="nav-link" data-scroll-target="#sec\:estruturas_dados"><span class="header-section-number">2.4</span> Estruturas de dados</a>
  <ul class="collapse">
  <li><a href="#sec:vetores_estrutura" id="toc-sec:vetores_estrutura" class="nav-link" data-scroll-target="#sec\:vetores_estrutura"><span class="header-section-number">2.4.1</span> Vetores</a></li>
  <li><a href="#matrizes" id="toc-matrizes" class="nav-link" data-scroll-target="#matrizes"><span class="header-section-number">2.4.2</span> Matrizes</a></li>
  <li><a href="#sec:estrutura_listas" id="toc-sec:estrutura_listas" class="nav-link" data-scroll-target="#sec\:estrutura_listas"><span class="header-section-number">2.4.3</span> Listas</a></li>
  <li><a href="#sec:estrutura_data_frames" id="toc-sec:estrutura_data_frames" class="nav-link" data-scroll-target="#sec\:estrutura_data_frames"><span class="header-section-number">2.4.4</span> Tabelas no R: <code>data.frame</code></a></li>
  <li><a href="#sec:fundamentos_tibble" id="toc-sec:fundamentos_tibble" class="nav-link" data-scroll-target="#sec\:fundamentos_tibble"><span class="header-section-number">2.4.5</span> <code>tibble</code>’s como uma alternativa moderna aos <code>data.frame</code>’s</a></li>
  </ul></li>
  <li><a href="#sec:fundamentos_tipos_dados" id="toc-sec:fundamentos_tipos_dados" class="nav-link" data-scroll-target="#sec\:fundamentos_tipos_dados"><span class="header-section-number">2.5</span> Tipos de dados</a>
  <ul class="collapse">
  <li><a href="#textos-e-caracteres-character" id="toc-textos-e-caracteres-character" class="nav-link" data-scroll-target="#textos-e-caracteres-character"><span class="header-section-number">2.5.1</span> Textos e caracteres (<code>character</code>)</a></li>
  <li><a href="#números-reais-double" id="toc-números-reais-double" class="nav-link" data-scroll-target="#números-reais-double"><span class="header-section-number">2.5.2</span> Números reais (<code>double</code>)</a></li>
  <li><a href="#números-inteiros-integer" id="toc-números-inteiros-integer" class="nav-link" data-scroll-target="#números-inteiros-integer"><span class="header-section-number">2.5.3</span> Números inteiros (<code>integer</code>)</a></li>
  <li><a href="#o-tipo-numérico-numeric" id="toc-o-tipo-numérico-numeric" class="nav-link" data-scroll-target="#o-tipo-numérico-numeric"><span class="header-section-number">2.5.4</span> O tipo numérico (<code>numeric</code>)</a></li>
  <li><a href="#valores-lógicos-logical" id="toc-valores-lógicos-logical" class="nav-link" data-scroll-target="#valores-lógicos-logical"><span class="header-section-number">2.5.5</span> Valores lógicos (<code>logical</code>)</a></li>
  </ul></li>
  <li><a href="#sec:funcoes_str_is" id="toc-sec:funcoes_str_is" class="nav-link" data-scroll-target="#sec\:funcoes_str_is"><span class="header-section-number">2.6</span> Identificando tipos e estruturas com a função <code>str()</code> e as funções <code>is.*()</code></a>
  <ul class="collapse">
  <li><a href="#tome-muito-cuidado-com-is.vector-e-is.numeric" id="toc-tome-muito-cuidado-com-is.vector-e-is.numeric" class="nav-link" data-scroll-target="#tome-muito-cuidado-com-is.vector-e-is.numeric"><span class="header-section-number">2.6.1</span> Tome muito cuidado com <code>is.vector()</code> e <code>is.numeric()</code></a></li>
  </ul></li>
  <li><a href="#sec:coercion_R_fundamentos" id="toc-sec:coercion_R_fundamentos" class="nav-link" data-scroll-target="#sec\:coercion_R_fundamentos"><span class="header-section-number">2.7</span> Coerção no R</a>
  <ul class="collapse">
  <li><a href="#a-árvore-de-coerção" id="toc-a-árvore-de-coerção" class="nav-link" data-scroll-target="#a-árvore-de-coerção"><span class="header-section-number">2.7.1</span> A árvore de coerção</a></li>
  <li><a href="#coerções-explícitas-com-as-funções-as." id="toc-coerções-explícitas-com-as-funções-as." class="nav-link" data-scroll-target="#coerções-explícitas-com-as-funções-as."><span class="header-section-number">2.7.2</span> Coerções explícitas com as funções <code>as.*()</code></a></li>
  <li><a href="#também-podemos-converter-estruturas-de-dados-com-as-funções-as." id="toc-também-podemos-converter-estruturas-de-dados-com-as-funções-as." class="nav-link" data-scroll-target="#também-podemos-converter-estruturas-de-dados-com-as-funções-as."><span class="header-section-number">2.7.3</span> Também podemos converter estruturas de dados com as funções <code>as.*()</code></a></li>
  </ul></li>
  <li><a href="#um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r" id="toc-um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r" class="nav-link" data-scroll-target="#um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r"><span class="header-section-number">2.8</span> Um estudo de caso: importando os dados da PINTEC-IBGE para o R</a></li>
  <li><a href="#subsetting" id="toc-subsetting" class="nav-link" data-scroll-target="#subsetting"><span class="header-section-number">2.9</span> <em>Subsetting</em></a>
  <ul class="collapse">
  <li><a href="#principais-diferenças-entre-as-funções-e" id="toc-principais-diferenças-entre-as-funções-e" class="nav-link" data-scroll-target="#principais-diferenças-entre-as-funções-e"><span class="header-section-number">2.9.1</span> Principais diferenças entre as funções <code>[</code> e <code>[[</code>:</a></li>
  <li><a href="#dimensões-disponíveis-em-subsetting" id="toc-dimensões-disponíveis-em-subsetting" class="nav-link" data-scroll-target="#dimensões-disponíveis-em-subsetting"><span class="header-section-number">2.9.2</span> Dimensões disponíveis em <em>subsetting</em></a></li>
  <li><a href="#tipos-de-índices" id="toc-tipos-de-índices" class="nav-link" data-scroll-target="#tipos-de-índices"><span class="header-section-number">2.9.3</span> Tipos de índices</a></li>
  <li><a href="#o-operador-e-a-estrutura-do-resultado" id="toc-o-operador-e-a-estrutura-do-resultado" class="nav-link" data-scroll-target="#o-operador-e-a-estrutura-do-resultado"><span class="header-section-number">2.9.4</span> O operador <code>$</code> e a estrutura do resultado</a></li>
  </ul></li>
  <li><a href="#valores-especiais-do-r" id="toc-valores-especiais-do-r" class="nav-link" data-scroll-target="#valores-especiais-do-r"><span class="header-section-number">2.10</span> Valores especiais do R</a>
  <ul class="collapse">
  <li><a href="#sec:impactos_valores_especiais" id="toc-sec:impactos_valores_especiais" class="nav-link" data-scroll-target="#sec\:impactos_valores_especiais"><span class="header-section-number">2.10.1</span> Os impactos desses valores especiais</a></li>
  <li><a href="#valores-especiais-também-estão-associados-a-algum-tipo-de-dado" id="toc-valores-especiais-também-estão-associados-a-algum-tipo-de-dado" class="nav-link" data-scroll-target="#valores-especiais-também-estão-associados-a-algum-tipo-de-dado"><span class="header-section-number">2.10.2</span> Valores especiais também estão associados a algum tipo de dado</a></li>
  <li><a href="#como-identificar-valores-especiais" id="toc-como-identificar-valores-especiais" class="nav-link" data-scroll-target="#como-identificar-valores-especiais"><span class="header-section-number">2.10.3</span> Como identificar valores especiais</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Capítulos/01-nocoes-basicas.html">Introduzindo a Linguagem R</a></li><li class="breadcrumb-item"><a href="../Capítulos/02-fundamentos.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Fundamentos da Linguagem R</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Fundamentos da Linguagem R</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec:fundamentos_R" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec:fundamentos_R"><span class="header-section-number">2.1</span> Introdução</h2>
<p>Nas próximas seções vou abordar os fundamentos da linguagem: os básicos de sua sintaxe, quais são as estruturas e tipos de dados que a linguagem oferece, e como as suas regras de <em>coercion</em> funcionam.</p>
<p>Na maior parte do tempo, você não vai estar interessado em como o R está estruturando ou interpretando os seus dados. Porém, várias das funções ou ações que você deseja aplicar, exigem que os seus dados estejam estruturados em um formato específica. Logo, ter familiaridade com os fundamentos do R, com as suas estruturas e suas propriedades, e principalmente, poder reconhecê-las, vai te salvar muito tempo. Com esse conhecimento, será mais fácil de você evitar erros, e será mais fácil de identificar e transformar a estrutura de seus dados para qualquer que seja a sua necessidade em um dado momento de sua análise.</p>
</section>
<section id="mais-detalhes-sobre-objetos" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="mais-detalhes-sobre-objetos"><span class="header-section-number">2.2</span> Mais detalhes sobre objetos</h2>
<p>Uma das principais características do R é que ele é uma linguagem orientada a objetos (<em>object oriented</em>). Isto significa, que quando você estiver trabalhando com seus dados no R, você estará constantemente aplicando operações e transformações sobre os objetos onde seus dados estão guardados.</p>
<p>Um objeto no R é como uma caixa que você utiliza na sua mudança de casa. Você guarda algo dentro dessa caixa, e escreve na lateral um nome (ou um “rótulo”) para essa caixa, para que você se lembre do que está dentro dela. No dia seguinte à mudança, quando você precisar do conteúdo que está guardado naquela caixa, você procura essa caixa pelo nome que você deu a ela.</p>
<p>No exemplo abaixo, eu estou criando um objeto. Dou o nome de <code>data_aniversario</code> para este objeto, e estou utilizando o símbolo <code>&lt;-</code> para definir o valor deste objeto. Agora, este objeto guarda a data de aniversário de um amigo importante (20 de maio). O símbolo <code>&lt;-</code> é comumente chamado de <em>assignment</em>, e significa que estamos atribuindo um valor a um objeto (no caso abaixo, <code>data_aniversario</code>). Em outras palavras, os comandos abaixo, podem ser lidos como: eu atribuo ao objeto de nome <code>data_aniversario</code>, o valor de <code>"20 de maio"</code>. Após isso, sempre que eu chamar por esse nome, o R irá procurar por uma caixa (ou um objeto) que possui o nome de <code>data_aniversario</code>. Quando ele encontrar essa caixa, ele irá me retornar no console o que tem dentro dessa caixa (ou desse objeto).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>data_aniversario <span class="ot">&lt;-</span> <span class="st">"20 de maio"</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="do">### Quando eu chamo pelo nome deste objeto</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="do">### no console, o R me retorna o que tem dentro dele.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>data_aniversario</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "20 de maio"</code></pre>
</div>
</div>
<p>Este conceito de “objeto” é simplesmente uma metáfora, ou uma forma útil de enxergarmos este sistema. Pois para o R, o nome <code>data_aniversario</code> se trata apenas uma conexão até o valor (<code>"20 de maio"</code>). Para demonstrarmos essa ideia, vamos utilizar os endereços desses objetos. Isto é, todos os valores contidos nos objetos que você cria em sua sessão do R, vão obrigatoriamente ocupar um espaço, ou um endereço da memória RAM de seu computador. Enquanto este objeto estiver “vivo”, ou seja, enquanto esta conexão entre o nome <code>x</code> e os seus valores permanecer acessível em sua sessão, esses valores vão estar ocupando um endereço específico de sua memória RAM. Para descobrirmos esse endereço, nós podemos utilizar a função <code>ref()</code> do pacote <code>lobstr</code>. Vamos supor por exemplo, que nós criamos um vetor chamado <code>x</code>, que contém três números. Perceba abaixo pelo resultado da função <code>ref()</code>, que ao criar este objeto <code>x</code>, os seus valores foram alocados no endereço <code>0x1ca169c03d8</code> da minha memória RAM.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lobstr)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ref</span>(x)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>## [1:0x1ca169c03d8] &lt;dbl&gt; </code></pre>
<p>Portanto, um objeto no R, nada mais é do que uma conexão entre um nome e valores que estão guardados em um endereço específico da memória RAM de seu computador. Os únicos momentos em que este endereço muda são: 1) todas as vezes em que você reiniciar a sua sessão no R; 2) ou todas as vezes em que você executar novamente os códigos necessários para criar os seus objetos. Tendo isso em mente, um objeto no R pode ser representado pela <a href="#fig-objetos1" class="quarto-xref">Figura&nbsp;<span>2.1</span></a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-objetos1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-objetos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/objetos_1.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-objetos1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.1: Representação de um objeto
</figcaption>
</figure>
</div>
</div>
</div>
<p>Para desenvolvermos essa ideia, pense o que ocorreria, se atribuíssemos os valores do objeto <code>x</code>, a um novo objeto. Segundo essa perspectiva, nós estaríamos apenas conectando o vetor com os valores 6, 7 e 8, a um novo nome, no exemplo abaixo, ao nome <code>y</code>. Nós poderíamos utilizar novamente a função <code>ref()</code> para conferirmos o endereço onde os valores do objeto <code>y</code>, se encontram, e perceba que eles estão no mesmo local que os valores do objeto <code>x</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> x</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ref</span>(y)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>## [1:0x1ca169c03d8] &lt;dbl&gt; </code></pre>
<p>Logo, se atualizarmos a nossa representação visual, temos o seguinte resultado:</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-objetos2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-objetos2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/objetos_2.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-objetos2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.2: Conectando mais nomes a um mesmo conjunto de valores
</figcaption>
</figure>
</div>
</div>
</div>
<p>Em outras palavras, o R em nenhum momento criou uma cópia do vetor contendo os valores 6, 7 e 8, e alocou essa cópia no objeto <code>y</code>. Ele apenas conectou um novo nome (<code>y</code>) a esse vetor de valores. Por isso, quando você possui um objeto, e atribui um novo valor a este objeto, você está na verdade eliminando a conexão que o nome deste objeto possuía com o valor que estava guardado anteriormente naquele objeto. Ou seja, se você retornar ao vetor <code>x</code>, e definir um novo valor para ele, você estaria eliminando a sua conexão com o vetor que contém os números 6, 7 e 8, e atribuindo essa conexão a um outro conjunto de valores. Por exemplo, caso eu executasse o comando <code>x &lt;- "Hello World"</code>, o resultado seria uma nova conexão como você pode ver pela <a href="#fig-objetos3" class="quarto-xref">Figura&nbsp;<span>2.3</span></a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-objetos3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-objetos3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/objetos_3.png" class="img-fluid figure-img" style="width:60.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-objetos3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.3: Atribuindo novos valores a seus objetos
</figcaption>
</figure>
</div>
</div>
</div>
<p>O R vai automaticamente eliminar qualquer valor que não esteja conectado a um nome (isto é, um objeto em sua sessão). Logo, tendo em mente a <a href="#fig-objetos3" class="quarto-xref">Figura&nbsp;<span>2.3</span></a>, caso eu atribuísse um novo valor ao objeto <code>y</code>, a última conexão existente até o vetor que contém os números 6, 7 e 8, seria eliminada. Com isso, este vetor não possuiria mais nenhuma conexão até um nome e, por isso, esses valores seriam descartados pelo R. Portanto, se você precisa atribuir um novo valor para um determinado objeto, mas deseja manter o valor que você deu a ele anteriormente vivo de alguma forma, basta que você crie uma nova conexão até esse valor. Em outras palavras, se você quer manter este valor vivo, basta conectá-lo a um novo objeto.</p>
<p>No exemplo abaixo, eu crio um objeto (<code>economista_1</code>) contendo o nome de um economista famoso, e em seguida conecto este nome a um novo objeto (<code>economista_anterior</code>). Portanto, o nome de Keynes está agora conectado a dois nomes (isto é, ele está contido em dois objetos diferentes em sua sessão no R). Por último, eu sobreponho o nome de Keynes que guardei no primeiro objeto (<code>economista_1</code>), pelo nome de outro economista famoso. Quando faço isso, estou efetivamente eliminando uma das conexões até o nome de Keynes, e atribuindo essa conexão ao nome de Schumpeter. Porém, como o nome de Keynes ainda possui uma conexão existente (<code>economista_anterior</code>), o nome continua “vivo” e presente em nossa sessão, e se quisermos acessar novamente esse nome, basta chamarmos pelo objeto onde o salvamos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Primeiro valor</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>economista_1 <span class="ot">&lt;-</span> <span class="st">"John Maynard Keynes"</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Atribuindo o primeiro valor a um novo</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># objeto</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>economista_anterior <span class="ot">&lt;-</span> economista_1</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Sobrepondo o primeiro valor no</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># primeiro objeto com um novo nome</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>economista_1 <span class="ot">&lt;-</span> <span class="st">"Joseph Alois Schumpeter"</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>economista_1</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Joseph Alois Schumpeter"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>economista_anterior</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "John Maynard Keynes"</code></pre>
</div>
</div>
</section>
<section id="como-o-r-organiza-e-interpreta-os-seus-dados" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="como-o-r-organiza-e-interpreta-os-seus-dados"><span class="header-section-number">2.3</span> Como o R organiza e interpreta os seus dados</h2>
<p>Aqui temos duas questões distintas, mas que estão interconectadas. A primeira, se refere a como o R organiza os seus dados. Já a segunda questão, se refere a como o R interpreta os seus dados. A primeira questão fala das diferentes formas que o R possui para estruturar e organizar os seus dados. Essas formas são chamadas de <strong>estruturas de dados</strong>. A <a href="#fig-estrutura-dados" class="quarto-xref">Figura&nbsp;<span>2.4</span></a> apresenta essa questão de forma visual.</p>
<p>Já a segunda questão, fala dos diferentes tipos de dados que o R pode trabalhar com. Ou seja, todo objeto existente no R é interpretado de uma determinada maneira. É como se o R atribuísse uma cor para cada objeto: “Ah este objeto é vermelho! Opa, este objeto parece ser azul! E esse? Será que é verde? Não, acho que ele é amarelo mesmo”. Para todo objeto existente, o R atribui um tipo de dado específico a ele. Tudo depende do tipo de dado que está armazenado dentro deste objeto. A <a href="#fig-tipos-dados" class="quarto-xref">Figura&nbsp;<span>2.5</span></a> apresenta essa questão de forma visual.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-estrutura-dados" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-estrutura-dados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/estrutura-dados.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-estrutura-dados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.4: Estruturas de dados
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-tipos-dados" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tipos-dados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/tipos_dados.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tipos-dados-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.5: Tipos de dados
</figcaption>
</figure>
</div>
</div>
</div>
<p>Tanto a estrutura de dados que está sendo utilizada em um objeto, quanto o tipo de dado atribuído a ele, são partes de extrema importância no R. Pois cada função no R pode esperar como <em>input</em>, um objeto que esteja em um tipo ou estrutura de dados específicos. Além disso, em alguns casos, o R pode aplicar diferentes “versões” de uma mesma função sobre o seu objeto, a depender do tipo de dado associado a ele.</p>
<p>Portanto, estamos nos perguntando qual o tipo de dado que o R está associando a um certo conjunto de valores, e em muitas ocasiões, podemos nos surpreender com as escolhas da linguagem. Tal surpresa está representada na <a href="#fig-tipos-dados" class="quarto-xref">Figura&nbsp;<span>2.5</span></a>. Por exemplo, quando eu vejo o valor <code>"20/05/2020"</code>, eu rapidamente o associo ele à data 20 de maio de 2020, mas será que o R compreende que este valor se trata de uma data? A resposta curta é, não.</p>
<p>Pelo fato das datas não estarem entre os tipos de dados básicos do R, enquanto não dissermos explicitamente para o R que se tratam de datas, valores como <code>"20/05/2020"</code> são tratados inicialmente como simples textos (isto é, valores do tipo <code>character</code>). Isso é um ponto importante, pois várias funções ou ações que queremos executar no R, exigem que os seus dados estejam no tipo adequado. Por isso, você vai enfrentar diversas situações onde o console lhe retorna um erro confuso, e depois de alguns minutos analisando os seus comandos e conferindo a estrutura de seus dados, você se supreende, e descobre que o R estava o tempo todo interpretando os seus números como textos!</p>
<p>Inicialmente, vamos descrever nas próximas seções as estruturas de dados presentes na linguagem. Em seguida, partimos para os tipos de dados básicos do R. Nessas seções, não vamos incluir uma estrutura do R em específico, que é o <code>array</code>. Nós veremos mais a frente, as matrizes (<code>matrix</code>), que no fundo são um caso especial de <code>array</code>. Enquanto matrizes são vetores com duas dimensões (uma dimensão para as linhas e outra para as colunas), os <code>array</code> são vetores com “n” dimensões. Em outras palavras, com um <code>array</code> você pode criar um objeto tridimensional (3 dimensões), ou se quiser ir longe, um objeto com 4, 5, ou infinitas dimensões.</p>
</section>
<section id="sec:estruturas_dados" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec:estruturas_dados"><span class="header-section-number">2.4</span> Estruturas de dados</h2>
<section id="sec:vetores_estrutura" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="sec:vetores_estrutura"><span class="header-section-number">2.4.1</span> Vetores</h3>
<p>Os vetores são a estrutura básica da linguagem R, pois todas as outras estruturas, são construídas a partir desses vetores. <strong>Um vetor é simplesmente uma sequência de valores</strong>. Valores que podem ser datas, números, textos, índices, ou qualquer outro tipo que você imaginar. Pelo fato de ser uma simples sequência de valores, o vetor é uma estrutura unidimensional. É como se esse vetor fosse composto por apenas uma coluna, que você preenche com quantas linhas você precisar. Ou então, você também pode imaginá-lo como uma corda, que amarra e mantém os seus valores conectados um atrás do outro.</p>
<p>A forma mais simples de se criar um vetor, é através da função <code>c()</code> (abreviação para <em>combine</em>, ou combinar), em que você fornece os valores que quer incluir neste vetor, separando-os por vírgulas. A outra forma (indireta) de se criar um vetor, é através de funções que retornam por padrão este tipo de estrutura. Um exemplo simples, é a função <code>:</code> que serve para criar sequências numéricas no R, no exemplo abaixo, uso essa função para criar uma sequência de 1 a 10. Outro exemplo, seria a função <code>rep()</code> que serve para repetir um conjunto de valores, por quantas vezes você quiser.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="dv">48</span>, <span class="dv">24</span>, <span class="dv">12</span>, <span class="dv">6</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 48 24 12  6</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a" "b" "c" "d"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">times =</span> <span class="dv">5</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Ana"     "Eduardo" "Ana"     "Eduardo" "Ana"     "Eduardo" "Ana"    
 [8] "Eduardo" "Ana"     "Eduardo"</code></pre>
</div>
</div>
<p>Como o vetor é uma estrutura unidimensional, eu posso acessar um único valor dentro desse vetor, utilizando apenas um índice. Por exemplo, se eu quero extrair o quarto valor dessa sequência, eu utilizo o número 4, se eu quero o terceiro valor, o número 3, e assim por diante. Para acessar “partes”, ou um único valor de uma estrutura no R, nós utilizamos a função <code>[</code>, e para utilizá-la, basta abrir colchetes após o nome do objeto onde você salvou este vetor, ou após a função que está gerando este vetor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>vetor[<span class="dv">4</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>)[<span class="dv">3</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "c"</code></pre>
</div>
</div>
<p>Para acessar mais de um valor dentro deste vetor, você terá que fornecer um novo vetor de índices à função <code>[</code>. Um jeito prático de criar este novo vetor de índices, é criando uma sequência com a função <code>:</code> que vimos anteriormente. Um detalhe, é que o R irá extrair os valores na ordem em que você os dá a <code>[</code>. Logo, se eu dentro de <code>[</code> incluir o vetor <code>c(2,4,6,1)</code>, o R irá lhe retornar um novo vetor, que contém o segundo, quarto, sexto e primeiro item do vetor anterior, respectivamente. Caso você repita algum índice, o R irá repetir o valor dentro do vetor resultante, e não te avisará sobre isso.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">25</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>vetor[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1 2 3 4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>vetor[<span class="dv">8</span><span class="sc">:</span><span class="dv">13</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  8  9 10 11 12 13</code></pre>
</div>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>vetor[<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2 4 4 1</code></pre>
</div>
</div>
<p>Os vetores que estamos criando com essas funções são comumente chamados de vetores atômicos (<em>atomic vector</em>). Esses vetores possuem uma propriedade simples e importante: <strong>vetores atômicos possuem apenas um único tipo de dado dentro deles</strong>. Você não consegue guardar dentro de um mesmo vetor, valores de dois tipos de dados diferentes (por exemplo, textos e números) sem que alguma transformação ocorra. Caso você tente burlar essa regra, o R irá automaticamente converter os valores para um único tipo de dado, e pode ser que parte desses dados não possam ser convertidos de forma lógica para este único tipo, e acabam sendo “perdidos” neste processo. Falaremos mais sobre esse processo de conversão, quando chegarmos em tipos de dados.</p>
</section>
<section id="matrizes" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="matrizes"><span class="header-section-number">2.4.2</span> Matrizes</h3>
<p>Matrizes nada mais são do que vetores com duas dimensões. Se você possui dados atualmente alocados em um vetor, e deseja organizá-los em colunas e linhas, você pode rapidamente criar uma matriz com este vetor, ao adicionar dimensões a ele, através da função <code>dim()</code>. Você usa a função sobre o vetor desejado à esquerda do símbolo de <em>assignment</em> (<code>&lt;-</code>), e atribui um valor ao resultado dessa função. No caso de matrizes, esse valor será um vetor com dois elementos, o primeiro definindo o número de linhas, e o segundo, o número de colunas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(vetor) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">2</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>vetor</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6</code></pre>
</div>
</div>
<p>Uma outra forma de criar uma matriz, é através da função <code>matrix()</code>. Você primeiro fornece um vetor à função, e define quantas colunas você deseja em <code>ncol</code>, e quantas linhas em <code>nrow</code>. Um detalhe que fica claro no exemplo abaixo, é que ao criar uma matriz, ela por padrão será preenchida por coluna, e não por linha. Caso você queira que ela seja preenchida por linha, você deve adicionar o valor <code>TRUE</code>, ao argumento <code>byrow</code> na função.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Para preencher a matriz, por linha, adicione</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co"># byrow = TRUE à função</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, <span class="at">nrow =</span> <span class="dv">5</span>, <span class="at">ncol =</span> <span class="dv">4</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20</code></pre>
</div>
</div>
<p>Os vetores são estruturas unidimensionais, e com apenas um índice poderíamos acessar um valor contido nele. Porém, as matrizes possuem duas dimensões, logo, temos que fornecer dois índices à função <code>[</code> para acessarmos um único elemento dessa matriz. Basta você separar esses dois índices por uma vírgula, onde o primeiro valor corresponde a linha, e o segundo, a coluna desejada. No exemplo abaixo, estou extraindo o elemento que se encontra na terceira linha da quarta coluna.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>matriz <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, <span class="at">nrow =</span> <span class="dv">5</span>, <span class="at">ncol =</span> <span class="dv">4</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>matriz[<span class="dv">3</span>,<span class="dv">4</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 18</code></pre>
</div>
</div>
<p>Eu posso também extrair uma parte dessa matriz, ao fornecer mais valores dentro de um vetor, para cada um dos dois índices. No primeiro exemplo abaixo, eu extraio todos os valores da primeira a terceira linha da segunda coluna da matriz. Agora, caso eu queira extrair todos os valores de uma dimensão (todas as linhas, ou todas as colunas), basta que eu deixe em “branco” ao lado de cada índice. No segundo exemplo abaixo, estou extraindo todos os valores da segunda coluna.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>matriz[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">2</span>] <span class="co"># É o mesmo que: matriz[c(1,2,3), 2]</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 6 7 8</code></pre>
</div>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>matriz[ , <span class="dv">2</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  6  7  8  9 10</code></pre>
</div>
</div>
<p>Pelo fato de matrizes serem vetores com duas dimensões, elas herdam a propriedade do vetor, e, portanto: <strong>matrizes podem conter dados de apenas um único tipo</strong>. Por essa característica, você provavelmente utilizará essa estrutura poucas vezes. De qualquer forma é útil conhecê-la.</p>
</section>
<section id="sec:estrutura_listas" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="sec:estrutura_listas"><span class="header-section-number">2.4.3</span> Listas</h3>
<p>A lista é uma estrutura especial e muito importante do R, pois ela é a exceção da propriedade dos vetores (que podem conter apenas um tipo de dado). <strong>Portanto, uma lista é um vetor, onde cada elemento deste vetor pode ser não apenas de um tipo de dado diferente, mas também de tamanho e estrutura diferentes.</strong> Dito de outra forma, você pode incluir o que você quiser em cada elemento de uma lista.</p>
<p>Uma lista é criada pela função <code>list()</code>, e para utilizá-la, basta fornecer os valores que deseja inserir em cada elemento desta lista, separados por vírgulas. No exemplo abaixo, estou inserindo no primeiro elemento desta lista a data que vimos anteriormente (“20/05/2020”), no segundo, estou incluindo uma matriz, no terceiro, um vetor com nomes, e no quarto, um <code>data.frame</code> (falaremos sobre eles após essa seção).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Lista nomeada</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co"># nome = valor</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>lista <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="st">"20/05/2020"</span>,</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">matriz =</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, <span class="at">ncol =</span> <span class="dv">4</span>, <span class="at">nrow =</span> <span class="dv">5</span>),</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">vetor =</span> <span class="fu">c</span>(<span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span>, <span class="st">"Macapá"</span>),</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">tabela =</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="dv">21</span><span class="sc">:</span><span class="dv">30</span>, <span class="at">y =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>))</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>lista</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$data
[1] "20/05/2020"

$matriz
     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20

$vetor
[1] "Belo Horizonte" "Londrina"       "Macapá"        

$tabela
    x           y
1  21  2.08749847
2  22  0.89801652
3  23  0.52684742
4  24  0.05447599
5  25 -0.68582890
6  26 -0.65862147
7  27 -0.53714919
8  28  0.37764936
9  29 -1.28045042
10 30  0.58714905</code></pre>
</div>
</div>
<p>Perceba que nós nomeamos cada elemento dessa lista. Isso abre novas possibilidades, pois agora podemos utilizar um sistema diferente da função <code>[</code> para acessarmos os valores específicos de uma lista, utilizando o operador <code>$</code>. Através deste operador, podemos acessar os elementos dessa lista, através do nome que demos para cada um deles. O problema deste sistema, é que ele lhe permite acessar todos os valores contidos em um elemento de sua lista, mas não lhe permite extrair valores específicos contidos em cada um destes elementos da lista.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>lista<span class="sc">$</span>matriz</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20</code></pre>
</div>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>lista<span class="sc">$</span>vetor</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Belo Horizonte" "Londrina"       "Macapá"        </code></pre>
</div>
</div>
<p>Você não precisa nomear cada um dos elementos dessa lista como fizemos acima. Eu nomeie apenas para dar um exemplo do operador <code>$</code>. Porém, neste caso em que você não atribui um nome a esses elementos, você não pode acessá-los mais pelo operador <code>$</code>, e terá que retornar à funçaõ <code>[</code> para tal serviço. Em outras palavras, se você deseja criar uma lista, mas não está muito preocupado em nomear cada um dos elementos que vão estar nessa lista, basta separar esses valores por vírgulas como no exemplo abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>lista <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>),</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>),</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(T, F, T)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>lista</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] 6 7 8

[[2]]
[1] "a" "b" "c"

[[3]]
[1]  TRUE FALSE  TRUE</code></pre>
</div>
</div>
<p>Antes de prosseguirmos, darei uma nova descrição (dessa vez, uma descrição visual) de uma lista, para que você fixe na sua cabeça o que ela é. Eu espero que eu tenha desejado bem o suficiente, para que você seja capaz de identificar um trem carregando quatro vagões na <a href="#fig-lista1" class="quarto-xref">Figura&nbsp;<span>2.6</span></a>. Podemos pensar esse trem como uma lista, e os seus vagões como os elementos dessa lista. Tendo isso em mente, temos na <a href="#fig-lista1" class="quarto-xref">Figura&nbsp;<span>2.6</span></a> uma representação de uma lista com quatro elementos.</p>
<p>Como disse anteriormente, podemos incluir o que quisermos dentro de cada elemento dessa lista, ou dentro de cada vagão desse trem. Pois cada vagão é capaz de comportar elementos de qualquer dimensão e em qualquer estrutura, e como esses vagões estão separados uns dos outros, esses elementos não precisam compartilhar das mesmas características. Dito de outra forma, eu posso carregar 15 toneladas de ouro no primeiro vagão, 100 Kg de carvão no segundo vagão, e 1 Kg de ferro no terceiro vagão.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-lista1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lista1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/lista.png" class="img-fluid figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lista1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.6: Representação de uma lista
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-lista2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lista2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/colchetes.png" class="img-fluid figure-img" style="width:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lista2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.7: Diferença entre um e dois colchetes em listas
</figcaption>
</figure>
</div>
</div>
</div>
<p>Portanto, a lista é uma estrutura que lhe permite transportar todos esses diferentes elementos, em um mesmo objeto no R (ou todos esses diferentes componentes em um mesmo trem). Quando chegarmos em interação, você verá que essa característica torna a lista, uma estrutura extremamente útil.</p>
<p>Agora como eu posso extrair valores dessa lista através da função <code>[</code> ? Bem, a lista é a exceção da propriedade dos vetores, mas ela continua sendo um vetor em sua essência, ou uma estrutura unidimensional. Por isso, você pode acessar um item de uma lista com apenas um índice dentro de <code>[</code>.</p>
<p>Porém, caso você usar apenas um colchete para selecionar o primeiro elemento de sua lista, você percebe que uma pequena descrição (<code>"[[1]]"</code>), ou o nome que você deu aquele elemento, aparece em cima dos valores contidos neste elemento da lista. Por isso, se você deseja extrair apenas os valores desse elemento, sem essa descrição, você deve utilizar o índice dentro de dois colchetes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>lista <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"O ano tem 365 dias"</span>,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>, <span class="at">ncol =</span> <span class="dv">4</span>, <span class="at">nrow =</span> <span class="dv">5</span>)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>lista[<span class="dv">1</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
</div>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>lista[[<span class="dv">1</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre>
</div>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>lista[[<span class="dv">2</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "O ano tem 365 dias"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>lista[[<span class="dv">3</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4]
[1,]    1    6   11   16
[2,]    2    7   12   17
[3,]    3    8   13   18
[4,]    4    9   14   19
[5,]    5   10   15   20</code></pre>
</div>
</div>
<p>Isso ocorre, porque quando você utiliza apenas um colchete para selecionar o primeiro elemento, o R acaba lhe retornando uma nova lista contendo um elemento, e não apenas o que está dentro deste elemento em si. Dizendo em termos da representação visual que utilizamos na <a href="#fig-lista1" class="quarto-xref">Figura&nbsp;<span>2.6</span></a>, se eu possuo um trem com quatro vagões, e utilizo um colchete para selecionar o primeiro vagão, o R me retorna um novo trem que contém o primeiro vagão. Mas se eu utilizo dois colchetes, o R me retorna apenas o primeiro vagão, e nada mais.</p>
<p>Mas como eu faço para extrair um valor específico de um elemento de uma lista? Para isso você deve abrir um novo colchete após os colchetes duplos que você criou para selecionar o elemento da lista (como mostrado na <a href="#fig-lista2" class="quarto-xref">Figura&nbsp;<span>2.7</span></a>). A partir daí, basta replicar o que vimos anteriormente com os índices. No exemplo abaixo, estou primeiro selecionando o terceiro elemento da nossa lista (que é uma matriz). Em seguida, eu seleciono o item da terceira linha da primeira coluna desta matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>lista[[<span class="dv">3</span>]][<span class="dv">3</span>,<span class="dv">1</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
</div>
</section>
<section id="sec:estrutura_data_frames" class="level3" data-number="2.4.4">
<h3 data-number="2.4.4" class="anchored" data-anchor-id="sec:estrutura_data_frames"><span class="header-section-number">2.4.4</span> Tabelas no R: <code>data.frame</code></h3>
<p>O <code>data.frame</code> é a principal estrutura utilizada para guardar tabelas e bases de dados no R (esta estrutura é semelhante ao <code>DataFrame</code> no framework <code>pandas</code> do Python). Na grande maioria das vezes que você importar os seus dados para o R, eles serão alocados dentro de um <code>data.frame</code>. Essa estrutura é no fundo, uma lista com algumas propriedades a mais. Por isso, o <code>data.frame</code> herda uma das propriedades da lista: <strong>cada uma das colunas da tabela formada por um <code>data.frame</code>, pode conter um tipo de dado diferente das demais colunas deste <code>data.frame</code>.</strong></p>
<p>Esta é uma das principais características que tornam o <code>data.frame</code>, uma estrutura adequada para guardar a grande maioria das bases de dados. Pois é muito comum, que você possua em sua base, diversas colunas contendo dados de diferentes tipos. Por exemplo, você pode ter uma base que possui uma coluna contendo datas, outras duas contendo valores numéricos, e uma última coluna contendo textos, ou rótulos indicando a qual indicador ou grupo, os valores numéricos da linha se referem. E ao importar uma base como essa para o R, é de seu desejo que o R interprete essas colunas corretamente e mantenha os tipos desses dados intactos.</p>
<p>Os <code>data.frame</code>’s são criados pela função <code>data.frame()</code>. Você deve preencher essa função com os valores que você deseja alocar em cada coluna separados por vírgulas. Você pode escolher não dar um nome a cada coluna, neste caso a função se ocupará de dar um nome genérico para elas. Caso opte por definir esses nomes, você deve fornecê-los antes dos valores da coluna, seguindo a seguinte estrutura:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Estrutura Básica:</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co"># data.frame(</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   &lt;nome_coluna&gt; = &lt;valor_coluna&gt; </span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co"># )</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">nomes =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">times =</span> <span class="dv">5</span>),</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">numeros =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">constante =</span> <span class="dv">25</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     nomes     numeros constante
1      Ana -1.57576271        25
2  Eduardo -1.10535066        25
3      Ana -0.85332690        25
4  Eduardo -0.44557751        25
5      Ana  0.20310147        25
6  Eduardo  0.34410449        25
7      Ana  0.04130259        25
8  Eduardo -0.08708728        25
9      Ana -1.45232309        25
10 Eduardo -1.18069340        25</code></pre>
</div>
</div>
<p>Caso você esteja em dúvida, tudo o que a função <code>rnorm()</code> faz é gerar valores aleatórios seguindo uma distribuição normal. Vemos que no exemplo acima, geramos uma tabela com 3 colunas e 10 linhas, e aqui chego a segunda principal propriedade de um <code>data.frame</code>, que é: <strong>todas as colunas de um <code>data.frame</code> devem possuir o mesmo número de linhas</strong>. O motivo dessa propriedade é um pouco óbvio, pois se estamos tentando formar uma tabela de dados, é natural pensarmos que ela deve formar um retângulo uniforme.</p>
<p>Isso significa, que se eu pedisse para a função <code>rep()</code> repetir os valores 6 vezes (ao invés de 5), gerando assim um vetor de 12 elementos (ou 12 linhas), a função <code>data.frame()</code> me retornaria um erro, indicando que o número de linhas criadas pelos diferentes vetores não possuem o mesmo número de linhas.</p>
<p>Caso não tivéssemos essa propriedade, estaríamos permitindo que alguma dessas colunas deste <code>data.frame</code>, fosse mais longa do que as outras. Neste caso, como você lidaria com as observações “sobressalentes” da tabela ? Você possui um valor na coluna x que não possui um valor correspondente na coluna y, será que você considera o valor da coluna y como vazio ? Não disponível ? Não existente ? Enfim, uma confusão que é desnecessária.</p>
<p>Essa propriedade nos garante que para cada observação (ou linha) da nossa tabela, deve <strong>sempre</strong> existir um valor na coluna y correspondente ao valor da coluna x, mesmo que o valor da coluna y seja um valor <code>NA</code> (não disponível), ou algo indicando que não foi possível coletar esse valor no plano físico de nossa atividade.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./../Figuras/data_frame_representacao.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Representação de um <code>data.frame</code> a partir de uma lista</figcaption>
</figure>
</div>
</div>
</div>
<p>Ao voltar para o exemplo acima, você pode perceber que na terceira coluna que definimos em <code>data.frame()</code>, demos uma simples constante (25) à função. Como resultado, a função acaba preenchendo toda a coluna por essa constante. Isso ocorre sempre que você fornece um único valor a uma coluna de seu <code>data.frame</code>, seja este valor, uma data, um texto, um número ou qualquer outro tipo que imaginar.</p>
<p>A partir daqui, é interessante criarmos um modelo visual em nossa cabeça, sobre o que um <code>data.frame</code> representa. Como disse anteriormente, um <code>data.frame</code>, é basicamente uma lista, com algumas propriedades a mais, em especial a propriedade de que todos os seus elementos devem possuir o mesmo número de linhas. Portanto, se você quer imaginar um <code>data.frame</code> em sua mente, você pode imaginar uma lista, onde cada um de seus elementos, representa uma coluna desse <code>data.frame</code>. Em conjunto, essas colunas (ou os elementos dessa lista) formam uma tabela, sendo essa tabela, comumente referida como um <code>data.frame</code>.</p>
<p>Vale destacar um outro comportamento da função <code>data.frame()</code>. Ela transforma por padrão, todos os textos em fatores (<em>factor</em>), ou em outras palavras, valores de uma variável categórica que possui um conjunto limitado de valores possíveis. Vamos aprender mais sobre este tipo de dados nas próximas seções. Inicialmente, isso não tem grandes implicações sobre os seus dados. Eles vão continuar sendo apresentados como textos, e a única grande mudança será sobre a forma como o R irá ordenar esses valores caso você peça isso a ele. Mas é importante saber deste detalhe, pois você vai querer suprimir esse comportamento na maioria das vezes. Para isso, basta adicionar o valor <code>FALSE</code> para o argumento <code>stringsAsFactors</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>tabela <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">cidade =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span>, <span class="st">"Macapá"</span>), <span class="at">times =</span> <span class="dv">4</span>),</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor =</span> <span class="fu">rnorm</span>(<span class="dv">12</span>),</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Estou utilizando a função is.character()</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co"># para confirmar que data.frame() manteve</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="co"># a coluna de cidades como texto (characters)</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="fu">is.character</span>(tabela<span class="sc">$</span>cidade)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>No exemplo acima, você também percebe que eu utilizei dentro da função <code>is.character()</code>, o operador <code>$</code> para acessar os valores da coluna <code>cidade</code> da nossa tabela. Em <code>data.frame</code>’s você sempre pode utilizar este mecanismo para acessar os valores de uma das colunas de sua tabela, pois <code>data.frame()</code> irá sempre se preocupar em nomear as colunas caso você não o faça. Portanto, mesmo que <code>data.frame()</code> invente um nome completamente esquisito para as suas colunas, elas sempre terão um nome para o qual você pode se referir com <code>$</code>.</p>
<p>Isso não significa que você deixará de utilizar o sistema <code>[</code>, pois essa função é muito mais flexível do que você imagina. Uma de suas principais e mais poderosas ferramentas, é um sistema que é comumente chamado de <em>logical subsetting</em>. Com ele, podemos usar a função <code>[</code> para extrair valores de um objeto, de acordo com o resultado de testes lógicos. Em diversas funções de pacotes que você utilizar, se você visitar o código fonte dessas funções, você irá encontrar este sistema sendo utilizado em algum momento, sendo portanto, uma ferramenta extremamente útil dentro do R.</p>
<p>Em resumo, se você quer extrair todos os valores de uma coluna de seu <code>data.frame</code>, você pode utilizar o sistema <code>$</code>, ou o mesmo sistema que utilizamos em matrizes, ao deixar o índice das linhas em “branco” dentro de <code>[</code>. Se você quer extrair partes específicas de sua tabela, você terá que usar <code>[</code> da mesma forma que o utilizamos em matrizes. Como as colunas de um <code>data.frame</code> são nomeados, você pode também extrair uma coluna inteira, ao colocar o nome dessa coluna entre aspas dentro dos colchetes. Todos os sistemas utilizados abaixo, nos retorna todos os valores da coluna <code>cidade</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>tabela<span class="sc">$</span>cidade</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>tabela[, <span class="dv">1</span>]</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>tabela[[<span class="st">"cidade"</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Você deve ter percebido acima que utilizei novamente os dois colchetes, ao me referir dentro deles pelo nome da coluna desejada. Este sistema funciona exatamente da mesma forma que ele funciona em listas. Se eu utilizar um colchete, o R me retorna um <code>data.frame</code> contendo uma única coluna (neste caso, a coluna <code>cidade</code>), se eu uso dois colchetes, o R me retorna um vetor contendo apenas os valores dessa coluna.</p>
<p>Agora, voltando um pouco em nossa descrição, quando eu disse que um <code>data.frame</code> são listas, pois herdava muitas de suas propriedades, eu acabei omitindo uma dessas propriedades para evitar confusões. Você deve ter percebido pelos exemplos anteriores, que cada elemento de um <code>data.frame</code> é uma coluna de sua tabela. Você talvez tenha percebido também que todos esses elementos nos exemplos anteriores, eram vetores. Isso é uma característica marcante de um <code>data.frame</code>, pois na maioria das vezes em que você ver um, ele estará servindo apenas como um laço, que amarra e mantém diferentes vetores unidos em uma mesma estrutura, vetores esses que juntos formam uma tabela.</p>
<p>Você deve estar pensando: “Mas é claro que cada coluna é um vetor! Não faria sentido se eu incluísse matrizes ou outras tabelas em uma coluna de uma tabela! Um vetor é a estrutura que faz mais sentido para essas colunas!”. Bom, eu creio que agora é uma boa hora para “explodir” a sua cabeça!…ou pelo menos metaforicamente falando. <strong>A outra propriedade que <code>data.frame</code>’s herdam de listas, é que cada um de seus elementos também não precisam ser da mesma estrutura. </strong></p>
<p>Essa propriedade significa que eu posso incluir sim, uma matriz, ou um outro <code>data.frame</code>, como uma nova coluna de um <code>data.frame</code> que está salvo em algum objeto. Lembre-se que a principal diferença entre um <code>data.frame</code> e uma lista, é que os elementos de um <code>data.frame</code> precisam obrigatoriamente ter o mesmo número de linhas. No exemplo abaixo, eu estou criando inicialmente um <code>data.frame</code> com 10 linhas e 2 colunas, logo, se eu quiser incluir uma nova tabela como uma nova coluna desse <code>data.frame</code>, essa nova tabela (ou novo <code>data.frame</code>) deve possuir 10 linhas (mas esse novo <code>data.frame</code> pode ter quantas colunas você desejar).</p>
<p>Você pode facilmente adicionar uma nova coluna a um <code>data.frame</code>, utilizando o operador <code>$</code>. Você escreve primeiro o nome do objeto onde o seu <code>data.frame</code> está contido, abre o cifrão (<code>$</code>), e em seguida, coloca um nome de uma coluna que não existe em seu <code>data.frame</code> até aquele momento. Se não há alguma coluna neste <code>data.frame</code> que possui este nome, o R irá adicionar esta coluna a ele, e para você preencher essa coluna com algum valor, basta utilizar o símbolo de <em>assignment</em> (<code>&lt;-</code>), como se você estivesse salvando algum valor em um novo objeto. Após criar essa nova coluna, eu chamo por ela, para que o R me mostre o que tem nessa coluna, e como esperávamos, ele me retorna o novo <code>data.frame</code> que criamos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>tabela <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">cidade =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Belo Horizonte"</span>, <span class="st">"Londrina"</span>), <span class="at">times =</span> <span class="dv">5</span>),</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>tabela<span class="sc">$</span>novo_dataframe <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="fu">rep</span>(<span class="st">"Ana"</span>, <span class="at">times =</span> <span class="dv">10</span>),</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> <span class="fu">rep</span>(<span class="st">"Eduardo"</span>, <span class="at">times =</span> <span class="dv">10</span>),</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">z =</span> <span class="dv">25</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>tabela<span class="sc">$</span>novo_dataframe</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     x       y  z
1  Ana Eduardo 25
2  Ana Eduardo 25
3  Ana Eduardo 25
4  Ana Eduardo 25
5  Ana Eduardo 25
6  Ana Eduardo 25
7  Ana Eduardo 25
8  Ana Eduardo 25
9  Ana Eduardo 25
10 Ana Eduardo 25</code></pre>
</div>
</div>
<p>Na <a href="#fig-str-dataframe-nest" class="quarto-xref">Figura&nbsp;<span>2.8</span></a>, estou utilizando a função <code>str()</code> sobre o objeto <code>tabela</code>. Essa função nos retorna no console, uma descrição da estrutura de um objeto. No retângulo vermelho, temos a estrutura geral do objeto, vemos que o objeto <code>tabela</code> é um <code>data.frame</code> com dez linhas e três colunas. Os nomes de suas três colunas estão especificadas no retângulo verde. A direita do nome da terceira coluna (chamada <code>novo_dataframe</code>), podemos ver uma descrição de sua estrutura marcada por um retângulo azul. Vemos neste retângulo azul, portanto, a estrutura desta terceira coluna, e podemos confirmar que se trata também de um <code>data.frame</code> com 10 linhas e 3 colunas, e no retângulo roxo, podemos ver o nome das três colunas (no caso abaixo, colunas x, y e z) contidas neste segundo <code>data.frame</code>. Os falantes de língua inglesa costumam se referir a esta situação onde inserimos uma nova estrutura dentro de uma mesma estrutura, como uma <em>nested structure</em>, ou uma estrutura “aninhada”. Logo, o exemplo que estou dando, se trata de um <em>nested</em> <code>data.frame</code>. Pois estamos inserindo um <code>data.frame</code>, dentro de um outro <code>data.frame</code>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-str-dataframe-nest" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-str-dataframe-nest-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/str_dataframe_mod.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-str-dataframe-nest-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.8: Estrutura de um <code>data.frame</code> aninhado
</figcaption>
</figure>
</div>
</div>
</div>
<p>Se você chamar pelo nome <code>tabela</code> no console, para ver o que tem dentro deste objeto, o console irá lhe mostrar um <code>data.frame</code> com 10 linhas e 5 colunas. Pois ele lhe apresenta tanto as 2 colunas definidas como vetores em <code>tabela</code>, quanto as 3 colunas definidas em <code>tabela$novo_dataframe</code>, tudo em uma mesma tabela. Entretanto, como vimos através da função <code>str()</code>, o R está considerando este objeto como um <code>data.frame</code> com 10 linhas e 3 colunas, onde a terceira coluna contém um novo <code>data.frame</code> de 10 linhas e com outras 3 colunas, e não como um único <code>data.frame</code> com 10 linhas e 5 colunas.</p>
<p>Tendo essas considerações em mente, você pode sim incluir dados que estão em qualquer uma das estruturas anteriormente mencionadas, dentro de uma coluna (ou elemento) de um <code>data.frame</code>. Essa propriedade é mais citada nos manuais originais da linguagem <span class="citation" data-cites="Rlanguage Rintroduction">(veja <a href="references.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>, <a href="references.html#ref-Rintroduction" role="doc-biblioref">2020b</a>)</span>, enquanto é muito pouco mencionada, ou pouco explicada em detalhes em outros livros-texto sobre a linguagem. Pois é uma propriedade que faz pouco sentido, considerando-se as principais aplicações de um <code>data.frame</code>. Porém, com essa propriedade, você pode pensar facilmente em uma outra estrutura que é muito mais útil e muito mais poderosa, para ser incluída em uma nova coluna de seu <code>data.frame</code>. Essa estrutura, é uma lista!</p>
<p>Pense um pouco sobre isso. Uma lista é um vetor em sua essência, e por isso, pode facilmente formar uma nova coluna desse <code>data.frame</code>. A vantagem de se incluir uma lista, é que agora em cada célula (ou em cada linha) dessa nova coluna, eu posso guardar um dado de um tipo, tamanho e estrutura diferentes. Se fossemos utilizar a representação visual da seção anterior, é como se a coluna de seu <code>data.frame</code> tenha se transformado em um trem, e agora cada célula, ou cada linha dessa coluna, tenha se tornado um vagão deste trem. Com essa realidade, você pode por exemplo, facilmente aplicar um modelo de regressão sobre 1.000 bases de dados diferentes, e ainda guardar os resultados em cada linha de uma nova coluna, tudo isso com apenas um comando! Dessa forma, você terá em uma coluna de seu <code>data.frame</code> contendo uma lista, lista essa que está mantendo todos esses 1.000 <code>data.frame</code>’s diferentes juntos.</p>
<p>Se você consegue entender a língua inglesa, mesmo que sutilmente, eu altamente recomendo que assista a palestra de Hadley Wickham, entitulada <em>“Managing many models with R”</em>, que está disponível no YouTube<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Nesta palestra, ele dá um exemplo prático de como você pode implementar essa ideia, ao aplicar um modelo de regressão sobre várias bases diferentes, utilizando essa propriedade em um <code>data.frame</code>.</p>
</section>
<section id="sec:fundamentos_tibble" class="level3" data-number="2.4.5">
<h3 data-number="2.4.5" class="anchored" data-anchor-id="sec:fundamentos_tibble"><span class="header-section-number">2.4.5</span> <code>tibble</code>’s como uma alternativa moderna aos <code>data.frame</code>’s</h3>
<p>Um <code>tibble</code> nada mais é do que uma “versão moderna” de um <code>data.frame</code>. Essa estrutura de dado é originária do pacote <code>tibble</code>, logo, se você deseja utilizá-la em algum de seus dados, você terá que chamar obrigatoriamente por esse pacote com o comando <code>library()</code><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Lembre-se que o pacote deve estar instalado em sua máquina, para que você seja capaz de chamar por ele com o comando <code>library()</code>.</p>
<p>Portanto, essa estrutura foi criada com o intuito de melhorar alguns comportamentos do <code>data.frame</code>, que eram adequados para a sua época, mas que hoje, são desnecessários e que podem gerar um pouco de dor de cabeça. Tais estruturas podem ser criadas do zero, através da função <code>tibble()</code>, que funciona da mesma maneira que <code>data.frame()</code>. Você dá o nome para cada coluna, e após um igual (<code>=</code>) você define o que irá preencher cada uma dessas colunas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tibble)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>tab_tibble <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">Datas =</span> <span class="fu">seq.Date</span>(<span class="fu">as.Date</span>(<span class="st">"2020-12-01"</span>), <span class="fu">as.Date</span>(<span class="st">"2020-12-10"</span>), <span class="at">by =</span> <span class="dv">1</span>),</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">Usuario =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">size =</span> <span class="dv">10</span>, <span class="at">replace =</span> T),</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">Valor =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="dv">2000</span>, <span class="dv">3000</span>, <span class="dv">4000</span>, <span class="dv">5000</span>), <span class="at">size =</span> <span class="dv">10</span>, <span class="at">replace =</span> T)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>tab_tibble</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 3
  Datas      Usuario Valor
  &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;
1 2020-12-01 Ana      3000
2 2020-12-02 Eduardo  5000
3 2020-12-03 Eduardo  3000
4 2020-12-04 Eduardo  3000
5 2020-12-05 Eduardo  4000
# ℹ 5 more rows</code></pre>
</div>
</div>
<p>Por outro lado, se você já possui um <code>data.frame</code> e deseja convertê-lo para um <code>tibble</code>, você precisa apenas aplicar a função <code>as_tibble()</code> sobre ele.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>tabela <span class="ot">&lt;-</span> <span class="fu">as_tibble</span>(tabela)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A primeira melhoria dessas estruturas, se encontra no método de <code>print()</code>, ou em outras palavras, na forma como o R lhe mostra a sua tabela no console. Quando chamamos por um objeto que é um <code>data.frame</code>, o console acaba lhe retornando muito mais linhas do que o necessário (ele pode retornar até 1000 linhas), além de todas as colunas da tabela. Se o seu <code>data.frame</code> possui várias colunas, você pode se sentir frustrado com esse comportamento, pois se alguma coluna de sua tabela não couber ao lado das colunas anteriores, o console acaba quebrando o resultado em várias “linhas”, algo que pode tornar a leitura confusa com certa facilidade.</p>
<p>As origens do R são antigas (&gt; 50 anos), e aparentemente esse não era um comportamento muito ruim na época, talvez porque as dimensões das tabelas dessa época eram muito limitadas. Porém, com as capacidades de processamento atuais, essa atitude é desnecessária ou indesejada em quase todas as situações. Veja no exemplo abaixo, onde eu pego a base <code>flights</code> (que possui 19 variáveis diferentes), e transformo-a em um <code>data.frame</code> com a função <code>as.data.frame()</code>. Para que o resultado não consuma muito espaço deste material, eu ainda limito o resultado às 5 primeiras linhas da tabela com <code>head()</code>. Perceba que a tabela foi dividida em 3 linhas diferentes de <em>output</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nycflights13)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.frame</span>(flights) <span class="sc">%&gt;%</span> </span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">head</span>(<span class="at">n =</span> <span class="dv">5</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time
1 2013     1   1      517            515         2      830            819
2 2013     1   1      533            529         4      850            830
3 2013     1   1      542            540         2      923            850
4 2013     1   1      544            545        -1     1004           1022
5 2013     1   1      554            600        -6      812            837
  arr_delay carrier flight tailnum origin dest air_time distance hour minute
1        11      UA   1545  N14228    EWR  IAH      227     1400    5     15
2        20      UA   1714  N24211    LGA  IAH      227     1416    5     29
3        33      AA   1141  N619AA    JFK  MIA      160     1089    5     40
4       -18      B6    725  N804JB    JFK  BQN      183     1576    5     45
5       -25      DL    461  N668DN    LGA  ATL      116      762    6      0
            time_hour
1 2013-01-01 05:00:00
2 2013-01-01 05:00:00
3 2013-01-01 05:00:00
4 2013-01-01 05:00:00
5 2013-01-01 06:00:00</code></pre>
</div>
</div>
<p>Quando as suas tabelas são <code>tibble</code>’s, o console lhe retorna por padrão, apenas as 10 primeiras linhas da tabela (caso a tabela seja muito pequena, ele pode lhe retornar todas as linhas), o que já é o suficiente para vermos a sua estrutura. Além disso, caso as próximas colunas não caibam em uma mesma “linha”, ou ao lado das colunas anteriores, o <code>tibble</code> acaba omitindo essas colunas para não sobrecarregar o seu console de resultados. Lembre-se que você sempre pode ver toda a tabela, em uma janela separada através da função <code>View()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">View</span>(flights)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Veja o exemplo abaixo, onde eu chamo novamente pela base <code>flights</code>. O primeiro detalhe que você percebe, é a dimensão da tabela (algo que não é informado, quando chamamos por um <code>data.frame</code>) no canto superior esquerdo da tabela (336.776 linhas e 19 colunas). O segundo detalhe, é que o tipo de dado contido em cada coluna, está descrito logo abaixo do nome da coluna, de acordo com a abreviação deste tipo. Por exemplo, nas três primeiras colunas estão contidos números inteiros (<em>integer</em>’s - <code>int</code>), enquanto na sexta coluna (<code>dep_delay</code>) temos números decimais (<em>double</em>’s - <code>dbl</code>).</p>
<p>Mesmo que em um <code>tibble</code>, você fique sem a possibilidade de visualizar todas as outras colunas da tabela, que não cabem na mesma linha junto com as colunas anteriores, um <code>tibble</code> sempre lhe retorna logo abaixo da tabela, uma lista contendo o nome de todas as colunas restantes, além do tipo de dado contido em cada coluna, através das mesmas abreviações que vimos nas colunas anteriores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>flights</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 336,776 × 19
   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
1  2013     1     1      517            515         2      830            819
2  2013     1     1      533            529         4      850            830
3  2013     1     1      542            540         2      923            850
4  2013     1     1      544            545        -1     1004           1022
5  2013     1     1      554            600        -6      812            837
# ℹ 336,771 more rows
# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …</code></pre>
</div>
</div>
<p>Além desses pontos, <code>tibble</code>’s vão sempre criar destaques, ou ênfases em certos dados no console, algo que os <code>data.frame</code>’s não fazem em nenhum momento. Por exemplo, <code>tibble</code>’s vão sempre marcar de vermelho, qualquer número que seja negativo, uma funcionalidade que é bem familiar aos usuários de Excel que utilizam formatação condicional. Um outro detalhe, é que essa estrutura também marca as casas dos milhares com um pequeno sublinhado, o que facilita muito a leitura de números muito grandes.</p>
<p>Para mais, um comportamento muito comum de um <code>data.frame</code>, é converter os seus dados em textos, para fatores (<code>factor</code>). Este não é um comportamento de todo ruim, e nem sempre ele ocorre. Porém o principal valor dos fatores no R, está no uso de <em>dummies</em> em regressões e análises estatísticas, além da maneira como a ordenação de seus valores é executada. Estas características são importantes, mas também são irrelevantes para uma gama muito grande de situações. Em outras palavras, este é um comportamento desnecessário na maioria de nossas análises.</p>
<p>Por isso, uma outra característica que os <code>tibble</code>’s carregam, é que eles nunca transformam os seus dados para um outro tipo. Isso é um ponto muito importante! As funções com as quais nós trabalhamos no R, geralmente funcionam melhor com (ou são especializadas em) uma estrutura ou tipo de dado específico, e quando nós estruturamos as nossas análises sobre essas funções, nós desejamos evitar mudanças não autorizadas sobre os tipos e estruturas utilizados.</p>
<p>Ou seja, é sempre melhor evitar transformações implícitas de seus dados. Pois essas operações podem muito bem, levantar erros dos quais você não compreende, até que você (depois de muito tempo analisando os resultados) perceba que os seus dados foram convertidos para algo incompatível com o que você deseja realizar.</p>
<p>Dessa forma, em um <code>tibble</code> os seus dados em texto são interpretados como textos (<code>character</code>), a menos que você peça explicitamente ao R que interprete esses dados de uma outra forma. Veja o exemplo abaixo, onde utilizo a função <code>str()</code> para ver um resumo da estrutura de cada tabela. Podemos ver abaixo, que a coluna <code>text</code> na tabela <code>tib</code> contém dados do tipo <code>character</code> (<code>chr</code>), enquanto essa mesma coluna na tabela <code>df</code>, possui dados do tipo <code>factor</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>tib <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">text =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">size =</span> <span class="dv">10</span>, <span class="at">replace =</span> T)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">text =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">size =</span> <span class="dv">10</span>, <span class="at">replace =</span> T)</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(tib)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>tibble [10 x 2] (S3: tbl_df/tbl/data.frame)
 $ x   : num [1:10] 0.172 0.315 0.119 -0.155 -0.165 ...
 $ text: chr [1:10] "Eduardo" "Ana" "Eduardo" "Eduardo" ...</code></pre>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>'data.frame':   10 obs. of  2 variables:
 $ x   : num  0.0639 -0.4522 0.7528 -1.3353 1.454 ...
 $ text: Factor w/ 2 levels "Ana","Eduardo": 2 2 2 1 2 2 1 1 2 1</code></pre>
<p>Uma última característica de um <code>tibble</code>, é que ele lhe permite criar colunas com nomes que não respeitam as regras usuais do R. Por exemplo, não é permitido criar variáveis que possuam um nome que se inicia por um número, ou então, que possuam algum tipo de espaço ao longo dele. Mas dentro de um <code>tibble</code>, você não possui tais restrições. No exemplo abaixo, eu tento ultrapassar essa regra na função <code>data.frame()</code>, e ela acaba preenchendo o espaço no nome, com um ponto (.), e também coloca uma letra qualquer antes do número da coluna “10_janeiro”, enquanto em um <code>tibble</code>, isso não ocorre. Entretanto, mesmo que você possua essa liberdade em um <code>tibble</code>, ao se referir a essas colunas que não se encaixam nas regras do R, você terá de contornar o nome dessas colunas, com acentos graves (`).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>data_frame <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Nome coluna"</span> <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"10_janeiro"</span> <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">10</span>)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>tibble <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Nome coluna"</span> <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"10_janeiro"</span> <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">10</span>)</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(data_frame, <span class="dv">10</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Nome.coluna X10_janeiro
1    1.1547142 -0.61716609
2   -0.9835476  1.15786240
3    0.7115670 -0.06361489
4    0.4106486 -0.60002315
5   -1.2921761 -1.31783740
6    1.2599612  0.35075579
7   -1.2853554 -0.42862554
8   -0.9221728 -1.68730627
9   -0.8045062  0.90921247
10   0.6508011 -0.26749117</code></pre>
</div>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>tibble</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 2
  `Nome coluna` `10_janeiro`
          &lt;dbl&gt;        &lt;dbl&gt;
1         0.841        0.286
2        -0.125        1.86 
3         1.66        -1.21 
4         1.18        -1.28 
5        -0.733        0.524
# ℹ 5 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>tibble<span class="sc">$</span><span class="st">`</span><span class="at">10_janeiro</span><span class="st">`</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  0.2858658  1.8592471 -1.2114297 -1.2822384  0.5242709 -0.7140074
 [7]  0.9085594 -1.0150557 -0.4590776 -1.5638036</code></pre>
</div>
</div>
<p>Portanto, os <code>tibble</code>’s foram criados com o intuito de manter as funcionalidades importantes de um <code>data.frame</code>, e ao mesmo tempo, eliminar comportamentos que hoje são desnecessários ou ineficientes. O <code>tibble</code> é uma estrutura preguiçosa. Pois ele nunca converte implicitamente os seus dados para algum outro tipo, ele não altera o nome de suas colunas, e ele também não sobrecarrega o seu console com linhas e linhas de resultados, lhe mostrando apenas o necessário.</p>
</section>
</section>
<section id="sec:fundamentos_tipos_dados" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="sec:fundamentos_tipos_dados"><span class="header-section-number">2.5</span> Tipos de dados</h2>
<p>Como foi destacado anteriormente, além das estruturas de dados, o R possui os tipos de dados. Tipos esses que dizem respeito a forma como o R está interpretando os seus dados, em um dado momento. Os cinco tipos de dados básicos da linguagem são:</p>
<ol type="1">
<li><p><code>character</code>: valores de texto ou caracteres.</p></li>
<li><p><code>double</code>: valores númericos inclusos no conjunto dos números reais.</p></li>
<li><p><code>integer</code>: valores númericos inclusos no conjunto de números inteiros, ou basicamente, números sem casas decimais.</p></li>
<li><p><code>logical</code>: valores <code>TRUE</code> (verdadeiro) e <code>FALSE</code> (falso), resultantes de testes lógicos.</p></li>
<li><p><code>complex</code>: valores em números complexos.</p></li>
</ol>
<p>Vários outros tipos de dados mais complexos, como datas (<code>Date</code>) e fatores (<code>factor</code>), são construídos a partir desses 5 tipos básicos da linguagem. O único tipo básico que não irei abordar nas próximas seções, será o tipo <code>complex</code>, pois é um tipo muito específico e extremamente raro na linguagem.</p>
<p>Vale destacar que, diferentes autores denominam essa propriedade de formas diferentes, ou, tendem a misturá-la em outros conceitos. Como exemplo, <span class="citation" data-cites="peng2015">PENG (<a href="references.html#ref-peng2015" role="doc-biblioref">2015</a>)</span> denomina os “tipos de dados” como “classes atômicas de objetos” (ou, <em>“atomic classes of objects”</em>), enquanto <span class="citation" data-cites="wickham2017">WICKHAM; GROLEMUND (<a href="references.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span>, costuma se referir a essa propriedade como “tipos de vetores” (ou, <em>“vector types”</em>). Independente da forma como os autores denominam essa propriedade, a lógica permanece a mesma.</p>
<p>O termo utilizado por <span class="citation" data-cites="wickham2017">WICKHAM; GROLEMUND (<a href="references.html#ref-wickham2017" role="doc-biblioref">2017</a>)</span> é o mais apropriado para essa situação. Não apenas porque ele representa melhor a forma como esses conceitos são apresentados nos manuais internos da linguagem <span class="citation" data-cites="Rlanguage Rintroduction">(veja <a href="references.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>, <a href="references.html#ref-Rintroduction" role="doc-biblioref">2020b</a>)</span>, mas também, porque o termo utilizado por <span class="citation" data-cites="peng2015">PENG (<a href="references.html#ref-peng2015" role="doc-biblioref">2015</a>)</span> mistura dois conceitos importantes que são diferentes entre si: a classe e o tipo de um objeto.</p>
<p>O tipo do objeto, (isto é, o que estou chamando aqui de tipo de dado - <code>character</code>, <code>double</code>, etc.), determina a representação interna do objeto. Ou seja, como esse objeto é armazenado internamente na memória de seu computador. Já a classe é um atributo do objeto, que determina quais são os métodos de funções a serem aplicados sobre este objeto <span class="citation" data-cites="chambers2016">(<a href="references.html#ref-chambers2016" role="doc-biblioref">CHAMBERS, 2016</a>, pp.&nbsp;45)</span>. Por isso eu evito a denominação utilizada por <span class="citation" data-cites="peng2015">PENG (<a href="references.html#ref-peng2015" role="doc-biblioref">2015</a>)</span>, dado que ela pode ter um sentido dúbio dependendo da situação.</p>
<section id="textos-e-caracteres-character" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="textos-e-caracteres-character"><span class="header-section-number">2.5.1</span> Textos e caracteres (<code>character</code>)</h3>
<p>Artigos, livros, línguas, documentos, dicionários, jornais, páginas da web, são várias as possíveis fontes de texto. Certos campos da ciência conseguem extrair diversas análises e conhecimentos importantes desses tipos de fonte. Ou seja dados em texto são extremamente importantes e comuns nos mais diversos tipos de análises (a inteligencia artificial, ChatGPT, <em>webscrapping</em>, etc., são provas disso).</p>
<p>Variáveis do tipo texto são geralmente denominadas de variáveis categóricas. Pois em geral, elas buscam classificar os seus dados em certas categorias e grupos. Para além dessas variáveis, também é comum utilizarmos textos para definir rótulos e títulos de gráficos, ou ainda, para definir certos argumentos de funções.</p>
<p>Para armazenar, interpretar e transformar esse tipo de dado, o R nos oferece o tipo <code>character</code>. Valores do tipo <code>character</code> também são conhecidos pelo termo <em>string</em> (ou <em>string of characters</em>). Todo valor em texto no R (isto é, todo dado do tipo <code>character</code>), deve ser fornecido entre aspas (simples - <code>'</code>, ou duplas - <code>"</code>), sendo essa uma convenção utilizada em quase todas as linguagens de programação existentes, e no R não é diferente. Esta convenção se torna ainda mais importante no R, pois ela também serve para diferenciar valores em texto de nomes de objetos.</p>
<p>Em outras palavras, quando queremos acessar os valores que estão dentro de um objeto, nós simplesmente escrevemos o nome deste objeto. Entretanto, quando estamos fornecendo um simples texto ao R, é muito comum que nos esqueçamos de contornar esse texto com aspas. Como resultado, o R acaba interpretando esse valor como o nome de um objeto e, por isso, começa a procurar por um objeto que possua um nome igual a este texto que você digitou. Caso o R não encontre um objeto com um nome equivalente a esse texto, ele vai lhe retornar um erro indicando que ele não foi capaz de encontrar um objeto com este nome em sua sessão.</p>
<p>Para mais, caso este texto que você digitou, possua algum espaço, o R vai lhe retornar um erro um pouco diferente, dizendo que o símbolo que você inseriu no console, é inesperado ou inválido. De qualquer forma, o problema desse erro é o mesmo, você provavelmente se esqueceu de contornar o texto por aspas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>O_ano_tem_365_dias</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Erro: objeto 'O_ano_tem_365_dias' não encontrado</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>O ano tem <span class="dv">365</span> dias</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Erro: unexpected symbol in "O ano"</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="st">"O ano tem 365 dias"</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="do">## [1] "O ano tem 365 dias"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vale destacar que, um par de aspas, delimita um único valor do tipo <code>character</code>. Portanto, para criar um vetor contendo vários valores do tipo <code>character</code>, você tem que contornar cada um desses valores por aspas. Caso você contorne todos os diferentes valores por um único par de aspas, você vai criar um vetor do tipo <code>character</code> que contém 1 único elemento. Tal problemática está demonstrada abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a, b, c, d"</span>)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(vec)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>vec2 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(vec2)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4</code></pre>
</div>
</div>
</section>
<section id="números-reais-double" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="números-reais-double"><span class="header-section-number">2.5.2</span> Números reais (<code>double</code>)</h3>
<p>Em quase todos os momentos que você estiver trabalhando com dados numéricos, esses dados vão estar sendo interpretados pelo tipo <code>double</code>. Pois este tipo básico abarca todo o conjunto dos números reais. E como o conjunto de números inteiros (<code>integer</code>) está incluso no conjunto dos números reais, quando você insere um número inteiro, ou um número sem casas decimais no console, ele será interpretado inicialmente pelo R como um número real (<code>double</code>).</p>
<p>Dito de outra forma, ao inserirmos apenas o número 10 no console, o R vai interpretar este 10 como um <code>double</code>, e não como <code>integer</code>, independente do fato desse número aparecer no console sem casas decimais. Pense como se este 10, fosse na verdade para o R algo como 10,00000000000… No exemplo abaixo, eu utilizo a função <code>is.integer()</code> para perguntar ao R, se ele está interpretando este valor como um <code>integer</code>, e como esperávamos a função nos retorna um <code>FALSE</code>, indicando que não se trata de um número inteiro.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># O R está basicamente interpretando</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co"># este 10 como 10.00000000, mesmo</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co"># que ele te mostre</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.double</span>(<span class="dv">10</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(<span class="dv">10</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<p>Vale destacar, que o R é uma linguagem centralizada nos padrões americanos, e que, portanto, utiliza o ponto para definir casas decimais, ao invés da vírgula que nós brasileiros utilizamos. Por esse motivo, para criar um vetor de números decimais, você deve utilizar um ponto para delimitar as casas decimais de seus valores. As vírgulas servem apenas para separar os diferentes valores deste vetor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="fl">1.24</span>, <span class="fl">2.25</span>, <span class="fl">3.62381</span>, <span class="fl">7.05</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.24000 2.25000 3.62381 7.05000</code></pre>
</div>
</div>
</section>
<section id="números-inteiros-integer" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3" class="anchored" data-anchor-id="números-inteiros-integer"><span class="header-section-number">2.5.3</span> Números inteiros (<code>integer</code>)</h3>
<p>O tipo <code>integer</code> abarca o conjunto dos números inteiros, ou basicamente todos os números sem casas decimais. Você utilizará muito este tipo, quando estiver utilizando sequências numéricas, seja para extrair partes de um objeto com a função <code>[</code>, ou gerando um índice para as linhas de sua tabela. Como vimos na seção anterior, caso você insira um número sem casas decimais no console, o R vai interpretar inicialmente este número como um <code>double</code>.</p>
<p>Assim sendo, você tem três formas de se criar um <code>integer</code> no R. A primeira é inserindo um L maiúsculo após o número que você está criando. A segunda, é transformando o seu vetor do tipo <code>double</code> para o tipo <code>integer</code>, através da função <code>as.integer()</code>. A terceira, seria através de funções que lhe retornam por padrão este tipo de dado, sendo o principal exemplo, a função <code>:</code> que lhe retorna, por padrão, uma sequência de <code>integer</code>’s. Podemos confirmar se os números criados são de fato <code>integer</code>’s, usando a função <code>is.integer()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="dv">1</span>L, <span class="dv">2</span>L, <span class="dv">3</span>L, <span class="dv">10</span>L)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  1  2  3 10</code></pre>
</div>
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.integer</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="fl">10.2561</span>, <span class="fl">1.55</span>))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  1  2 10  1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
</section>
<section id="o-tipo-numérico-numeric" class="level3" data-number="2.5.4">
<h3 data-number="2.5.4" class="anchored" data-anchor-id="o-tipo-numérico-numeric"><span class="header-section-number">2.5.4</span> O tipo numérico (<code>numeric</code>)</h3>
<p>Em alguns momentos você pode se deparar com o tipo <code>numeric</code>. Ele nada mais é do que um “apelido” para os tipos <code>integer</code> e <code>double</code>. Dito de outra forma, os tipos <code>integer</code> e <code>double</code> são conjuntamente conhecidos como o tipo <code>numeric</code> <span class="citation" data-cites="wickham2015_advanced">(<a href="references.html#ref-wickham2015_advanced" role="doc-biblioref">WICKHAM, 2015</a>)</span>.</p>
<p>Entretanto, mesmo que <code>numeric</code> seja um sinônimo para os tipos <code>integer</code> e <code>double</code>, o R não costuma empregar esse nome <code>numeric</code> de forma uniforme. Na maioria das ocasiões em que o tipo <code>numeric</code> aparece, o R está na verdade, se referindo especificamente ao tipo <code>double</code>. De qualquer forma, apenas entenda que se um conjunto de dados está associado ao tipo <code>double</code> ou ao tipo <code>integer</code>, ele também está diretamente associado ao tipo <code>numeric</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.numeric</span>(<span class="dv">1</span>L)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.numeric</span>(<span class="fl">1.25</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
</section>
<section id="valores-lógicos-logical" class="level3" data-number="2.5.5">
<h3 data-number="2.5.5" class="anchored" data-anchor-id="valores-lógicos-logical"><span class="header-section-number">2.5.5</span> Valores lógicos (<code>logical</code>)</h3>
<p>No R, valores lógicos são interpretados pelo tipo de dado <code>logical</code> e, como você já deve ter percebido, este tipo abrange apenas dois valores possíveis, que são verdadeiro - <code>TRUE</code>, e falso - <code>FALSE</code>. Valores lógicos também são muito conhecidos em diversas linguagens de programação pelo termo <code>boolean</code>. Você irá utilizar muito este tipo de dado para filtrar linhas de seu <code>data.frame</code>, para preencher uma coluna de rótulos, ou para identificar valores “não disponíveis” e <em>outliers</em> em sua base de dados.</p>
<p>Temos dois métodos de se obter esse tipo de valor no R. A primeira, é escrevê-los na mão, podendo também se referir apenas a primeira letra maiúscula de cada um, ao invés de escrever toda a palavra.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>vetor_logico <span class="ot">&lt;-</span> <span class="fu">c</span>(T, F, T, <span class="cn">TRUE</span>, <span class="cn">FALSE</span>)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>vetor_logico</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE FALSE  TRUE  TRUE FALSE</code></pre>
</div>
</div>
<p>A segunda e principal forma, é através de testes lógicos. No exemplo abaixo, eu estou criando um vetor com 5 elementos, e em seguida, peço ao R que me diga se cada elemento deste vetor é maior do que 5. Vemos que apenas o terceiro e o quarto elemento deste vetor, são maiores do que 5.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.5</span>, <span class="fl">2.45</span>, <span class="fl">5.6</span>, <span class="fl">7.2</span>, <span class="fl">1.3</span>)</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>vetor <span class="sc">&gt;</span> <span class="dv">5</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE FALSE  TRUE  TRUE FALSE</code></pre>
</div>
</div>
<p>O que acabamos de fazer acima, se trata de um teste lógico, pois estamos testando uma hipótese (maior do que 5) sobre cada um dos elementos deste vetor. Como resultado, o R lhe retorna um vetor com o mesmo comprimento do primeiro, porém agora, este vetor está preenchido com <code>TRUE</code>’s e <code>FALSE</code>’s, lhe indicando quais dos elementos do primeiro vetor se encaixam na hipótese que você definiu.</p>
<p>Este vetor contendo apenas valores lógicos, não é tão útil em sua singularidade. Porém, ao utilizarmos ele sobre à função <code>[</code>, podemos utilizar o sistema que mencionei anteriormente, chamado de <em>logical subsetting</em>, que é uma forma extremamente útil de extrairmos partes de um objeto. A ideia, é extrairmos qualquer elemento deste objeto que possua um valor <code>TRUE</code> correspondente em um teste lógico específico que podemos definir. Consequentemente, poderíamos utilizar o teste anterior que criamos, para extrair todos os elementos do vetor, que são maiores do que 5, desta forma:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>vetor[vetor <span class="sc">&gt;</span> <span class="dv">5</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5.6 7.2</code></pre>
</div>
</div>
<p>Para criar um teste lógico, você precisa utilizar algum operador lógico (como os operadores <code>&gt;</code> e <code>==</code>), ou então, alguma função que aplique este tipo de teste e lhe retorne um valor lógico como resultado (por exemplo, a função <code>is.integer()</code>).</p>
</section>
</section>
<section id="sec:funcoes_str_is" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="sec:funcoes_str_is"><span class="header-section-number">2.6</span> Identificando tipos e estruturas com a função <code>str()</code> e as funções <code>is.*()</code></h2>
<p>Na linguagem Python, a função <code>str()</code> serve para convertermos um objeto para o tipo <em>string</em>. Porém, na linguagem R, essa mesma função <code>str()</code> exerce um papel completamente diferente. No R, o nome <code>str</code> representa na realidade uma abreviação para <em>structure</em> (ou “estrutura”). Por isso, a função <code>str()</code> nos fornece uma pequena descrição da estrutura de um objeto específico.</p>
<p>Como um primeiro exemplo, quando aplicamos a função <code>str()</code> sobre a tabela <code>diamonds</code> do pacote <code>ggplot2</code>, o R nos retorna uma descrição contendo: a estrutura na qual esse objeto se encontra (<code>tibble</code>); as dimensões dessa tabela (<code>53,940 x 10</code>); as classes associadas a esse objeto (<code>S3: tbl_df/tbl/data.frame</code>); os nomes das colunas dessa tabela (<code>$ carat</code>, <code>$ cut</code>, <code>$ color</code>, etc); além de uma abreviação que indica o tipo de dado associado a cada uma dessas colunas (<code>num</code> para <code>numeric</code>, <code>int</code> para <code>integer</code>, etc.).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(diamonds)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)
 $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...
 $ cut    : Ord.factor w/ 5 levels "Fair"&lt;"Good"&lt;..: 5 4 2 4 2 3 3 3 1 3 ...
 $ color  : Ord.factor w/ 7 levels "D"&lt;"E"&lt;"F"&lt;"G"&lt;..: 2 2 2 6 7 7 6 5 2 5 ...
 $ clarity: Ord.factor w/ 8 levels "I1"&lt;"SI2"&lt;"SI1"&lt;..: 2 3 5 4 2 6 7 3 4 5 ...
 $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...
 $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...
 $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...
 $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...
 $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...
 $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...</code></pre>
</div>
</div>
<p>Como um segundo exemplo, ao aplicarmos a função <code>str()</code> sobre uma lista, a descrição resultante me confirma que o objeto se trata de uma lista de 5 elementos (<code>List of 5</code>). Devido à abreviação <code>chr</code> presente nos elementos <code>produto_vendido</code> e <code>data_de_registro</code>, nós também identificamos que os valores armazenados nesses elementos da lista estão associados ao tipo <code>character</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>registro_venda <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">produto_vendido =</span> <span class="st">"Leite Mua 1L"</span>,</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">unidades_vendidas =</span> <span class="dv">5</span>,</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">preco_por_unidade =</span> <span class="fl">3.45</span>,</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor_venda =</span> <span class="dv">5</span> <span class="sc">*</span> <span class="fl">3.45</span>,</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">data_de_registro =</span> <span class="st">"2021-08-22"</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(registro_venda)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 5
 $ produto_vendido  : chr "Leite Mua 1L"
 $ unidades_vendidas: num 5
 $ preco_por_unidade: num 3.45
 $ valor_venda      : num 17.2
 $ data_de_registro : chr "2021-08-22"</code></pre>
</div>
</div>
<p>Como um terceiro exemplo, quando aplicamos a função <code>str()</code> sobre um vetor, podemos identificar o tipo de dado associado àquele vetor além de suas dimensões. Pela demonstração abaixo, sabemos através da abreviação <code>int</code> que o vetor <code>sequencia</code> contém dados do tipo <code>integer</code>, e que este vetor possui 100 elementos (<code>[1:100]</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>sequencia <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(sequencia)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> int [1:100] 1 2 3 4 5 6 7 8 9 10 ...</code></pre>
</div>
</div>
<p>Portanto, a função <code>str()</code> é a forma mais prática e visual de se identificar as características principais de um objeto no R. Entretanto, futuramente você vai enfrentar situações onde você deve construir um programa (isto é, um <em>script</em>) que executa determinadas ações a depender da estrutura de um objeto ou dos tipos de dados associados a ele. Ou seja, haverá momentos em que você precisa inserir dentro de seu programa, testes que realizam essas verificações de forma automática. O primeiro passo para a construção desses testes são as funções <code>is.*()</code>.</p>
<p>Em geral, toda função <code>is.*()</code> retorna um único valor do tipo <code>logical</code>, informando se o objeto em questão pertence ou não ao tipo ou estrutura definido no nome dessa função. O tipo ou estrutura para a qual você está testando é definido no próprio nome da função. Por exemplo, se eu utilizo a função <code>is.character(x)</code>, eu estou querendo testar se o objeto <code>x</code> está associado ao tipo <code>character</code>. Como demonstrado abaixo, a função <code>is.character()</code> me retorna um valor <code>TRUE</code> para o objeto <code>nome</code>, entretanto, o mesmo não ocorre para o objeto <code>idade</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>nome <span class="ot">&lt;-</span> <span class="st">"Pedro Faria"</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>idade <span class="ot">&lt;-</span> <span class="dv">23</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="fu">is.character</span>(nome)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.character</span>(idade)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<p>Em resumo, se você deseja testar se um objeto possui uma certa propriedade, procure por uma função cujo nome comece por <code>"is."</code> seguido pelo nome dessa estrutura ou tipo no qual você está interessado. Como uma lista inicial, as funções para os tipos de dados são:</p>
<ul>
<li><code>is.integer()</code>.</li>
<li><code>is.character()</code>.</li>
<li><code>is.numeric()</code>.</li>
<li><code>is.double()</code>.</li>
<li><code>is.logical()</code>.</li>
<li><code>is.atomic()</code>.</li>
<li><code>is.complex()</code>.</li>
</ul>
<p>Já para o caso das estruturas de dados, estamos nos referindo às seguintes funções:</p>
<ul>
<li><code>is.vector()</code>.</li>
<li><code>is.list()</code>.</li>
<li><code>is.data.frame()</code>.</li>
<li><code>is.matrix()</code>.</li>
<li><code>is.array()</code>.</li>
<li><code>tibble::is_tibble()</code></li>
</ul>
<p>Uma outra forma (mais informal) de se identificar o tipo de dado associado a um objeto (ou a uma parte desse objeto) é através da função <code>typeof()</code>. Ao aplicar essa função sobre um objeto específico (ou sobre uma parte desse objeto), a função nos retorna o nome do tipo de dado associado a este objeto.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>L, <span class="dv">2</span>L, <span class="dv">3</span>L)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(vec)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "integer"</code></pre>
</div>
</div>
<section id="tome-muito-cuidado-com-is.vector-e-is.numeric" class="level3" data-number="2.6.1">
<h3 data-number="2.6.1" class="anchored" data-anchor-id="tome-muito-cuidado-com-is.vector-e-is.numeric"><span class="header-section-number">2.6.1</span> Tome muito cuidado com <code>is.vector()</code> e <code>is.numeric()</code></h3>
<p>A função <code>is.vector()</code> testa se um objeto é um vetor atômico. Porém, o principal problema dessa função é que ela baseia o seu teste na ausência de atributos, ao invés de se preocupar se o objeto se encaixa ou não na descrição de um vetor. Você pode encontrar mais detalhes sobre isso ao ler atentamente a documentação interna da função, com o comando <code>?is.vector</code>. Mas em resumo, a função <code>is.vector()</code> testa se o objeto em questão, é um vetor que não possui atributos (exceto o atributo <code>names</code>).</p>
<p>Vamos descrever o que são atributos mais a frente, mas devido a essa especificação, a função <code>is.vector()</code> retorna <code>FALSE</code> para diversos tipos de vetores “não-atômicos”, como os tipos <code>factor</code>, <code>Date</code>, <code>POSIXct</code> e <code>POSIXlt</code> (vamos descrever esses tipos em capítulos posteriores), pois todos eles possuem um atributo chamado <code>class</code>. Para mais, saiba que <code>is.vector()</code> retorna <code>TRUE</code> para listas, pois como descrevemos na seção <a href="#sec:estrutura_listas">Listas</a>, listas são no fundo, vetores. Além disso, listas geralmente contém no máximo um atributo <code>names</code> (o qual é permitido por <code>is.vector()</code>). Para demonstrar os resultados gerados por cada função que vou apresentar nessa seção, estou criando abaixo alguns objetos de teste, além de uma função que será responsável por aplicar a função sobre cada um desses objetos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">1</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>l <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="dv">1</span>)</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="dv">1</span>)</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>v1 <span class="ot">&lt;-</span> <span class="fu">as.Date</span>(<span class="st">"2021-01-01"</span>)</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>v2 <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="st">"a"</span>)</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">double</span>(<span class="dv">1</span>)</span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>aplicar_teste <span class="ot">&lt;-</span> <span class="cf">function</span>(x){</span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>  objs <span class="ot">&lt;-</span> <span class="fu">list</span>(m, a, l, d, v1, v2, vec, <span class="cn">NULL</span>)</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map_lgl</span>(objs, x)</span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(r) <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"matrix"</span>, <span class="st">"array"</span>, <span class="st">"list"</span>,</span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"data.frame"</span>, <span class="st">"Date"</span>, </span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"factor"</span>, <span class="st">"double"</span>, </span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"NULL"</span></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(r)</span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Perceba pelo resultado abaixo, que a função <code>is.vector()</code> nos retorna <code>TRUE</code> para uma lista (<code>list</code>), mas nos retorna <code>FALSE</code> para diversos vetores associados a tipos “não-atômicos” da linguagem, como os tipos <code>Date</code> e <code>factor</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aplicar_teste</span>(is.vector)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    matrix      array       list data.frame       Date     factor     double 
     FALSE      FALSE       TRUE      FALSE      FALSE      FALSE       TRUE 
      NULL 
     FALSE </code></pre>
</div>
</div>
<p>Devido a essas características, caso você deseje testar se um objeto <code>x</code> é um vetor atômico de forma mais restrita (isto é, que retorna <code>FALSE</code> para listas e <code>FALSE</code> para tipos de dados “não-atômicos” como <code>Date</code> e <code>factor</code>), você pode utilizar o teste lógico <code>is.vector(x) &amp; !is.list(x)</code>. Como demonstrado abaixo, esse teste retorna <code>TRUE</code> para <code>vec</code>, mas <code>FALSE</code> para <code>l</code> e para <code>v1</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.vector</span>(l) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.list</span>(l) <span class="co"># lista</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.vector</span>(v1) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.list</span>(v1) <span class="co"># Vetor do tipo Date</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.vector</span>(vec) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.list</span>(vec) <span class="co"># Vetor do tipo double</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>Dentro dos pacotes básicos do R nós temos a função <code>is.atomic()</code>, mas o pacote <code>purrr</code> nos oferece uma função “irmã” chamada de <code>is_atomic()</code> . A única diferença entre essas duas funções, é que <code>is_atomic()</code> retorna <code>FALSE</code> para um valor <code>NULL</code>, enquanto <code>is.atomic()</code> retorna <code>TRUE</code>. Para além desse detalhe, você pode reparar abaixo, que ambas as funções retornam um valor <code>TRUE</code> para matrizes (<code>matrix</code>) e <em>arrays</em> (<code>array</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aplicar_teste</span>(is_atomic)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    matrix      array       list data.frame       Date     factor     double 
      TRUE       TRUE      FALSE      FALSE       TRUE       TRUE       TRUE 
      NULL 
     FALSE </code></pre>
</div>
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aplicar_teste</span>(is.atomic)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    matrix      array       list data.frame       Date     factor     double 
      TRUE       TRUE      FALSE      FALSE       TRUE       TRUE       TRUE 
      NULL 
     FALSE </code></pre>
</div>
</div>
<p>Com esses detalhes em mente, se você deseja adotar um conceito levemente mais abrangente de vetor, de forma a testar se um objeto é um vetor e incluir os diversos tipos “não-atômicos” como <code>Date</code> e <code>factor</code>, você pode utilizar a função <code>is_atomic()</code> do pacote <code>purrr</code>. Mas também é necessário contornar o comportamento de <code>is_atomic()</code> para matrizes e <em>arrays</em>, ao aplicar o teste lógico <code>is_atomic(x) &amp; is.null(dim(x))</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is_atomic</span>(m) <span class="sc">&amp;</span> <span class="fu">is.null</span>(<span class="fu">dim</span>(m)) <span class="co"># Matriz</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is_atomic</span>(a) <span class="sc">&amp;</span> <span class="fu">is.null</span>(<span class="fu">dim</span>(a)) <span class="co"># Array</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is_atomic</span>(v1) <span class="sc">&amp;</span> <span class="fu">is.null</span>(<span class="fu">dim</span>(v1)) <span class="co"># Vetor do tipo Date</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is_atomic</span>(vec) <span class="sc">&amp;</span> <span class="fu">is.null</span>(<span class="fu">dim</span>(vec)) <span class="co"># Vetor do tipo double</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>Para além de <code>is_atomic()</code>, o pacote <code>purrr</code> também nos oferece a função <code>is_vector()</code>. Ao invés de se preocupar com os atributos que um objeto carrega, a função <code>is_vector()</code> verifica se o objeto <code>x</code> é armazenado (na camada mais profunda da linguagem) a partir de um vetor. Entretanto, como os vetores atômicos são a unidade fundamental das demais estruturas de dados presentes na linguagem, este conceito de vetor adotado por <code>is_vector()</code> é bastante abrangente, de modo que a função nos retorna <code>TRUE</code> para todas as estruturas e tipos de dados, como está demonstrado abaixo. Portanto, de certa forma, <code>is_vector()</code> busca identificar se um dado objeto é construído a partir de um vetor, mas não necessariamente se ele é um vetor <em>per se</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aplicar_teste</span>(is_vector)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    matrix      array       list data.frame       Date     factor     double 
      TRUE       TRUE       TRUE       TRUE       TRUE       TRUE       TRUE 
      NULL 
     FALSE </code></pre>
</div>
</div>
<p>Por último, como o tipo <code>numeric</code> é um sinônimo para os tipos <code>integer</code> e <code>double</code>, ao aplicar a função <code>is.numeric()</code> sobre um objeto, você está na verdade testando se esse objeto específico está associado ao tipo <code>double</code> ou ao tipo <code>integer</code>. Se você precisa que esse objeto esteja associado a apenas um desses dois tipos, utilize a função correspondente a esse tipo (<code>is.integer()</code> ou <code>is.double()</code>) ao invés de <code>is.numeric()</code>.</p>
</section>
</section>
<section id="sec:coercion_R_fundamentos" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="sec:coercion_R_fundamentos"><span class="header-section-number">2.7</span> Coerção no R</h2>
<p>Quando discuti sobre vetores e sua principal propriedade (<strong>vetores podem manter apenas um tipo de dado dentro dele</strong>), eu mencionei que caso você tentasse burlar essa regra, o R automaticamente converteria todos os valores para um único tipo de dado. Este processo é usualmente chamado por <em>coercion</em>, ou coerção, e iremos explicar como ele funciona nesta seção.</p>
<p>Em resumo, coerção é o processo em que o R converte automaticamente e, <strong>implicitamente</strong>, valores de um tipo de dado para um outro tipo. Esse processo é bem semelhante ao processo de coerção que ocorre na linguagem JavaScript, sendo a soma entre um número e um <em>string</em>, o exemplo mais clássico de coerção em JavaScript. Reproduzindo esse exemplo abaixo, nós estamos somando um valor numérico a um texto. Ao perceber essa diferença entre os tipos de dados, o JavaScript converte automaticamente o valor <code>10</code> para o tipo <em>string</em>, antes de executar a soma. Logo, ao realizar essa conversão, o JavaScript transforma uma soma entre um número e um <em>string</em>, em uma soma entre dois <em>strings</em> e, como resultado, o JavaScript apenas concatena os dois números um do lado do outro, como demonstrado abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em JavaScript:</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> x <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="st">"20"</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(x)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<script>
// Em JavaScript:
var x = 10 + "20"
print(x)
</script>
</div>
<pre><code>1020</code></pre>
<div class="cell">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span>(x)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>"string"</code></pre>
<p>Apesar da semelhança, processos de coerção no R, ocorrem geralmente quando estamos lidando com vetores de alguma maneira, especialmente quando estamos alterando partes de um vetor específico, ou também, quando estamos calculando um vetor a partir de uma função, e essa função nos retorna mais de 1 tipo de dado em seus resultados. Provavelmente, o exemplo mais clássico de coerção no R, está na concatenação entre um número e um texto. Perceba abaixo, que independente do vetor <code>vec</code> possuir valores do tipo <code>integer</code> (<code>1L</code> e <code>2L</code>), todo o vetor foi automaticamente convertido para o tipo <code>character</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>L, <span class="dv">2</span>L, <span class="st">"Texto"</span>)</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(vec)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "character"</code></pre>
</div>
</div>
<p>Um outro exemplo bem comum de coerção no R, é quando inserimos valores de um tipo “y” em um vetor que contém valores de um tipo “x”. Repare abaixo que, inicialmente, o vetor <code>a</code> possuía 3 elementos que pertenciam ao tipo <code>integer</code>. Porém, ao inserirmos um texto como quarto elemento desse vetor, todos os elementos desse vetor foram automaticamente convertidos para o tipo <code>character</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>L, <span class="dv">2</span>L, <span class="dv">3</span>L)</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(a)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "integer"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>a[<span class="dv">4</span>] <span class="ot">&lt;-</span> <span class="st">"Texto"</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(a)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1"     "2"     "3"     "Texto"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(a)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "character"</code></pre>
</div>
</div>
<p>Os exemplos acima são ilustrativos, pois na prática, você geralmente não provoca um processo de coerção de forma proposital. Na grande maioria das vezes, você será surpreendido por tal evento. Um exemplo bastante comum no dia-a-dia de coerção ocorre durante a importação de bases de dados mal formatadas. Isso significa que, um processo de coerção pode representar, em muitos momentos, um sinal vermelho para você, lhe indicando que há algo mal formatado na sua base de dados, ou que, você não está incluindo alguma configuração importante no comando de importação da base, ou ainda, que algum de seus comandos no R está gerando um <em>bug</em>, ou um resultado que os demais comandos de seu <em>script</em> não são capazes de lidar com.</p>
<p>Por outro lado, uma situação em que é extremamente útil nos aproveitarmos dessa coerção, é quando queremos somar um vetor lógico. Pois ao convertermos um vetor <code>logical</code> para um vetor <code>integer</code>, os valores <code>TRUE</code> são automaticamente convertidos para 1, enquanto valores <code>FALSE</code> são convertidos para 0. Com isso, você pode aplicar a função <code>sum()</code> sobre um teste lógico para descobrir, por exemplo, quantos elementos de um vetor são maiores do que 5. Para mais, ao calcularmos a média desse vetor lógico, com a função <code>mean()</code>, estamos na verdade calculando a proporção de <code>TRUE</code>’s neste vetor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">3.6</span>, <span class="fl">7.8</span>, <span class="fl">1.9</span>, <span class="fl">5.2</span>, <span class="fl">9.6</span>)</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(vec <span class="sc">&gt;</span> <span class="dv">5</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3</code></pre>
</div>
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(vec <span class="sc">&gt;</span> <span class="dv">5</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5</code></pre>
</div>
</div>
<p>Um processo de coerção ocorre apenas sobre vetores atômicos. Porém, lembre-se que todas as outras estruturas são construídas a partir desses vetores, ou todas as outras estruturas podem conter esses vetores dentro delas. Por isso, uma coluna de seu <code>data.frame</code>, ou toda uma matriz, podem sofrer uma coerção, independentemente de você ter ou não requisitado por tal transformação.</p>
<section id="a-árvore-de-coerção" class="level3" data-number="2.7.1">
<h3 data-number="2.7.1" class="anchored" data-anchor-id="a-árvore-de-coerção"><span class="header-section-number">2.7.1</span> A árvore de coerção</h3>
<p>Quando o processo de coerção ocorre, o R segue uma regra bem simples para escolher o tipo de dado para o qual os seus valores serão convertidos. Em resumo, o R irá sempre transformar os seus dados para o tipo de dado mais flexível, seguindo uma espécie de árvore ou hierarquia, a qual está referenciada na <a href="#fig-arvore-coercao" class="quarto-xref">Figura&nbsp;<span>2.9</span></a>. Você pode ver que o tipo <code>character</code>, está no topo da árvore e, portanto, é o tipo mais flexível de todos, enquanto o <code>logical</code> que está na base, é o tipo mais restrito de todos.</p>
<p>Isso significa, que se você criar um vetor com valores <code>integer</code> e <code>logical</code>, todos esses valores serão convertidos para <code>integer</code>’s. Por outro lado, se for um vetor com valores <code>integer</code> e <code>character</code>, esses valores serão convertidos para <code>character</code>’s. E assim por diante. Ou seja, você é capaz de prever para qual tipo esse vetor será convertido, ao olhar para os dois tipos que estão sendo misturados neste vetor, e identificar qual deles é tipo de dado mais flexível.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-arvore-coercao" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-arvore-coercao-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/arvore_coercao.png" class="img-fluid figure-img" style="width:100.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-arvore-coercao-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.9: Árvore de coerção
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="coerções-explícitas-com-as-funções-as." class="level3" data-number="2.7.2">
<h3 data-number="2.7.2" class="anchored" data-anchor-id="coerções-explícitas-com-as-funções-as."><span class="header-section-number">2.7.2</span> Coerções explícitas com as funções <code>as.*()</code></h3>
<p>Na seção <a href="#sec:funcoes_str_is">Identificando tipos e estruturas com a função <code>str()</code> e as funções <code>is.*()</code></a>, mostramos as funções <code>is.*()</code> que servem para identificarmos se um objeto pertence ou não a uma estrutura ou um tipo de dado específicos. Para além dessas funções, o R também nos oferece as funções <code>as.*()</code>.</p>
<p>Em suma, as funções <code>as.*()</code> servem para convertermos explicitamente os valores de um objeto para um tipo de dado específico. Ou seja, você aplica uma dessas funções quando você deseja provocar explicitamente um processo de coerção sobre um objeto. Como exemplo, se eu tenho um vetor contendo valores do tipo <code>double</code>, e desejo transformá-los em valores do tipo <code>character</code>, eu preciso apenas fornecer este vetor à função <code>as.character()</code>. Veja o exemplo abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.5</span>, <span class="sc">-</span><span class="dv">2</span>, <span class="dv">20</span>)</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.character</span>(vetor)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "0"   "1"   "0.5" "-2"  "20" </code></pre>
</div>
</div>
<p>Da mesma forma como ocorre com as funções <code>is.*()</code>, o nome da função <code>as.*()</code> que você está utilizando, determina o tipo de dado com o qual essa função trabalha. Logo, a função <code>as.logical()</code> busca converter um objeto para o tipo <code>logical</code>, enquanto a função <code>as.integer()</code>, converte um objeto para o tipo <code>integer</code>, e assim por diante. Abaixo temos uma lista dessas funções.</p>
<ul>
<li><code>as.character()</code>.</li>
<li><code>as.double()</code>.</li>
<li><code>as.integer()</code>.</li>
<li><code>as.logical()</code>.</li>
<li><code>as.numeric()</code>.</li>
</ul>
<p>Apesar de serem funções extremamente úteis, o R não é capaz de fazer mágica. Quando uma função <code>as.*()</code> encontra algum elemento que ela não consegue converter (de alguma forma lógica) para o tipo especificado, a função acaba inserindo um valor <code>NA</code> (valor não disponível) no lugar deste elemento. Por exemplo, se eu possuo o objeto <code>D</code> abaixo, e tento convertê-lo para o tipo <code>double</code>, apenas o terceiro elemento deste objeto é de fato convertido, pois o R <strong>não sabe como</strong> converter os outros dois elementos para o tipo <code>double</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb166"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>D <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"R$2,45"</span>, <span class="st">"Texto"</span>, <span class="st">"8.90"</span>)</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.double</span>(D)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: NAs introduced by coercion</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  NA  NA 8.9</code></pre>
</div>
</div>
<p>Como um outro exemplo, ao utilizarmos a função <code>as.logical()</code> sobre um objeto <code>x</code>, se esse objeto <code>x</code> se encontra no tipo <code>double</code> ou <code>integer</code>, todos os valores que forem iguais a 0, serão convertidos para <code>FALSE</code>, enquanto todos os demais valores (diferentes de 0) serão convertidos para <code>TRUE</code>. Contudo, se o objeto <code>x</code> se encontra no tipo <code>character</code>, apenas textos explícitos dos valores lógicos (<code>FALSE</code> e <code>TRUE</code>), podem ser convertidos. Perceba pelo exemplo abaixo, que o R consegue converter apenas os elementos 1, 5 e 6 do vetor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>vetor <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"TRUE"</span>, <span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"F"</span>, <span class="st">"T"</span>)</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="fu">as.logical</span>(vetor)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE    NA    NA    NA FALSE  TRUE</code></pre>
</div>
</div>
</section>
<section id="também-podemos-converter-estruturas-de-dados-com-as-funções-as." class="level3" data-number="2.7.3">
<h3 data-number="2.7.3" class="anchored" data-anchor-id="também-podemos-converter-estruturas-de-dados-com-as-funções-as."><span class="header-section-number">2.7.3</span> Também podemos converter estruturas de dados com as funções <code>as.*()</code></h3>
<p>Apesar do processo de coerção ocorrer (de forma automática e implícita) apenas sobre os tipos de dados associados a um objeto, nós também temos a capacidade de provocar um “processo de coerção” sobre a estrutura de dado empregada por um objeto, com as funções <code>as.*()</code>. Ou seja, da mesma forma que temos uma função <code>as.*()</code> para cada tipo de dado, nós também temos uma função <code>as.*()</code> para cada estrutura de dado do R. Como uma lista inicial, temos as seguintes funções:</p>
<ul>
<li><code>as.vector()</code>.</li>
<li><code>as.list()</code>.</li>
<li><code>as.matrix()</code>.</li>
<li><code>as.array()</code>.</li>
<li><code>as.data.frame()</code>.</li>
<li><code>tibble::as_tibble()</code>.</li>
</ul>
<p>Algumas conversões são bem diretas, e simples de se compreender. Por exemplo, uma lista (<code>list</code>) pode ser facilmente convertida para um <code>data.frame</code>, pois como descrevemos na seção <a href="#sec:estrutura_data_frames">Tabelas no R: <code>data.frame</code></a>, um <code>data.frame</code> é no fundo, uma lista nomeada com elementos de mesmo comprimento. Tal conversão é demonstrada no exemplo abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>lista <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">produtoid =</span> <span class="fu">c</span>(<span class="dv">1335</span>, <span class="dv">1335</span>, <span class="dv">1242</span>, <span class="dv">1198</span>),</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">preco =</span> <span class="fu">c</span>(<span class="fl">2.4</span>, <span class="fl">2.4</span>, <span class="fl">5.6</span>, <span class="fl">1.9</span>),</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">unidades =</span> <span class="fu">c</span>(<span class="dv">200</span>, <span class="dv">100</span>, <span class="dv">430</span>, <span class="dv">90</span>)</span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>data_frame <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(lista)</span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a>data_frame</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  produtoid preco unidades
1      1335   2.4      200
2      1335   2.4      100
3      1242   5.6      430
4      1198   1.9       90</code></pre>
</div>
</div>
<p>Por outro lado, algumas conversões podem ser estranhas. Por exemplo, ao convertermos uma matriz para uma lista, cada elemento dessa matriz é transformada em um elemento dessa nova lista. Esse mesmo processo ocorre se convertermos um vetor em uma lista. Lembre-se que, uma matriz é no fundo, um vetor com duas dimensões. Logo, ao requisitarmos a conversão de uma matriz para uma lista, é como se essa matriz fosse convertida primeiro para um vetor e, a partir desse vetor, fosse convertida para uma lista.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="at">nrow =</span> <span class="dv">2</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>m</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2]
[1,]    1    3
[2,]    2    4</code></pre>
</div>
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(m)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3

[[4]]
[1] 4</code></pre>
</div>
</div>
</section>
</section>
<section id="um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="um-estudo-de-caso-importando-os-dados-da-pintec-ibge-para-o-r"><span class="header-section-number">2.8</span> Um estudo de caso: importando os dados da PINTEC-IBGE para o R</h2>
<p>Como um exemplo prático de coerção, durante um determinado dia eu (Pedro) estava analisando os dados da PINTEC-IBGE (Pesquisa de Inovação), mais especificamente, a tabela 1 da pesquisa referente à edição de 2000. Com os comandos abaixo, você pode baixar o arquivo dessa tabela em Excel para um diretório temporário de seu computador e importá-la para dentro de seu R, de modo que você possa acompanhar os próximos comandos que vou mostrar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readxl)</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>github <span class="ot">&lt;-</span> <span class="st">"https://github.com/pedropark99/"</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>pasta <span class="ot">&lt;-</span> <span class="st">"Curso-R/raw/master/Dados/"</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>arquivo <span class="ot">&lt;-</span> <span class="st">"tab01_2000.xls"</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(github, pasta, arquivo)</span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>dir <span class="ot">&lt;-</span> <span class="fu">tempdir</span>()</span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>caminho <span class="ot">&lt;-</span> <span class="fu">paste</span>(dir, arquivo, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\\</span><span class="st">"</span>)</span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a><span class="fu">download.file</span>(url, <span class="at">destfile =</span> caminho, <span class="at">mode =</span> <span class="st">"wb"</span>)</span>
<span id="cb177-12"><a href="#cb177-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-13"><a href="#cb177-13" aria-hidden="true" tabindex="-1"></a>tab1 <span class="ot">&lt;-</span> readxl<span class="sc">::</span><span class="fu">read_excel</span>(</span>
<span id="cb177-14"><a href="#cb177-14" aria-hidden="true" tabindex="-1"></a>  caminho, </span>
<span id="cb177-15"><a href="#cb177-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">range =</span> <span class="st">"A9:R57"</span>,</span>
<span id="cb177-16"><a href="#cb177-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">col_names =</span> <span class="fu">paste0</span>(<span class="st">"X"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">18</span>)</span>
<span id="cb177-17"><a href="#cb177-17" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Neste dia, eu estava tentado calcular uma simples soma das colunas <code>X5</code> e <code>X6</code>, porém, o R estava me retornando o erro abaixo, me indicando que alguma dessas colunas estava associada a um tipo de dado não-numérico.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb178"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>tab1<span class="sc">$</span>X6 <span class="sc">+</span> tab1<span class="sc">$</span>X5</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>Error in tab1$X6 + tab1$X5 : non-numeric argument to binary operator</code></pre>
<p>Este é um erro inesperado, pois quando abrimos o arquivo Excel da tabela, podemos observar que praticamente todas as colunas da tabela (incluindo as colunas <code>X6</code> e <code>X5</code>) são claramente colunas numéricas e, portanto, deveriam estar sendo interpretadas por tipos numéricos. Ao analisarmos mais de perto a estrutura do objeto <code>tab1</code> com a função <code>str()</code>, podemos perceber que diversas colunas da tabela (incluindo a coluna <code>X6</code>) estão sendo interpretadas pelo tipo <code>character</code>, ao invés do tipo <code>double</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(tab1)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>tibble [49 x 18] (S3: tbl_df/tbl/data.frame)
 $ X1 : chr [1:49] "Total" "Indústrias extrativas" ...
 $ X2 : num [1:49] 72005 1729 70277 10253 9491 ...
 $ X3 : num [1:49] 22698 297 22401 3024 2773 ...
 $ X4 : num [1:49] 12658.5 92.5 12566 1683.5 1559 ...
 $ X5 : num [1:49] 10355.5 68.1 10287.3 1553.2 1439.4 ...
 $ X6 : chr [1:49] "2974.6496207720083" "27.740643394384399" ...
 $ X7 : num [1:49] 18160 285 17874 2558 2320 ...
 $ X8 : num [1:49] 16753 254 16499 2331 2099 ...
 $ X9 : num [1:49] 2000 36 1964 327 318 ...
 $ X10: num [1:49] 8120.3 80.7 8039.6 1216.7 1105.9 ...
 $ X11: num [1:49] 8944 146 8798 1325 1221 ...
 $ X12: chr [1:49] "3427.0471614397024" "25.137011567518176" ...
 $ X13: chr [1:49] "2996.0692977925214" "91.851470771912076" ...
 $ X14: num [1:49] 2520.6 28.6 2492 355.6 322.8 ...
 $ X15: chr [1:49] "4276.5049681355704" "62.304616808180924" ...
 $ X16: chr [1:49] "2264.1329981437439" "6.021725515719007" ...
 $ X17: chr [1:49] "1175.6811947066112" "51.283169365446376" ...
 $ X18: chr [1:49] "836.69077528521564" "4.99972192701554" ...</code></pre>
<p>Podemos confirmar esse cenário, ao aplicarmos a função <code>is.character()</code> sobre a coluna <code>X6</code>, como demonstrado abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb182"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.character</span>(tab1<span class="sc">$</span>X6)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>[1] TRUE</code></pre>
<p>Portanto, identificamos a origem do erro: a coluna <code>X6</code> está sendo interpretada pelo tipo <code>character</code> e, consequentemente, não pode ser somada diretamente a uma coluna do tipo <code>numeric</code>. Poderíamos utilizar a função <code>as.numeric()</code> sobre a coluna <code>X6</code> e somar o resultado à coluna <code>X5</code> para contornarmos esse problema. Todavia, seria útil identificarmos o porquê dessa coluna estar sendo interpretada desde o início como uma coluna de texto.</p>
<p>Se no arquivo original <code>tab01_2000.xls</code>, essas colunas estão configuradas como colunas numéricas, o mesmo deveria ocorrer dentro do R. Porque o R decidiu aplicar o tipo <code>character</code> sobre essas colunas? Podemos encontrar a resposta para essa pergunta ao olharmos mais atentamente para o intervalo da linha 15 à linha 24 dessa coluna <code>X6</code>. Abaixo, estou justamente selecionando esse intervalo de linhas da coluna. Perceba que na sexta linha do resultado, temos um símbolo de menos (<code>-</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>tab1[<span class="dv">15</span><span class="sc">:</span><span class="dv">24</span>, <span class="st">"X6"</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>### A tibble: 10 x 1
##    X6                
##    &lt;chr&gt;             
##  1 47.766222201789986
##  2 53.292711161353139
##  3 0                 
##  4 1.222975124981859 
##  5 0                 
##  6 -                 
##  7 1.222975124981859 
##  8 452.69478203700271
##  9 384.49410807956616
## 10 68.200673957436564</code></pre>
<p>Pense sobre “como o R deveria interpretar esse sinal de menos?”. Considerando apenas as 10 primeiras linhas da coluna <code>X6</code>, o R claramente optaria por um tipo de dado numérico para interpretar essa coluna. Contudo, ao se deparar com esse sinal de menos, como o R converteria esse símbolo para um número? A resposta é: ele simplesmente não sabe como realizar essa conversão! Logo, como o R não sabe como converter esse sinal de menos para um número, ele optou por interpretar esse símbolo pelo tipo de dado mais flexível de todos. Isto é, o tipo <code>characater</code>. Ao interpretar esse símbolo pelo tipo <code>character</code>, o R percebeu que teria de converter toda a coluna <code>X6</code> para o tipo <code>character</code> para manter esses dados juntos em uma mesma coluna.</p>
<p>Concluindo, este é um exemplo onde uma formatação ruim da base de dados, pode levar a coerções implícitas e inesperadas no R. Como um exercício, você pode abrir o arquivo <code>tab01_2000.xls</code> no Excel, e eliminar manualmente esse símbolo de menos da coluna <code>X6</code>, e tentar importar novamente o arquivo para o R. Ao fazer isso, você vai perceber que o tipo <code>double</code> será empregado sobre a coluna <code>X6</code>, ao invés do tipo <code>character</code>, pois justamente o R não enfrentou o entrave de encontrar um símbolo ou um texto, em uma coluna que é claramente numérica.</p>
</section>
<section id="subsetting" class="level2" data-number="2.9">
<h2 data-number="2.9" class="anchored" data-anchor-id="subsetting"><span class="header-section-number">2.9</span> <em>Subsetting</em></h2>
<p>As operações de <em>subsetting</em>, são extremamente importantes no R, e você irá utilizá-las com grande frequência ao longo de seu trabalho. Ao longo das seções de <a href="#sec:estruturas_dados">Estruturas de Dados</a>, eu dei exemplos sobre como utilizar o <em>subsetting</em> com cada tipo de estrutura. Tendo isso em mente, essa seção busca explicitar (ou formalizar) algumas características importantes dessas operações. Como o próprio nome dá a entender, as operações de <em>subsetting</em> servem para extrairmos ou modificarmos <em>subsets</em> (partes) de seus objetos <span class="citation" data-cites="Rlanguage">(<a href="references.html#ref-Rlanguage" role="doc-biblioref">TEAM, 2020a</a>)</span>. Como vimos anteriormente, essas operações são realizadas pelas funções <code>[</code> e <code>[[</code>.</p>
<p>Para utilizar a função <code>[</code>, você precisa abrir um par de colchetes (<code>[ ]</code>) após o nome do objeto (ou função) com o qual está trabalhando. Já para a função <code>[[</code>, você necessita abrir dois pares de colchetes (<code>[[ ]]</code>) após o nome (ou função) com o qual você está trabalhando. Também já vimos ao longo das seções de <a href="#sec:estruturas_dados">Estruturas de Dados</a>, que para extrairmos partes de estruturas unidimensionais como vetores e listas, precisamos de apenas um índice, ou de um único conjunto de índices. Mas para extrairmos partes de estruturas bidimensionais, como matrizes e <code>data.frame</code>’s, precisamos de dois índices, ou de dois conjuntos de índices.</p>
<p>Além disso, lembre-se que como definimos anteriormente, as listas são estruturas especiais, pois podem conter diversas outras estruturas em seus elementos. Portanto, apesar das listas serem estruturas unidimensionais, elas podem conter outras estruturas bidimensionais dentro delas. Por isso, caso você esteja interessado em extrair partes de uma estrutura bidimensional, que está dentro de algum elemento de uma lista, por exemplo, você irá precisar de uma combinação entre um único índice (para acessar o elemento da lista) e outros dois conjuntos de índices (para acessar uma parte específica da estrutura bidimensional).</p>
<section id="principais-diferenças-entre-as-funções-e" class="level3" data-number="2.9.1">
<h3 data-number="2.9.1" class="anchored" data-anchor-id="principais-diferenças-entre-as-funções-e"><span class="header-section-number">2.9.1</span> Principais diferenças entre as funções <code>[</code> e <code>[[</code>:</h3>
<ol type="1">
<li><p>A função <code>[</code> é capaz de trabalhar com todas as dimensões disponíveis de um objeto. Quais serão essas dimensões disponíveis depende da estrutura em que o objeto se encontra. Por outro lado, a função <code>[[</code> pode trabalhar apenas com uma dessas dimensões disponíveis.</p></li>
<li><p>A função <code>[</code> nos permite extrair um conjunto de elementos (ou seções) de um objeto (Ex: da 1° a 100° linha de um <code>data.frame</code>; os elementos 4, 5 e 8 de um vetor; do 3° ao 6° elemento de uma lista). Já a função <code>[[</code> nos permite extrair uma única parte, ou um único elemento de um objeto (Ex: o 5° elemento de uma lista; a 2° coluna de um <code>data.frame</code>; o 10° elemento de um vetor).</p></li>
<li><p>A função <code>[</code> geralmente lhe retorna um resultado na mesma estrutura de seu objeto original. Em outras palavras, se você utilizar a função <code>[</code> sobre uma lista, ela irá lhe retornar uma lista como resultado. Já a função <code>[[</code>, geralmente lhe retorna um resultado em uma estrutura diferente. Dito de outra forma, se você utilizar a função <code>[[</code> sobre um <code>data.frame</code>, por exemplo, ela geralmente vai lhe retornar um vetor como resultado.</p></li>
</ol>
</section>
<section id="dimensões-disponíveis-em-subsetting" class="level3" data-number="2.9.2">
<h3 data-number="2.9.2" class="anchored" data-anchor-id="dimensões-disponíveis-em-subsetting"><span class="header-section-number">2.9.2</span> Dimensões disponíveis em <em>subsetting</em></h3>
<p>A estrutura em que um objeto se encontra, define as dimensões que estão disponíveis para as funções <code>[</code> e <code>[[</code> . Logo, se você está trabalhando com um <code>data.frame</code>, por exemplo, você possui duas dimensões (linhas e colunas) com as quais você pode trabalhar com a função <code>[</code>. Mas se você está trabalhando com uma estrutura unidimensional, como um vetor atômico, você terá apenas uma única dimensão (os elementos desse vetor) para trabalhar em ambas às funções de <em>subsetting</em> (<code>[</code> e <code>[[</code>).</p>
<p>Uma das diferenças básicas entre as funções <code>[</code> e <code>[[</code>, se encontra no número de dimensões com as quais elas podem trabalhar. A função <code>[</code>, seria uma forma mais “geral” de <em>subsetting</em>, pois ela pode trabalhar com todas as dimensões disponíveis segundo a estrutura que um objeto se encontra. Já a função <code>[[</code>, representa uma forma mais restritiva de <em>subsetting</em>, pois ela trabalha em geral com apenas uma única dimensão de seu objeto (independentemente de qual seja a sua estrutura).</p>
<p>Portanto, se temos uma estrutura bidimensional como um <code>data.frame</code>, a função <code>[</code> pode trabalhar com as suas duas dimensões (linhas e colunas). Porém, a função <code>[[</code> pode trabalhar apenas com uma dessas dimensões, sendo no caso de <code>data.frame</code>’s, a dimensão das colunas. Agora, quando estamos trabalhando com uma estrutura unidimensional, como nós possuímos apenas uma dimensão (elementos) disponível, não há diferença entre as funções <code>[</code> e <code>[[</code> no sentido estabelecido anteriormente. De qualquer maneira, a função <code>[</code> continuará sendo a forma mais geral e flexível de <em>subsetting</em> para objetos unidimensionais. Pois a função <code>[</code> lhe permite selecionar um conjunto, ou uma sequência de elementos de uma estrutura unidimensional, enquanto que com a função <code>[[</code>, você poderá selecionar apenas um único elemento dessa estrutura. Um resumo das dimensões disponíveis em cada estrutura, se encontra na <a href="#fig-subsetting-table" class="quarto-xref">Figura&nbsp;<span>2.10</span></a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-subsetting-table" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-subsetting-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/subsetting_table.png" class="img-fluid figure-img" style="width:80.0%" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-subsetting-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.10: Resumo das dimensões disponíveis em cada estrutura
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-subsetting-table2" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-subsetting-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/subsetting_table2.png" class="img-fluid figure-img" style="width:80.0%" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-subsetting-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;2.11: Notação matemática das dimensões disponíveis em cada estrutura
</figcaption>
</figure>
</div>
</div>
</div>
<p>Nós também podemos ver essas diferenças entre as dimensões disponíveis em cada estrutura e para cada função de <em>subsetting</em>, sob uma perspectiva mais matemática, ao formar uma notação matemática de cada estrutura, incluindo subscritos que representem as suas respectivas dimensões. Essa visão está exposta na <a href="#fig-subsetting-table2" class="quarto-xref">Figura&nbsp;<span>2.11</span></a>. Por exemplo, pegando um <code>data.frame</code> chamado <span class="math inline">\(DF\)</span>, com <span class="math inline">\(i\)</span> linhas e <span class="math inline">\(j\)</span> colunas (<span class="math inline">\(DF_{i,j}\)</span>), temos que o comando <code>DF[2,4]</code> busca extrair o valor (ou valores) localizados na 2° linha da 4° coluna da tabela. Por outro lado, considerando-se uma lista chamada <span class="math inline">\(L\)</span>, contendo <span class="math inline">\(e\)</span> elementos (<span class="math inline">\(L_e\)</span>), o comando <code>L[[4]]</code>, traz como resultado, o 4° elemento dessa lista.</p>
</section>
<section id="tipos-de-índices" class="level3" data-number="2.9.3">
<h3 data-number="2.9.3" class="anchored" data-anchor-id="tipos-de-índices"><span class="header-section-number">2.9.3</span> Tipos de índices</h3>
<p>Os índices que você fornece às funções <code>[</code> e <code>[[</code>, podem ser de três tipos: 1) índices de texto - <code>character</code>; 2) índices numéricos - <code>integer</code>; 3) índices lógicos - <code>logical</code>. Logo abaixo, temos um exemplo do uso de índices numéricos sobre um vetor qualquer. Lembre-se que no caso de vetores, nós podemos utilizar um único índice para extrairmos um único valor do objeto em questão, e nós utilizamos dois ou mais índices, para extrairmos um conjunto de valores deste mesmo vetor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb186"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">2.2</span>, <span class="fl">1.3</span>, <span class="fl">4.5</span>, <span class="fl">3.7</span>, <span class="fl">5.2</span>)</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">4</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.7</code></pre>
</div>
<div class="sourceCode cell-code" id="cb188"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.2 1.3 4.5 3.7</code></pre>
</div>
<div class="sourceCode cell-code" id="cb190"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">1</span>)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.5 5.2 2.2</code></pre>
</div>
</div>
<p>Para utilizar um índice de texto (<code>character</code>), o objeto sobre o qual você está trabalhando, deve ser uma estrutura nomeada. Todas as estruturas (vetor, lista, matriz e <code>data.frame</code>) permitem o uso de nomes, que você pode acessar e definir através de funções como <code>colnames()</code>, <code>row.names()</code> e <code>names()</code>. Sendo que algumas estruturas, mais especificamente os <code>data.frame</code>’s, vão sempre nomear automaticamente os seus elementos. Ou seja, você sempre poderá utilizar um índice de texto em um <code>data.frame</code>, para selecionar alguma de suas colunas. Pois mesmo que você se esqueça de nomear alguma coluna, ao criar o seu <code>data.frame</code>, a função que cria essa estrutura irá automaticamente criar um nome qualquer para cada coluna não nomeada.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb192"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>],</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">nome =</span> <span class="st">"Ana"</span>,</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Belo Horizonte"</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   id nome       valor X.Belo.Horizonte.
1   A  Ana  1.48853088    Belo Horizonte
2   B  Ana -0.02411427    Belo Horizonte
3   C  Ana  0.12813567    Belo Horizonte
4   D  Ana  0.33721395    Belo Horizonte
5   E  Ana  0.42392884    Belo Horizonte
6   F  Ana  1.64710244    Belo Horizonte
7   G  Ana  0.42464561    Belo Horizonte
8   H  Ana  0.18352602    Belo Horizonte
9   I  Ana -0.11708401    Belo Horizonte
10  J  Ana -0.25152845    Belo Horizonte</code></pre>
</div>
<div class="sourceCode cell-code" id="cb194"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(df)[<span class="dv">4</span>] <span class="ot">&lt;-</span> <span class="st">"cidade"</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">"cidade"</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Belo Horizonte" "Belo Horizonte" "Belo Horizonte" "Belo Horizonte"
 [5] "Belo Horizonte" "Belo Horizonte" "Belo Horizonte" "Belo Horizonte"
 [9] "Belo Horizonte" "Belo Horizonte"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb196"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>df[<span class="fu">c</span>(<span class="st">"id"</span>, <span class="st">"valor"</span>)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   id       valor
1   A  1.48853088
2   B -0.02411427
3   C  0.12813567
4   D  0.33721395
5   E  0.42392884
6   F  1.64710244
7   G  0.42464561
8   H  0.18352602
9   I -0.11708401
10  J -0.25152845</code></pre>
</div>
<div class="sourceCode cell-code" id="cb198"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">"valor"</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1.48853088 -0.02411427  0.12813567  0.33721395  0.42392884  1.64710244
 [7]  0.42464561  0.18352602 -0.11708401 -0.25152845</code></pre>
</div>
<div class="sourceCode cell-code" id="cb200"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">"nome"</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana" "Ana"</code></pre>
</div>
</div>
<p>Em outras estruturas como um vetor, nomes não são atribuídos automaticamente a cada um de seus elementos, e por isso, você deve nomear os elementos deste vetor, para que você seja capaz de utilizar um índice de texto nele. Para isso, basta igualar esses elementos a um valor em texto (valor entre aspas) que representa esse nome, como no exemplo abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb202"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"b"</span> <span class="ot">=</span> <span class="dv">2</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="dv">3</span>, <span class="st">"d"</span> <span class="ot">=</span> <span class="dv">4</span>)</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>vec[<span class="st">"c"</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>c 
3 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb204"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"c"</span>, <span class="st">"b"</span>)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>a c b 
1 3 2 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb206"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>vec[[<span class="st">"b"</span>]]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2</code></pre>
</div>
</div>
<p>Por último, os índices lógicos (<code>TRUE</code> ou <code>FALSE</code>) são extremamente úteis em diversas aplicações, especialmente quando desejamos realizar um <em>subsetting</em> mais “complexo”. Porém, pelo fato de que a função <code>[[</code> nos permite extrair apenas uma única parte de um objeto, os índices lógicos são de certa forma inúteis com essa função. Portanto, sempre que utilizar índices do tipo lógico para selecionar os seus dados, você muito provavelmente quer utilizá-los com a função <code>[</code>. Por padrão, as funções <code>[</code> e <code>[[</code>, vão extrair todas as partes de um objeto, que possuírem um valor <code>TRUE</code> correspondente.</p>
<p>Portanto, no exemplo abaixo, caso eu utilize o vetor lógico <code>vlog</code>, para selecionar valores do vetor <code>vec</code>, a função <code>[</code> irá selecionar o 2°, 3° e 5° valor do vetor <code>vec</code>. Pois são essas as posições no vetor <code>vlog</code> que contém <code>TRUE</code>’s. Porém, a principal forma de gerarmos esses vetores lógicos a serem utilizados na função <code>[</code>, é através de testes lógicos. Por exemplo, podemos testar quais valores do vetor <code>vec</code>, são maiores do que 3, através do operador lógico <code>&gt;</code> (maior que).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb208"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">2.2</span>, <span class="fl">1.5</span>, <span class="fl">3.4</span>, <span class="fl">6.7</span>, <span class="fl">8.9</span>)</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>vlog <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="cn">FALSE</span>, <span class="cn">TRUE</span>, <span class="cn">TRUE</span>, <span class="cn">FALSE</span>, <span class="cn">TRUE</span>)</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>vec[vlog]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.5 3.4 8.9</code></pre>
</div>
<div class="sourceCode cell-code" id="cb210"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>vec[vec <span class="sc">&gt;</span> <span class="dv">3</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.4 6.7 8.9</code></pre>
</div>
</div>
<p>O R possui vários operadores lógicos diferentes, e o operador <code>&gt;</code> é apenas um deles. Um outro operador muito conhecido, é o de negação <code>"!"</code>. Este operador é utilizado, quando você deseja inverter um teste lógico, ou de certa forma, inverter o comportamento da função <code>[</code> quando fornecemos índices lógicos. O que o operador <code>!</code> faz na verdade, é inverter os valores de um vetor lógico. Logo, se eu aplicar este operador ao vetor <code>vlog</code>, esse será o resultado:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb212"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>vlog</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE FALSE FALSE  TRUE FALSE</code></pre>
</div>
</div>
<p>Portanto, os valores que antes eram <code>TRUE</code>, passam a ser <code>FALSE</code>, e vice-versa. Por isso, ao utilizarmos o operador <code>!</code> sobre um teste lógico qualquer, nós invertemos o teste em questão. Pois o operador <code>!</code> inverte os valores do vetor lógico resultante desse teste. Com isso, se eu utilizar esse operador sobre o teste anterior, onde testamos quais valores do vetor <code>vec</code> são maiores do que 3, nós estaremos efetivamente testando a hipótese contrária, de que esses valores são menores ou iguais a 3. Vale ressaltar, que esse operador deve ser posicionado antes do objeto que você deseja inverter, ou antes do teste lógico a ser realizado.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb214"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="sc">!</span>vec <span class="sc">&gt;</span> <span class="dv">3</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.2 1.5</code></pre>
</div>
</div>
<p>Um uso muito comum deste operador, é em conjunto com a função <code>is.na()</code>. Essa função, aplica um teste lógico sobre cada valor de um vetor, testando a hipótese de que esse valor se trata de um valor não-disponível (<code>NA</code>). Por isso, caso o valor em questão, seja de fato um valor não-disponível, a função <code>is.na()</code> irá retornar um <code>TRUE</code> correspondente, caso contrário, a função vai lhe retornar um <code>FALSE</code>. Logo, caso eu utilize a função <code>is.na()</code> dentro da função <code>[</code>, estaremos selecionando todos os valores não-disponíveis de um vetor. Porém, é muito mais comum que as pessoas queiram fazer justamente o contrário, que é eliminar esses valores não-disponíveis de seus dados. Por essa razão, é muito comum que se utilize o operador <code>!</code> em conjunto com a função <code>is.na()</code>, pois dessa forma, estaremos selecionando justamente os valores que se encaixam na hipótese contrária a testada por <code>is.na()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb216"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">2.2</span>, <span class="fl">1.3</span>, <span class="cn">NA_real_</span>, <span class="cn">NA_real_</span>, <span class="fl">2.5</span>)</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>vec</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.2 1.3  NA  NA 2.5</code></pre>
</div>
<div class="sourceCode cell-code" id="cb218"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="fu">is.na</span>(vec)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA NA</code></pre>
</div>
<div class="sourceCode cell-code" id="cb220"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>vec[<span class="sc">!</span><span class="fu">is.na</span>(vec)]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.2 1.3 2.5</code></pre>
</div>
</div>
<p>Vamos pensar no caso de um <code>data.frame</code>. Como definimos anteriormente, temos duas dimensões com as quais podemos trabalhar na função <code>[</code>, com este tipo de estrutura. Podemos por exemplo, utilizar o operador <code>!</code> e a função <code>is.na()</code> sobre a dimensão das linhas desse <code>data.frame</code>. Dessa forma, podemos eliminar todas as linhas dessa tabela, que possuam algum valor não-disponível em uma coluna. Veja o exemplo abaixo, em que uma tabela chamada <code>df</code>, contém três valores não-disponíveis na coluna <code>valor</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb222"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">8</span>],</span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor =</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">2.5</span>, <span class="cn">NA_real_</span>, <span class="fl">5.5</span>, <span class="cn">NA_real_</span>, <span class="cn">NA_real_</span>, <span class="fl">3.5</span>, <span class="fl">1.3</span>),</span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">nome =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Luiza"</span>, <span class="st">"João"</span>), <span class="at">size =</span> <span class="dv">8</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id valor  nome
1  A   1.2   Ana
2  B   2.5   Ana
3  C    NA   Ana
4  D   5.5   Ana
5  E    NA Luiza
6  F    NA   Ana
7  G   3.5  João
8  H   1.3 Luiza</code></pre>
</div>
<div class="sourceCode cell-code" id="cb224"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>nao_e_NA <span class="ot">&lt;-</span> <span class="sc">!</span>(<span class="fu">is.na</span>(df<span class="sc">$</span>valor))</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>df[nao_e_NA, ]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id valor  nome
1  A   1.2   Ana
2  B   2.5   Ana
4  D   5.5   Ana
7  G   3.5  João
8  H   1.3 Luiza</code></pre>
</div>
</div>
</section>
<section id="o-operador-e-a-estrutura-do-resultado" class="level3" data-number="2.9.4">
<h3 data-number="2.9.4" class="anchored" data-anchor-id="o-operador-e-a-estrutura-do-resultado"><span class="header-section-number">2.9.4</span> O operador <code>$</code> e a estrutura do resultado</h3>
<p>Você provavelmente se lembra do operador <code>$</code>, que se trata de um atalho à função <code>[[</code>. Porém, você talvez tenha percebido também, que utilizamos o operador <code>$</code> apenas em estruturas nomeadas. Logo, apesar de o operador <code>$</code> ser um “irmão” da função <code>[[</code>, ele não herda todas as características dessa função. Por exemplo, nós não podemos utilizar índices numéricos ou lógicos com este operador, para selecionarmos alguma parte de um objeto. Isto significa, que o operador <code>$</code> se trata de uma versão ainda mais restrita de <em>subsetting</em>, em relação à função <code>[[</code>. As únicas estruturas nomeadas com as quais este operador funciona, são listas e <code>data.frame</code>’s. Em outras palavras, mesmo que você nomeie os elementos de um vetor atômico, você não poderá utilizar o operador <code>$</code> para selecionar um desses elementos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb226"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span> <span class="ot">=</span> <span class="fl">2.5</span>, <span class="st">"b"</span> <span class="ot">=</span> <span class="fl">4.3</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="fl">1.2</span>)</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>vec<span class="sc">$</span>a</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb227"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>Error <span class="cf">in</span> vec<span class="sc">$</span>a <span class="sc">:</span> <span class="er">$</span> operator is invalid <span class="cf">for</span> atomic vectors</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Dentre as características da função <code>[[</code> herdadas pelo operador <code>$</code>, está o fato de que este operador pode trabalhar apenas com uma dimensão de um objeto. Em listas, podemos utilizar o operador <code>$</code> para selecionarmos algum dos elementos nomeados dessa lista. Já em <code>data.frame</code>’s, o operador <code>$</code> pode ser utilizado para selecionarmos uma das colunas desse <code>data.frame</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Um outro ponto a ser discutido, é que tanto o operador <code>$</code>, quanto a função <code>[[</code>, geram um resultado em uma estrutura diferente da estrutura do objeto original. Ou seja, quando realizamos um <em>subsetting</em> por meio desses operadores, o resultado geralmente possui uma estrutura com menos componentes do que a estrutura do objeto original, de onde estamos retirando esta parte. Dito de outra forma, se utilizarmos o operador <code>$</code>, ou a função <code>[[</code> para selecionarmos a coluna <code>valor</code> do <code>data.frame df</code> abaixo, o resultado de ambas as funções, serão um vetor atômico contendo os valores dessa coluna, e não um <code>data.frame</code> contendo apenas a coluna <code>valor</code>.</p>
<p>Logo, o uso da função <code>[[</code> (ou do operador <code>$</code>) sobre <code>data.frame</code>’s, vão lhe trazer a coluna (ou o elemento) em si do <code>data.frame</code>, e não um novo <code>data.frame</code> contendo essa coluna. Podemos confirmar isso, com o uso da função <code>str()</code>, que nos traz um resumo da estrutura de um objeto. Perceba nos exemplos abaixo, que em ambos os casos, o resultado da função <code>str()</code> está nos dizendo que o objeto resultante do uso de <code>$</code> ou de <code>[[</code>, se trata de um vetor atômico contendo dados do tipo numérico (<code>num</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb228"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>],</span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">valor =</span> <span class="fu">rnorm</span>(<span class="dv">10</span>),</span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">nome =</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Luiza"</span>, <span class="st">"João"</span>), <span class="at">size =</span> <span class="dv">10</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df<span class="sc">$</span>valor)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> num [1:10] -1.652 -0.268 -0.885 1.145 -1.522 ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb230"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df[[<span class="st">"valor"</span>]])</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> num [1:10] -1.652 -0.268 -0.885 1.145 -1.522 ...</code></pre>
</div>
</div>
<p>Essa característica é definida em detalhes no capítulo 4 de <span class="citation" data-cites="wickham2015_advanced">WICKHAM (<a href="references.html#ref-wickham2015_advanced" role="doc-biblioref">2015</a>)</span>. Sendo exatamente esta característica, que eu estava querendo destacar na <a href="#fig-lista2" class="quarto-xref">Figura&nbsp;<span>2.7</span></a>, quando estávamos descrevendo as listas. Se você utilizar a função <code>[</code> para selecionar um elemento de uma lista, o resultado será uma nova lista contendo esse elemento. Mas se você utilizar a função <code>[[</code> para fazer este trabalho, o resultado será apenas o elemento em si.</p>
<p>Você pode entender essa característica como uma “simplificação do resultado”, como se as funções <code>[[</code> e <code>$</code> gerassem um resultado em uma estrutura mais simples do que a do objeto original. Porém, eu creio que essa é uma forma equivocada de se enxergar esse sistema, pois estruturas não são usualmente comparadas em níveis de complexidade, mas sim por suas propriedades e características.</p>
<p>Por isso, uma forma mais útil e fiel de se enxergar essa característica, é através da representação apresentada pela <a href="#fig-lista2" class="quarto-xref">Figura&nbsp;<span>2.7</span></a>, onde através da função <code>[[</code>, podemos selecionar o elemento em si, e não uma nova estrutura contendo este elemento. Além disso, uma outra forma útil de enxergarmos essa característica no resultado das funções <code>[[</code> e <code>$</code>, é como uma forma de eliminarmos componentes da estrutura do objeto original. Em outras palavras, podemos enxergar o operador <code>$</code> ou a função <code>[[</code>, como uma forma de gerarmos um resultado com menos componentes do que a estrutura do objeto original.</p>
<p>Por exemplo, se temos um <code>data.frame</code> chamado <code>df</code>, onde temos duas colunas simples (que são vetores atômicos), e em seguida, adicionamos duas novas colunas, uma contendo uma lista, e outra contendo um outro <code>data.frame</code> de duas colunas (<code>y</code> e <code>z</code>), nós temos uma estrutura razoavelmente complexa. Se utilizarmos a função <code>str()</code>, para nos fornecer um resumo da estrutura de <code>df</code>, vemos que esse objeto tem pelo menos três componentes: 1) os vetores representados pelas colunas <code>x</code> e <code>nome</code>; 2) os cinco elementos da lista alocada na coluna <code>lista</code>; 3) e as duas colunas contidas no <code>data.frame</code> da coluna <code>outro_df</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb232"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> <span class="fu">rnorm</span>(<span class="dv">5</span>),</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">nome =</span> <span class="st">"Ana"</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>df<span class="sc">$</span>lista <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a>df<span class="sc">$</span>outro_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">y =</span> <span class="fu">rnorm</span>(<span class="dv">5</span>), <span class="at">z =</span> <span class="fu">rnorm</span>(<span class="dv">5</span>))</span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   5 obs. of  4 variables:
 $ x       : num  -1.674 -0.258 -0.695 1.316 -0.682
 $ nome    : chr  "Ana" "Ana" "Ana" "Ana" ...
 $ lista   :List of 5
  ..$ : num 1
  ..$ : num 2
  ..$ : num 3
  ..$ : num 4
  ..$ : num 5
 $ outro_df:'data.frame':   5 obs. of  2 variables:
  ..$ y: num  0.407 -0.538 -0.152 0.489 -0.449
  ..$ z: num  -1.0871 -0.5038 0.3307 0.0512 0.7805</code></pre>
</div>
</div>
<p>Caso eu utilize as funções <code>[[</code> e <code>$</code> para selecionarmos alguma das colunas de <code>df</code>, podemos aplicar novamente a função <code>str()</code> sobre o resultado, para compreendermos sua estrutura. Veja pelo exemplo abaixo, que o resultado da função <code>str()</code> nos descreve uma estrutura com menos componentes do que a estrutura original. Com isso, eu quero destacar que a estrutura desse resultado não necessariamente será menos “complexa” do que a original, mas sim que essa estrutura terá menos componentes. Portanto, pelo menos um dos componentes da estrutura original, será eliminado com o uso de <code>[[</code> ou de <code>$</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb234"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df[[<span class="st">"lista"</span>]])</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 5
 $ : num 1
 $ : num 2
 $ : num 3
 $ : num 4
 $ : num 5</code></pre>
</div>
<div class="sourceCode cell-code" id="cb236"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df[[<span class="st">"outro_df"</span>]])</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   5 obs. of  2 variables:
 $ y: num  0.407 -0.538 -0.152 0.489 -0.449
 $ z: num  -1.0871 -0.5038 0.3307 0.0512 0.7805</code></pre>
</div>
<div class="sourceCode cell-code" id="cb238"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df<span class="sc">$</span>outro_df)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   5 obs. of  2 variables:
 $ y: num  0.407 -0.538 -0.152 0.489 -0.449
 $ z: num  -1.0871 -0.5038 0.3307 0.0512 0.7805</code></pre>
</div>
</div>
</section>
</section>
<section id="valores-especiais-do-r" class="level2" data-number="2.10">
<h2 data-number="2.10" class="anchored" data-anchor-id="valores-especiais-do-r"><span class="header-section-number">2.10</span> Valores especiais do R</h2>
<p>Na linguagem R, possuímos alguns valores especiais, que não apenas são tratados de maneira diferente em relação a outros valores, mas que também efetivamente alteram o comportamento de algumas operações importantes na linguagem. Por exemplo, se você tentar dividir qualquer número por zero no console, ao invés do R lhe retornar um erro, lhe indicando que essa divisão é indefinida, o console vai lhe retornar o valor <code>Inf</code>, que se refere a infinito (ou <em>infinite</em>).</p>
<p>Por outro lado, de forma ainda mais estranha, se você tentar dividir zero por ele mesmo, o console vai lhe retornar o valor <code>NaN</code>, que significa <em>“not a number”</em>, ou em outras palavras, que o valor resultante da divisão não é um número.</p>
<p>Assim como várias outras linguagens de programação, o R também possui um valor “nulo”, ou, em outras palavras, um valor que representa o “vazio” ou o “nada”. Este valor é o <code>NULL</code>. Você encontra esse valor, sempre que a função ou expressão que você executou não possui um valor de retorno definido.</p>
<p>Esses são alguns exemplos de valores especiais que você pode adquirir. Porém, o valor especial mais comum, é o valor <code>NA</code>, que significa <em>not avaliable</em>, ou “não-disponível”. Este valor geralmente é resultado de uma dessas duas situações: 1) ao importar a sua base de dados para o R, a linguagem vai preencher automaticamente todas as células em sua base que estiverem vazias, com um valor <code>NA</code>; 2) quando você executa (ou causa de maneira indireta) um processo de coerção, no qual o R não consegue realizar. Ou seja, se o R não souber como converter um valor específico, para o tipo de dado ao qual você requisitou, ele vai lhe retornar um valor <code>NA</code> correspondente àquele valor.</p>
<p>Portanto, a primeira situação ocorre durante o processo de importação de dados, em todas as ocasiões em que você possuir alguma observação vazia na base de dados que você está importando. Logo, se em uma planilha do Excel, por exemplo, você possuir alguma célula vazia em sua tabela, ao importar essa planilha para o R, essas células vazias serão preenchidas com valores <code>NA</code> no R. Lembre-se que um valor <code>NA</code> indica uma observação não-disponível, o que significa que o valor correspondente aquela observação não pôde ser observado, ou não pôde ser registrado no momento de coleta dos dados.</p>
<p>Já a segunda situação, ocorre sempre quando o R não sabe como realizar o processo de coerção, pelo qual requisitamos, de uma forma lógica. Por exemplo, isso ocorre ao tentarmos converter valores de texto para números com <code>as.double()</code>. Pois o R não sabe como, ou não sabe qual a maneira mais adequada de se converter esses valores em texto para números. Por isso, a linguagem vai lhe retornar como resultado, valores <code>NA</code>.</p>
<section id="sec:impactos_valores_especiais" class="level3" data-number="2.10.1">
<h3 data-number="2.10.1" class="anchored" data-anchor-id="sec:impactos_valores_especiais"><span class="header-section-number">2.10.1</span> Os impactos desses valores especiais</h3>
<p>Por que estamos falando desses valores especiais? Porque eles alteram o comportamento de certas operações importantes do R e, com isso, podem deixar você desorientado! Por exemplo, se você tentar calcular a soma de uma coluna (de um <code>data.frame</code>) que contém um valor <code>NA</code>, o resultado dessa operação será um valor <code>NA</code>. Da mesma forma, se a coluna possuir um valor <code>NaN</code>, o resultado dessa soma será um valor <code>NaN</code>. Para que isso ocorra, o valor especial pode estar em qualquer linha que seja, basta que ele ocorra uma única vez, que a sua soma não vai funcionar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb240"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="cn">NA</span>, <span class="dv">4</span>))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA</code></pre>
</div>
<div class="sourceCode cell-code" id="cb242"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="cn">NaN</span>, <span class="dv">4</span>))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NaN</code></pre>
</div>
</div>
<p>Isso não significa que esses valores especiais serão uma dor de cabeça para você, pois cada um deles tem o seu propósito, e eles o cumprem muito bem. Mas é importante que você saiba do quão especiais eles são, e dos efeitos que eles causam em certas operações no R. Com isso, se em alguma situação uma função lhe retornar um valor <code>NA</code>, quando ela deveria lhe retornar algum valor definido, ou se essa função se comportar de maneira inesperada, você pode desconfiar que algum valor especial presente em seus dados, possa ser a fonte de sua surpresa.</p>
<p>Em geral, todas as funções que são afetadas por esses valores especiais, como as funções <code>sum()</code> e <code>mean()</code>, possuem um argumento <code>na.rm</code>, que define se a função deve ignorar esses valores especiais em seus cálculos. Portanto, caso uma coluna de seu <code>data.frame</code> possua esses valores especiais, e você precisa ignorá-los durante o cálculo de uma soma, lembre-se de configurar este argumento para verdadeiro (<code>TRUE</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb244"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="cn">NA</span>, <span class="dv">4</span>), <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 10</code></pre>
</div>
</div>
<p>Um outro tipo de operação importante que é afetada por esses valores especiais, são os testes lógicos. Como exemplo, vamos criar um teste lógico sobre os dados apresentados pela tabela <code>compras</code>. Nós temos nessa tabela, o nome da composição química dos principais remédios que estão em falta nos estoques de três grandes hospitais. Os três remédios presentes nessa tabela, são remédios bem comuns, como o valor <code>AA</code> que se refere à composição química da Aspirina (Ácido Acetilsalicílico).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb246"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>compras <span class="ot">&lt;-</span> <span class="fu">structure</span>(<span class="fu">list</span>(<span class="at">ano =</span> <span class="fu">c</span>(<span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>, </span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2019</span>, <span class="dv">2019</span>, <span class="dv">2019</span>), <span class="at">mes =</span> <span class="fu">c</span>(<span class="dv">2</span>L, <span class="dv">4</span>L, <span class="dv">5</span>L, <span class="dv">6</span>L, <span class="dv">8</span>L, <span class="dv">8</span>L, <span class="dv">10</span>L, <span class="dv">10</span>L, </span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span>L, <span class="dv">12</span>L), <span class="at">hospital1 =</span> <span class="fu">c</span>(<span class="st">"AA"</span>, <span class="cn">NA</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span>, <span class="cn">NA</span>, </span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a><span class="st">"doxiciclina"</span>, <span class="cn">NA</span>, <span class="st">"AA"</span>, <span class="st">"doxiciclina"</span>, <span class="cn">NA</span>), <span class="at">hospital2 =</span> <span class="fu">c</span>(<span class="st">"AA"</span>, </span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a><span class="st">"doxiciclina"</span>, <span class="st">"dexametasona"</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span>, <span class="cn">NA</span>, <span class="st">"dexametasona"</span>, </span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a><span class="st">"AA"</span>, <span class="st">"dexametasona"</span>, <span class="st">"AA"</span>), <span class="at">hospital3 =</span> <span class="fu">c</span>(<span class="st">"AA"</span>, <span class="st">"AA"</span>, <span class="st">"dexametasona"</span>, </span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a><span class="cn">NA</span>, <span class="st">"dexametasona"</span>, <span class="st">"doxiciclina"</span>, <span class="st">"dexametasona"</span>, <span class="cn">NA</span>, <span class="cn">NA</span>, <span class="st">"AA"</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>)), <span class="at">row.names =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">class =</span> <span class="st">"data.frame"</span>)</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>compras</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    ano mes    hospital1    hospital2    hospital3
1  2019   2           AA           AA           AA
2  2019   4         &lt;NA&gt;  doxiciclina           AA
3  2019   5 dexametasona dexametasona dexametasona
4  2019   6           AA dexametasona         &lt;NA&gt;
5  2019   8         &lt;NA&gt;           AA dexametasona
6  2019   8  doxiciclina         &lt;NA&gt;  doxiciclina
7  2019  10         &lt;NA&gt; dexametasona dexametasona
8  2019  10           AA           AA         &lt;NA&gt;
9  2019  10  doxiciclina dexametasona         &lt;NA&gt;
10 2019  12         &lt;NA&gt;           AA           AA</code></pre>
</div>
</div>
<p>Por exemplo, se nós quiséssemos identificar todas as linhas na tabela <code>compras</code>, em que a composição química da Aspirina (valor <code>AA</code>) aparece em pelo menos um dos hospitais (ou dito de outra forma, em pelo menos uma das colunas), poderíamos aplicar um teste lógico sobre a tabela <code>compras</code>. O teste lógico abaixo, serve para esse propósito, mas se olharmos para o resultado desse teste, podemos identificar que algo está errado.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb248"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> compras<span class="sc">$</span>hospital1 <span class="sc">==</span> <span class="st">"AA"</span> <span class="sc">|</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>  compras<span class="sc">$</span>hospital2 <span class="sc">==</span> <span class="st">"AA"</span> <span class="sc">|</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>  compras<span class="sc">$</span>hospital3 <span class="sc">==</span> <span class="st">"AA"</span> </span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>teste</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  TRUE  TRUE FALSE  TRUE  TRUE    NA    NA  TRUE    NA  TRUE</code></pre>
</div>
</div>
<p>Perceba acima, que o teste lógico detectou com sucesso todas as linhas da tabela <code>compras</code>, que possuem um valor <code>AA</code> em pelo menos uma de suas colunas. Mais especificamente, as linhas de posição 1°, 2°, 4°, 5°, 8° e 10°. Porém, podemos também identificar, que para as linhas de posição 6°, 7° e 9° na tabela, o teste lógico <code>teste</code> nos retornou valores <code>NA</code>. Ou seja, ao invés do teste lógico nos retornar um valor <code>FALSE</code>, para as linhas que não possuem um valor <code>AA</code> ao longo de suas colunas, ele acaba nos retornando um valor <code>NA</code>, pelo simples fato de que temos um valor <code>NA</code> em pelo menos uma das colunas. Isso se torna um grande problema, a partir do momento em que desejamos filtrar a nossa tabela <code>compras</code>, ao fornecer o nosso vetor <code>teste</code>, à função de <em>subsetting</em>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb250"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>compras[teste, ]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      ano mes hospital1    hospital2    hospital3
1    2019   2        AA           AA           AA
2    2019   4      &lt;NA&gt;  doxiciclina           AA
4    2019   6        AA dexametasona         &lt;NA&gt;
5    2019   8      &lt;NA&gt;           AA dexametasona
NA     NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
NA.1   NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
8    2019  10        AA           AA         &lt;NA&gt;
NA.2   NA  NA      &lt;NA&gt;         &lt;NA&gt;         &lt;NA&gt;
10   2019  12      &lt;NA&gt;           AA           AA</code></pre>
</div>
</div>
<p>Portanto, o problema gerado pelos valores <code>NA</code> presentes no resultado do teste lógico, é que eles geram indiretamente um novo problema a ser resolvido. O objetivo principal está em identificar as linhas da tabela <code>compras</code>, que possuem um valor <code>AA</code>, em pelo menos uma de suas colunas, e filtrá-las da tabela. Porém, ao fornecermos esse vetor <code>teste</code> à função de <em>subsetting</em>, a função <code>[</code> acaba adicionando uma nova linha ao resultado, para cada valor <code>NA</code> presente no vetor <code>teste</code>. Logo, o resultado que era para ter 6 linhas, acaba tendo 9. Com isso, teríamos um novo trabalho de eliminar essas novas linhas de <code>NA</code>’s, para chegarmos às linhas que queremos filtrar da nossa tabela <code>compras</code>.</p>
</section>
<section id="valores-especiais-também-estão-associados-a-algum-tipo-de-dado" class="level3" data-number="2.10.2">
<h3 data-number="2.10.2" class="anchored" data-anchor-id="valores-especiais-também-estão-associados-a-algum-tipo-de-dado"><span class="header-section-number">2.10.2</span> Valores especiais também estão associados a algum tipo de dado</h3>
<p>Vale destacar que, assim como qualquer outro valor no R, os valores especiais do R também estão associados a algum dos 5 tipos básicos de dados apresentados na seção <a href="#sec:fundamentos_tipos_dados">Tipos de dados</a>. Como exemplo, os valores <code>Inf</code>, <code>-Inf</code> e <code>NaN</code> são valores associados ao tipo <code>double</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb252"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="cn">Inf</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "double"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb254"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="sc">-</span><span class="cn">Inf</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "double"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb256"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="cn">NaN</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "double"</code></pre>
</div>
</div>
<p>Por outro lado, o valor <code>NA</code> é por padrão, um valor do tipo <code>logical</code>. Porém, diferentemente de <code>Inf</code>, <code>-Inf</code> e <code>NaN</code>, o valor <code>NA</code> possui diferentes “versões” para cada um dos 5 tipos de dados. Essas versões são <code>NA_character_</code>, <code>NA_real_</code>, <code>NA_complex_</code> e <code>NA_integer_</code>. Temos também outras “versões” referentes a tipos de dados mais complexos, como <code>NA_POSIXct_</code> e <code>NA_Date_</code> que se referem aos tipos <code>POSIXct</code> e <code>Date</code>, os quais vamos descrever no capítulo <a href="12-variaveis-tempo.html#sec:lubridate_var_tempo">Introdução à variáveis de tempo com <code>lubridate</code></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb258"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="cn">NA</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "logical"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb260"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="cn">NA_character_</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "character"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb262"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="fu">typeof</span>(<span class="cn">NA_real_</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "double"</code></pre>
</div>
</div>
<p>Portanto, valores como <code>Inf</code>, <code>-Inf</code> e <code>NaN</code> estão presentes apenas no tipo <code>double</code>, enquanto o valor <code>NA</code> possui uma “versão” para cada tipo de dado no R. Tanto que, se tentarmos converter um valor como <code>NaN</code> para algum outro tipo, como o tipo <code>logical</code>, ele será automaticamente convertido para um valor <code>NA</code> do tipo <code>logical</code>, como demonstrado abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb264"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.logical</span>(<span class="cn">NaN</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA</code></pre>
</div>
</div>
</section>
<section id="como-identificar-valores-especiais" class="level3" data-number="2.10.3">
<h3 data-number="2.10.3" class="anchored" data-anchor-id="como-identificar-valores-especiais"><span class="header-section-number">2.10.3</span> Como identificar valores especiais</h3>
<p>Por serem valores especiais, o R nos oferece um conjunto de funções para cada um desses valores especiais, as quais estão listadas abaixo:</p>
<ul>
<li><code>is.na()</code>.</li>
<li><code>is.finite()</code>.</li>
<li><code>is.infinite()</code>.</li>
<li><code>is.nan()</code></li>
</ul>
<p>A função <code>is.finite()</code> busca identificar se um valor numérico é finito, o que significa basicamente, um valor do tipo <code>numeric</code> diferente de <code>Inf</code>, <code>-Inf</code>, <code>NaN</code> e de <code>NA</code>. Perceba abaixo que, quando digo que a função <code>is.finite()</code> busca testar valores numéricos, estou querendo dizer que essa função é irrelevante para testar valores do tipo <code>character</code>, dado que ela nos retorna <code>FALSE</code> para qualquer valor textual. Repare também que essa função nos retorna <code>TRUE</code> para dados do tipo <code>logical</code>, dado que, no fundo, valores do tipo <code>logical</code> são armazenados através de 1’s e 0’s do tipo <code>integer</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb266"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(purrr)</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a>objs <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="cn">Inf</span>, <span class="cn">NaN</span>, <span class="cn">NA</span>, <span class="st">"texto"</span>, <span class="fl">1.25</span>, <span class="dv">1</span>L, <span class="cn">TRUE</span>)</span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a>r <span class="ot">&lt;-</span> <span class="fu">map_lgl</span>(objs, is.finite)</span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(r) <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Inf"</span>, <span class="st">"NaN"</span>, <span class="st">"NA"</span>,</span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"character"</span>, <span class="st">"double"</span>,</span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"integer"</span>, <span class="st">"logical"</span></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(r)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Inf       NaN        NA character    double   integer   logical 
    FALSE     FALSE     FALSE     FALSE      TRUE      TRUE      TRUE </code></pre>
</div>
</div>
<p>Ao descobrir o valor <code>NA</code>, você talvez tenha pensado que você seria capaz de identificar esse valor especial por um simples teste de igualdade. Entretanto, como descrevemos na seção <a href="#sec:impactos_valores_especiais">Os impactos desses valores especiais</a>, valores especiais alteram o comportamento de testes lógicos tradicionais, de modo que, um teste de igualdade como <code>x == NA</code> vai sempre resultar em um novo valor <code>NA</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb268"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>x <span class="sc">==</span> <span class="cn">NA</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NA</code></pre>
</div>
</div>
<p>Portanto, a forma adequada de se testar se um determinado objeto no R contém um valor <code>NA</code>, é aplicar a função <code>is.na()</code> sobre o objeto em questão. Caso o seu objetivo seja justamente o contrário (isto é, testar se o objeto não contém um valor <code>NA</code>), você precisa apenas inverter o teste lógico ao adicionar o operador <code>!</code> sobre a função.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb270"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.na</span>(x)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb272"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fazendo o teste inverso:</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span><span class="fu">is.na</span>(x)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<p>Já as funções <code>is.infinite()</code> e <code>is.nan()</code> funcionam exatamente da mesma forma, com a diferença que, essas funções testam se o objeto contém valores infinitos (<code>Inf</code> e <code>-Inf</code>) e valores <code>NaN</code>, respectivamente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb274"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.infinite</span>(<span class="cn">Inf</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb276"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="fu">is.nan</span>(<span class="cn">NaN</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>


<div id="refs" class="references csl-bib-body" data-entry-spacing="1" role="list" style="display: none">
<div id="ref-chambers2016" class="csl-entry" role="listitem">
CHAMBERS, J. M. <strong>Extending R</strong>. Boca Raton, FL: CRC Press, 2016.
</div>
<div id="ref-peng2015" class="csl-entry" role="listitem">
PENG, R. D. <strong><a href="https://bookdown.org/rdpeng/rprogdatascience/">R Programming for Data Science</a></strong>. [s.l.] Leanpub, 2015.
</div>
<div id="ref-Rlanguage" class="csl-entry" role="listitem">
TEAM, R. C. <strong><a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html">R Language Definition</a></strong>. Version 4.0.3 ed. [s.l.] R Foundation, 2020a.
</div>
<div id="ref-Rintroduction" class="csl-entry" role="listitem">
TEAM, R. C. <strong><a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html">An Introduction to R: A Programming Environment for Data Analysis and Graphics</a></strong>. Version 4.0.3 ed. [s.l.] R Foundation, 2020b.
</div>
<div id="ref-wickham2015_advanced" class="csl-entry" role="listitem">
WICKHAM, H. <strong><a href="https://adv-r.hadley.nz">Advanced R</a></strong>. 2. ed. Boca Raton, Florida: CRC Press, 2015.
</div>
<div id="ref-wickham2017" class="csl-entry" role="listitem">
WICKHAM, H.; GROLEMUND, G. <strong><a href="https://r4ds.had.co.nz">R for Data Science</a></strong>. Sebastopol, CA: O’Reilly Media, Inc., 2017.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://www.youtube.com/watch?v=rz3_FDVt9eg" class="uri">https://www.youtube.com/watch?v=rz3_FDVt9eg</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Caso tenha alguma dificuldade em chamar pelo pacote, volte a seção <a href="01-nocoes-basicas.html#sec:pacotes">Pacotes</a> para descobrir o passo que você se esqueceu de cumprir.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Lembre-se que no fundo, <code>data.frame</code>’s são listas, com a propriedade de que todos os elementos dessa lista, devem possuir o mesmo número de linhas. Portanto, se cada coluna desse <code>data.frame</code> representa um elemento da lista que forma esse <code>data.frame</code>, ao utilizarmos o operador <code>$</code>, também estaríamos selecionando um “elemento”, que se traduz em uma coluna do <code>data.frame</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiada");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiada");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Capítulos/01-nocoes-basicas.html" class="pagination-link" aria-label="Noções Básicas do R">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Noções Básicas do R</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Capítulos/03-tidyverse.html" class="pagination-link" aria-label="Introduzindo o universo do `tidyverse`">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduzindo o universo do <code>tidyverse</code></span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>