<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-BR" xml:lang="pt-BR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Introdução à Linguagem R - 10&nbsp; Manipulação e transformação de strings com stringr</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 1em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../Capítulos/11-factors.html" rel="next">
<link href="../Capítulos/09-theme-ggplot.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Nenhum resultado",
    "search-matching-documents-text": "documentos correspondentes",
    "search-copy-link-title": "Copiar link para a busca",
    "search-hide-matches-text": "Esconder correspondências adicionais",
    "search-more-match-text": "mais correspondência neste documento",
    "search-more-matches-text": "mais correspondências neste documento",
    "search-clear-button-title": "Limpar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Procurar"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Capítulos/10-strings.html">Ferramentas para tipos específicos de dados</a></li><li class="breadcrumb-item"><a href="../Capítulos/10-strings.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Manipulação e transformação de <em>strings</em> com <code>stringr</code></span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introdução à Linguagem R</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Procurar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefácio</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Introduzindo a Linguagem R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/01-nocoes-basicas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Noções Básicas do R</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/02-fundamentos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Fundamentos da Linguagem R</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Importando, organizando e transformando dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/03-tidyverse.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduzindo o universo do <code>tidyverse</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/03-importacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Importando e exportando dados com <code>readr</code>, <code>readxl</code> e <code>haven</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/04-transformacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Transformando dados com <code>dplyr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/06-dados-relacionais.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introdução a base de dados relacionais com <code>dplyr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/07-tidy-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title"><em>Tidy Data</em>: uma abordagem para organizar os seus dados com <code>tidyr</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Visualizando seus dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/08-ggplot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Visualização de dados com <code>ggplot2</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/09-theme-ggplot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Configurando componentes estéticos do gráfico no <code>ggplot2</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">Ferramentas para tipos específicos de dados</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/10-strings.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Manipulação e transformação de <em>strings</em> com <code>stringr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/11-factors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Introduzindo fatores (<em>factor</em>’s) com <code>forcats</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/12-variaveis-tempo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introdução à variáveis de tempo com <code>lubridate</code></span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Funções e Loops: construindo os seus próprios programas e automatizando tarefas</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/13-controle-fluxo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Controle condicional de fluxo</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/05-funcoes-loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Funções</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/17-loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title"><em>Loops</em></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/18-purrr.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title"><em>Functional programming</em> com <code>purrr</code></span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/15-debugging.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title"><em>Debugging</em> - Resolvendo <em>bugs</em> em suas funções</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/16-environments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title"><em>Environments</em> ou ambientes no R</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true">
 <span class="menu-text">Apêndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="true" aria-label="Alternar seção">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercícios</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Capítulos/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências bibliográficas</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Índice</h2>
   
  <ul>
  <li><a href="#sec:stringr_capitulo" id="toc-sec:stringr_capitulo" class="nav-link active" data-scroll-target="#sec\:stringr_capitulo"><span class="header-section-number">10.1</span> Introdução e pré-requisitos</a></li>
  <li><a href="#algumas-noções-básicas" id="toc-algumas-noções-básicas" class="nav-link" data-scroll-target="#algumas-noções-básicas"><span class="header-section-number">10.2</span> Algumas noções básicas</a></li>
  <li><a href="#concatenando-ou-combinando-strings-com-paste-e-str_c" id="toc-concatenando-ou-combinando-strings-com-paste-e-str_c" class="nav-link" data-scroll-target="#concatenando-ou-combinando-strings-com-paste-e-str_c"><span class="header-section-number">10.3</span> Concatenando ou combinando <em>strings</em> com <code>paste()</code> e <code>str_c()</code></a>
  <ul class="collapse">
  <li><a href="#a-função-str_c-como-uma-alternativa-para-concatenação-de-strings" id="toc-a-função-str_c-como-uma-alternativa-para-concatenação-de-strings" class="nav-link" data-scroll-target="#a-função-str_c-como-uma-alternativa-para-concatenação-de-strings"><span class="header-section-number">10.3.1</span> A função <code>str_c()</code> como uma alternativa para concatenação de <em>strings</em></a></li>
  </ul></li>
  <li><a href="#vantagens-do-pacote-stringr" id="toc-vantagens-do-pacote-stringr" class="nav-link" data-scroll-target="#vantagens-do-pacote-stringr"><span class="header-section-number">10.4</span> Vantagens do pacote <code>stringr</code></a></li>
  <li><a href="#comprimento-de-strings-com-str_length" id="toc-comprimento-de-strings-com-str_length" class="nav-link" data-scroll-target="#comprimento-de-strings-com-str_length"><span class="header-section-number">10.5</span> Comprimento de <em>strings</em> com <code>str_length()</code></a></li>
  <li><a href="#lidando-com-capitalização-e-espaços-em-branco" id="toc-lidando-com-capitalização-e-espaços-em-branco" class="nav-link" data-scroll-target="#lidando-com-capitalização-e-espaços-em-branco"><span class="header-section-number">10.6</span> Lidando com capitalização e espaços em branco</a></li>
  <li><a href="#extraindo-partes-ou-subsets-de-uma-string-com-str_sub" id="toc-extraindo-partes-ou-subsets-de-uma-string-com-str_sub" class="nav-link" data-scroll-target="#extraindo-partes-ou-subsets-de-uma-string-com-str_sub"><span class="header-section-number">10.7</span> Extraindo partes ou <em>subsets</em> de uma <em>string</em> com <code>str_sub()</code></a>
  <ul class="collapse">
  <li><a href="#sec:str_sub_e_str_length" id="toc-sec:str_sub_e_str_length" class="nav-link" data-scroll-target="#sec\:str_sub_e_str_length"><span class="header-section-number">10.7.1</span> Aliando <code>str_sub()</code> com <code>str_length()</code> para extrair partes de tamanho variável</a></li>
  </ul></li>
  <li><a href="#sec:stringr_regex" id="toc-sec:stringr_regex" class="nav-link" data-scroll-target="#sec\:stringr_regex"><span class="header-section-number">10.8</span> Expressões regulares (ou <em>regex</em>) com <code>str_detect()</code></a>
  <ul class="collapse">
  <li><a href="#a-expressão-regular-mais-simples-de-todas" id="toc-a-expressão-regular-mais-simples-de-todas" class="nav-link" data-scroll-target="#a-expressão-regular-mais-simples-de-todas"><span class="header-section-number">10.8.1</span> A expressão regular mais simples de todas</a></li>
  <li><a href="#conhecendo-a-função-str_view" id="toc-conhecendo-a-função-str_view" class="nav-link" data-scroll-target="#conhecendo-a-função-str_view"><span class="header-section-number">10.8.2</span> Conhecendo a função <code>str_view()</code></a></li>
  <li><a href="#caracteres-literais-e-metacharacters" id="toc-caracteres-literais-e-metacharacters" class="nav-link" data-scroll-target="#caracteres-literais-e-metacharacters"><span class="header-section-number">10.8.3</span> Caracteres literais e <em>metacharacters</em></a></li>
  <li><a href="#sec:regex_ancoras" id="toc-sec:regex_ancoras" class="nav-link" data-scroll-target="#sec\:regex_ancoras"><span class="header-section-number">10.8.4</span> Âncoras (<em>anchors</em>)</a></li>
  <li><a href="#classes-de-caracteres-character-classes" id="toc-classes-de-caracteres-character-classes" class="nav-link" data-scroll-target="#classes-de-caracteres-character-classes"><span class="header-section-number">10.8.5</span> Classes de caracteres (<em>character classes</em>)</a></li>
  <li><a href="#representando-qualquer-caractere-com-um-ponto" id="toc-representando-qualquer-caractere-com-um-ponto" class="nav-link" data-scroll-target="#representando-qualquer-caractere-com-um-ponto"><span class="header-section-number">10.8.6</span> Representando qualquer caractere com um ponto</a></li>
  <li><a href="#criando-alternativas-alternation" id="toc-criando-alternativas-alternation" class="nav-link" data-scroll-target="#criando-alternativas-alternation"><span class="header-section-number">10.8.7</span> Criando alternativas (<em>alternation</em>)</a></li>
  <li><a href="#quantificadores-quantifiers-ou-definindo-repetições" id="toc-quantificadores-quantifiers-ou-definindo-repetições" class="nav-link" data-scroll-target="#quantificadores-quantifiers-ou-definindo-repetições"><span class="header-section-number">10.8.8</span> Quantificadores (<em>quantifiers</em>) ou definindo repetições</a></li>
  <li><a href="#determinando-os-limites-de-uma-palavra" id="toc-determinando-os-limites-de-uma-palavra" class="nav-link" data-scroll-target="#determinando-os-limites-de-uma-palavra"><span class="header-section-number">10.8.9</span> Determinando os limites de uma palavra</a></li>
  <li><a href="#agrupamentos-e-backreferencing" id="toc-agrupamentos-e-backreferencing" class="nav-link" data-scroll-target="#agrupamentos-e-backreferencing"><span class="header-section-number">10.8.10</span> Agrupamentos e <em>backreferencing</em></a></li>
  <li><a href="#mais-sobre-padrões" id="toc-mais-sobre-padrões" class="nav-link" data-scroll-target="#mais-sobre-padrões"><span class="header-section-number">10.8.11</span> Mais sobre padrões</a></li>
  </ul></li>
  <li><a href="#substituindo-partes-de-um-texto-com-str_replace" id="toc-substituindo-partes-de-um-texto-com-str_replace" class="nav-link" data-scroll-target="#substituindo-partes-de-um-texto-com-str_replace"><span class="header-section-number">10.9</span> Substituindo partes de um texto com <code>str_replace()</code></a></li>
  <li><a href="#dividindo-strings-com-str_split" id="toc-dividindo-strings-com-str_split" class="nav-link" data-scroll-target="#dividindo-strings-com-str_split"><span class="header-section-number">10.10</span> Dividindo <em>strings</em> com <code>str_split()</code></a></li>
  <li><a href="#extraindo-apenas-a-correspondência-de-sua-expressão-regular-com-str_extract" id="toc-extraindo-apenas-a-correspondência-de-sua-expressão-regular-com-str_extract" class="nav-link" data-scroll-target="#extraindo-apenas-a-correspondência-de-sua-expressão-regular-com-str_extract"><span class="header-section-number">10.11</span> Extraindo apenas a correspondência de sua expressão regular com <code>str_extract()</code></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Capítulos/10-strings.html">Ferramentas para tipos específicos de dados</a></li><li class="breadcrumb-item"><a href="../Capítulos/10-strings.html"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Manipulação e transformação de <em>strings</em> com <code>stringr</code></span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Manipulação e transformação de <em>strings</em> com <code>stringr</code></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec:stringr_capitulo" class="level2" data-number="10.1">
<h2 data-number="10.1" class="anchored" data-anchor-id="sec:stringr_capitulo"><span class="header-section-number">10.1</span> Introdução e pré-requisitos</h2>
<p>Neste capítulo, vamos aprender mais sobre operações especializadas em dados textuais (dados do tipo <code>character</code>), ou como são mais comumente denominados em programação, <em>strings</em>. Esse capítulo também oferece uma introdução a um dos principais e mais importantes tópicos em processamento de texto, as expressões regulares (<em>regular expression</em>), ou <em>regex</em> como é mais conhecida. Para aplicarmos as diversas operações expostas, vamos utilizar as funções disponíveis no pacote <code>stringr</code>. Esse pacote está incluso no <code>tidyverse</code>, logo, para ter acesso às funções apresentadas, você pode chamar pelo <code>tidyverse</code> ou pacote <code>stringr</code> diretamente, por meio do comando <code>library()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="algumas-noções-básicas" class="level2" data-number="10.2">
<h2 data-number="10.2" class="anchored" data-anchor-id="algumas-noções-básicas"><span class="header-section-number">10.2</span> Algumas noções básicas</h2>
<p>Textos ou <em>strings</em> no R, são criados ao contornarmos um determinado texto por aspas (duplas - <code>"</code>, ou simples - <code>'</code>), e cada letra, espaço, símbolo ou número que compõe esse texto, é comumente denominado de caractere. Caso você se esqueça de fechar o par de aspas que contorna o seu texto, o R vai esperar até que você complete a expressão. Ou seja, em seu console, estaria acontecendo algo parecido com o que está abaixo. Lembre-se que você pode apertar a tecla <code>Esc</code>, para abortar a operação, caso você não consiga completá-la.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> x <span class="ot">&lt;-</span> <span class="st">"Olá eu sou Pedro!</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="st">+ </span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="st">+ </span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Como as aspas são responsáveis por delimitar esse tipo de dado, para que você possa incluir esse caractere em alguma cadeia de texto, você tem duas alternativas: 1) se você está contornando o texto com aspas duplas, utilize aspas simples, ou vice-versa; 2) contornar o comportamento especial das aspas, ao posicionar uma barra inclinada a esquerda antes de cada aspa (<code>\"</code> ou <code>\'</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="st">"Olá! Esse é um texto qualquer"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Olá! Esse é um texto qualquer"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="st">"Para incluir aspas ('') em uma string"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Para incluir aspas ('') em uma string"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="st">"Será que </span><span class="sc">\"</span><span class="st">alienígenas</span><span class="sc">\"</span><span class="st"> existem de fato?"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Será que \"alienígenas\" existem de fato?"</code></pre>
</div>
</div>
<p>Além disso, textos podem incluir diversos outros caracteres especiais. Sendo os principais exemplos, os caracteres de tabulação (<code>\t</code>), e de quebra de linha (<code>\n</code>). Entretanto, uma quantidade muito grande desses caracteres especiais, podem dificultar a nossa compreensão do conteúdo presente em um texto. Logo, há vários momentos em que desejamos visualizar o texto representado em uma <em>string</em> de maneira “crua”. Para isso, podemos aplicar a função <code>writeLines()</code> sobre o texto em questão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>texto <span class="ot">&lt;-</span> <span class="st">"Receita:</span><span class="sc">\n\t\t</span><span class="st">2 ovos</span><span class="sc">\n\t\t</span><span class="st">3 copos e meio de farinha</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="sc">\t\t</span><span class="st">2 copos de achocolatado</span><span class="sc">\n\t\t</span><span class="st">1 copo de açúcar</span><span class="sc">\n\t\t</span><span class="st">Meio copo de óleo</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="sc">\t\t</span><span class="st">1 colher (de sopa) de fermento</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="sc">\t\t</span><span class="st">1 colher (de café) de bicabornato de sódio</span><span class="sc">\n\t\t</span><span class="st">..."</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(texto)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Receita:
        2 ovos
        3 copos e meio de farinha
        2 copos de achocolatado
        1 copo de açúcar
        Meio copo de óleo
        1 colher (de sopa) de fermento
        1 colher (de café) de bicabornato de sódio
        ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>texto <span class="ot">&lt;-</span> <span class="st">"Será que </span><span class="sc">\"</span><span class="st">alienígenas</span><span class="sc">\"</span><span class="st"> existem de fato?"</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(texto)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Será que "alienígenas" existem de fato?</code></pre>
</div>
</div>
<p>Outro exemplo clássico de caracteres especiais, que são muito encontrados em páginas da internet (e.g.&nbsp;dados coletados em operações de <em>web scrapping</em>), são os códigos hexadecimais ou <em>code points</em> correspondentes a uma determinada letra presente no sistema Unicode. Descrevemos brevemente na seção <a href="03-importacao.html#sec:fontes_encoding_tipografia">Um pouco sobre fontes, encoding e tipografia</a>, a importância do Unicode para a universalização dos sistemas de <em>encoding</em>, e consequentemente, para a internacionalização de conteúdo.</p>
<p>Cada caractere no sistema Unicode, é representado por um <em>unicode code point</em> <span class="citation" data-cites="haralambous2007">(<a href="#ref-haralambous2007" role="doc-biblioref">HARALAMBOUS, 2007</a>)</span>. Em resumo, um <em>code point</em> é um número inteiro que pode identificar unicamente um caractere presente no sistema Unicode. Porém, caracteres que são codificados nesse sistema, são normalmente representados pelo código hexadecimal que equivale ao seu respectivo <em>code point</em>. Logo, ao invés de um número específico, você normalmente irá encontrar em <em>strings</em>, códigos que se iniciam por <code>\u</code>, ou <code>\U</code>, ou ainda <code>U+</code>, seguidos por uma combinação específica de letras e números. Como exemplo, os códigos hexadecimais abaixo equivalem aos <em>code points</em> que formam a palavra “Arigatōgozaimashita”, ou “Muito obrigado” em japonês.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="st">"\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3057\u305f"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Um outro ponto muito importante em <em>strings</em> está no uso de barras inclinadas à esquerda. Nós já vimos na seção <a href="03-importacao.html#sec:enderecos_disco_rigido">Definindo endereços do disco rígido no R</a>, que para representarmos uma barra inclinada à esquerda em uma <em>string</em> do R, precisarmos duplicar essa barra. Logo, em <em>strings</em>, a sequência <code>\\</code> significa para o R <code>\</code>. Existem alguns comandos e caracteres especiais que não requerem essa prática, como o comando que forma um <em>Unicode code point</em> (como demonstrado acima), que sempre se inicia por uma letra “u” antecedida por uma barra inclinada à esquerda (ex: <code>\u3042</code>). Um outro exemplo são os comandos para tabulações e quebra de linha que acabamos de mostrar (<code>\t</code> e <code>\n</code>). Entretanto, essas exceções são a minoria. Portanto, tenha esse cuidado ao utilizar barras inclinadas à esquerda em suas <em>strings</em>.</p>
</section>
<section id="concatenando-ou-combinando-strings-com-paste-e-str_c" class="level2" data-number="10.3">
<h2 data-number="10.3" class="anchored" data-anchor-id="concatenando-ou-combinando-strings-com-paste-e-str_c"><span class="header-section-number">10.3</span> Concatenando ou combinando <em>strings</em> com <code>paste()</code> e <code>str_c()</code></h2>
<p>Concatenar, significa unir diferentes valores. Porém, essa união pode ocorrer de diferentes maneiras, e como ela ocorre, tende a depender das funções que você utiliza, como você as configura, e com quais tipos de estruturas você está trabalhando. Com isso, eu quero destacar, que o termo concatenar, pode se referir a muitas coisas (ou operações) diferentes. Na linguagem R, uma das principais operações de concatenação está presente na formação de vetores atômicos, mais especificamente, no uso da função <code>c()</code> (abreviação para <em>combine</em>), que introduzimos na seção de <a href="02-fundamentos.html#sec:vetores_estrutura">Vetores</a>.</p>
<p>O papel da função <code>c()</code> é criar uma sequência a partir de um conjunto de valores. Essa sequência de valores, é o que forma um vetor, e é o que estabelece uma relação de dependência ou de união entre esses valores, pois os torna parte de uma mesma estrutura. Cada um deles possuem uma ordem, ou uma posição dentro dessa sequência, mas nenhum deles é capaz de gerar essa sequência sozinho.</p>
<p>Entretanto, ao concatenarmos textos, nós geralmente estamos nos referindo a uma operação um pouco diferente. Tradicionalmente, ao concatenarmos um conjunto de textos, nós já possuímos um vetor (ou mais vetores) em nossas mãos, e desejamos unir cada elemento, ou cada texto contido nesse vetor, de alguma forma lógica. Dentre os pacotes básicos do R, a principal função que realiza esse tipo de operação, é a função <code>paste()</code>. Um detalhe importante sobre essa função, é que ela converte, por padrão, qualquer tipo de <em>input</em> que você fornecer a ela, para o tipo <code>character</code>. Logo, você pode incluir dados numéricos ou de qualquer outro tipo nos <em>input</em>’s dessa função.</p>
<p>A forma como a função <code>paste()</code> realiza essa união entre os textos, depende diretamente de como você configura os argumentos da função, <code>sep</code> e <code>collapse</code>, e de quais <em>input</em>’s você fornece à função. Se você está fornecendo um único <em>input</em> à função, é certo que você está preocupado apenas com o argumento <code>collapse</code> (em outras palavras, <code>sep</code> é irrelevante nesse caso). Em resumo, o argumento <code>collapse</code> define qual o texto que irá separar os diferentes elementos do <em>input</em> que você forneceu a função. Em outras palavras, se o <em>input</em> que fornecemos é, por exemplo, um vetor de textos, ao definirmos o argumento <code>collapse</code>, estamos pedindo à <code>paste()</code> que junte todos os diferentes elementos do vetor, dentro de um único texto, separando-os pelo texto que você definiu no argumento <code>collapse</code>.</p>
<p>Por exemplo, se eu possuo o vetor <code>vec</code> abaixo, e utilizo a função <code>paste()</code> sobre ele, veja o que ocorre ao definirmos o argumento <code>collapse</code>. Perceba no exemplo abaixo, que todos os elementos do vetor <code>vec</code>, foram unidos dentro de um mesmo texto, onde cada um desses elementos são separados pelo texto <code>" : "</code> que definimos no argumento <code>collapse</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>conc_vec <span class="ot">&lt;-</span> <span class="fu">paste</span>(vec, <span class="at">collapse =</span> <span class="st">" : "</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>conc_vec</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "a : b : c : d : e"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="do">## --------------------------</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Um outro exemplo:</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>nomes <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Fabrício"</span>, <span class="st">"Eduardo"</span>, <span class="st">"Mônica"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>mensagem <span class="ot">&lt;-</span> <span class="fu">paste</span>(nomes, <span class="at">collapse =</span> <span class="st">" e "</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>mensagem</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Ana e Fabrício e Eduardo e Mônica"</code></pre>
</div>
</div>
<p>Portanto, o texto que você define em <code>collapse</code>, será o texto que vai separar cada um dos elementos do vetor que você fornece como <em>input</em> à função <code>paste()</code>. Por padrão, o argumento <code>collapse</code> é setado para nulo (<code>NULL</code>). Isso significa, que se você não definir algum texto para o argumento <code>collapse</code>, nada acontece ao aplicarmos a função <code>paste()</code> sobre o vetor. Como o argumento <code>sep</code> é irrelevante para um único <em>input</em>, se você não está interessado nesta operação que ocorre ao definirmos <code>collapse</code>, a função <code>paste()</code> não é o que você está procurando.</p>
<p>Por outro lado, se você está fornecendo dois ou mais <em>inputs</em> à função <code>paste()</code>, é provável que você esteja interessado em definir apenas o argumento <code>sep</code>, apesar de que o argumento <code>collapse</code> pode também ser útil para o seu caso. Ao fornecermos dois ou mais vetores como <em>inputs</em>, a função <code>paste()</code>, por padrão, tenta unir os elementos desses vetores, de forma a produzir um novo vetor de texto. Por exemplo, se eu forneço dois vetores à função <code>paste()</code>, como os vetores <code>vec</code> e <code>id</code> abaixo, o primeiro elemento do vetor resultante de <code>paste()</code> vai possuir os textos presentes no primeiro elemento de ambos os vetores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>id <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>conc_vec <span class="ot">&lt;-</span> <span class="fu">paste</span>(id, vec)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>conc_vec</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1 a" "2 b" "3 c" "4 d" "5 e"</code></pre>
</div>
</div>
<p>O argumento <code>sep</code> é responsável por definir o texto que vai separar os valores de diferentes <em>input</em>’s da função <code>paste()</code>. Perceba no exemplo acima, os valores dos vetores <code>id</code> e <code>vec</code>, estão todos separados por um espaço em branco. Isso significa, que por padrão, o argumento <code>sep</code> é configurado como um espaço em branco (<code>" "</code>), e, portanto, você não precisa definir o argumento <code>sep</code>, caso você deseja separar esses valores por um espaço. Mas se há interesse em um texto diferente, para separar esses valores, você deve defini-lo através do argumento <code>sep</code>. Por exemplo, você talvez deseja que não haja espaço algum entre esses valores, como exemplo abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>id <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"d"</span>, <span class="st">"e"</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>conc_vec <span class="ot">&lt;-</span> <span class="fu">paste</span>(id, vec, <span class="at">sep =</span> <span class="st">""</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>conc_vec</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1a" "2b" "3c" "4d" "5e"</code></pre>
</div>
</div>
<p>Assim sendo, em uma representação visual, podemos identificar os papéis dos argumentos <code>sep</code> e <code>collapse</code> da forma apresentada na <a href="#fig-sep-collapse" class="quarto-xref">Figura&nbsp;<span>10.1</span></a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-sep-collapse" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sep-collapse-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/sep_collapse.png" class="img-fluid figure-img" style="width:100.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-sep-collapse-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;10.1: Resumo dos papéis desempenhados pelos argumentos <code>sep</code> e <code>collapse</code> em <code>paste()</code>
</figcaption>
</figure>
</div>
</div>
</div>
<p>Porém, na maioria das aplicações práticas dessa função, pelo menos um dos <em>input</em>’s fornecidos será constante. Por exemplo, uma situação muito comum de uso dessa função, é a construção de caminhos (ou <em>paths</em>) para diferentes arquivos. Essa é exatamente a aplicação que utilizamos na seção <a href="18-purrr.html#sec:demanda_dist_ICMS">Um estudo de caso: uma demanda real sobre a distribuição de ICMS</a>.</p>
<p>Nessa seção, em uma das primeiras etapas descritas, precisamos ler ao todo, 12 planilhas diferentes, e como descrevemos no capítulo 4, para importarmos qualquer arquivo, nós precisamos fornecer o caminho até esse arquivo para o R. Com isso, teríamos a tarefa tediosa de construirmos 12 caminhos diferentes (imagine se fossem 36, ou 320 planilhas diferentes a serem lidas). Porém, como todas essas planilhas se encontram dentro do mesmo diretório de meu computador, eu me aproveito dessa regularidade, para fabricar esses caminhos de uma maneira prática, através da função <code>paste()</code>.</p>
<p>Inicialmente, temos apenas os nomes dessas planilhas contidos no objeto <code>planilhas</code> (que está replicado abaixo).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>planilhas <span class="ot">&lt;-</span> <span class="fu">list.files</span>(<span class="st">"./planilhas"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>planilhas</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>[1]  "Abril_2019.xlsx"     "Agosto_2019.xlsx"
[3]  "Dezembro_2019.xlsx"  "Fevereiro_2019.xlsx"
[5]  "Janeiro_2019.xlsx"   "Julho_2019.xlsx"
[7]  "Junho_2019.xlsx"     "Maio_2019.xlsx"     
[9]  "Marco_2019.xlsx"     "Novembro_2019.xlsx"
[11] "Outubro_2019.xlsx"   "Setembro_2019.xlsx" </code></pre>
<p>Para criarmos o endereço até cada uma dessas planilhas, precisamos juntar o caminho até o diretório em que elas se encontram (<code>"planilhas/"</code>), ao seus nomes. Com isso, podemos utilizar a função <code>paste()</code> da seguinte maneira. Perceba que dois <em>input</em>’s foram fornecidos a função: o primeiro, conciste apenas no texto <code>"planilhas/"</code>; o segundo, são os nomes das planilhas contidos no objeto <code>planilhas</code>. Além disso, repare que pelo fato de que o texto <code>"planilhas/"</code> ser “constante”, <code>paste()</code> acaba replicando-o para todos os 12 nomes presentes no objeto <code>planilhas</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>caminhos <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"planilhas/"</span>, planilhas, <span class="at">sep =</span> <span class="st">""</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>caminhos</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "planilhas/Abril_2019.xlsx"     "planilhas/Agosto_2019.xlsx"   
 [3] "planilhas/Dezembro_2019.xlsx"  "planilhas/Fevereiro_2019.xlsx"
 [5] "planilhas/Janeiro_2019.xlsx"   "planilhas/Julho_2019.xlsx"    
 [7] "planilhas/Junho_2019.xlsx"     "planilhas/Maio_2019.xlsx"     
 [9] "planilhas/Marco_2019.xlsx"     "planilhas/Novembro_2019.xlsx" 
[11] "planilhas/Outubro_2019.xlsx"   "planilhas/Setembro_2019.xlsx" </code></pre>
</div>
</div>
<p>Você talvez tenha percebido, especialmente durante o capítulo 4, que temos uma variante da função <code>paste()</code>, chamada <code>paste0()</code>. Essa irmã, nada mais é do que um atalho para a função <code>paste()</code>, que utiliza por padrão, a configuração <code>sep = ""</code>. Ou seja, em todas as ocasiões em que você estiver concatenando textos de diferentes <em>input</em>’s com a função <code>paste()</code>, e deseja utilizar nenhum espaço como separador entre os valores de cada <em>input</em>, você pode rapidamente executar essa ação por meio da função <code>paste0()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>caminhos <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"planilhas/"</span>, planilhas)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>caminhos</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "planilhas/Abril_2019.xlsx"     "planilhas/Agosto_2019.xlsx"   
 [3] "planilhas/Dezembro_2019.xlsx"  "planilhas/Fevereiro_2019.xlsx"
 [5] "planilhas/Janeiro_2019.xlsx"   "planilhas/Julho_2019.xlsx"    
 [7] "planilhas/Junho_2019.xlsx"     "planilhas/Maio_2019.xlsx"     
 [9] "planilhas/Marco_2019.xlsx"     "planilhas/Novembro_2019.xlsx" 
[11] "planilhas/Outubro_2019.xlsx"   "planilhas/Setembro_2019.xlsx" </code></pre>
</div>
</div>
<section id="a-função-str_c-como-uma-alternativa-para-concatenação-de-strings" class="level3" data-number="10.3.1">
<h3 data-number="10.3.1" class="anchored" data-anchor-id="a-função-str_c-como-uma-alternativa-para-concatenação-de-strings"><span class="header-section-number">10.3.1</span> A função <code>str_c()</code> como uma alternativa para concatenação de <em>strings</em></h3>
<p>Por ser uma operação muito comum e útil, o pacote <code>stringr</code> nos oferece a função <code>str_c()</code>, como uma alternativa à função <code>paste()</code>. Suas diferenças se restringem a dois pontos. Primeiro, a função <code>str_c()</code> foi escrita em C++, e consegue hoje, atingir uma maior eficiência se comparada a função <code>paste()</code>, como demonstrado abaixo. Logo, <code>str_c()</code> pode oferecer uma vantagem considerável, caso você esteja trabalhando com um grande conjunto de textos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(stringr)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>texto <span class="ot">&lt;-</span> <span class="fu">sample</span>(letters, <span class="at">size =</span> <span class="fl">1e6</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="fu">microbenchmark</span>(</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">paste</span>(texto, <span class="at">collapse =</span> <span class="st">""</span>),</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_c</span>(texto, <span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>Unit: milliseconds
                        expr      min       lq      mean
 paste(texto, collapse = "") 104.7202 107.8384 124.43956
 str_c(texto, collapse = "")  26.3803  26.9155  28.33062
   median        uq      max neval
 115.8264 129.90345 277.5362   100
  27.1933  29.02705  33.3686   100</code></pre>
<p>Segundo, temos também uma diferença importante sobre as configurações nativas utilizadas por essas funções. Pois a função <code>str_c()</code> adota <code>sep = ""</code> como a sua configuração padrão para o argumento <code>sep</code> (se igualando assim, à função <code>paste0()</code>), ao invés de <code>sep = " "</code>, que é o padrão adotado por <code>paste()</code>. Veja um exemplo abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_c</span>(<span class="st">"Dia"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">7</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Dia1" "Dia2" "Dia3" "Dia4" "Dia5" "Dia6" "Dia7"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_c</span>(<span class="st">"Dia"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">7</span>, <span class="at">sep =</span> <span class="st">" "</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Dia 1" "Dia 2" "Dia 3" "Dia 4" "Dia 5" "Dia 6" "Dia 7"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_c</span>(<span class="st">"Dia"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">7</span>, <span class="at">collapse =</span> <span class="st">"-"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Dia1-Dia2-Dia3-Dia4-Dia5-Dia6-Dia7"</code></pre>
</div>
</div>
<p>Apesar dessas diferenças, a função <code>str_c()</code> se comporta exatamente da mesma maneira que a função <code>paste()</code>. Por isso, pode ser interessante que você adote essa função como o seu padrão para concatenação de textos, especialmente levando-se em conta, a sua maior eficiência.</p>
</section>
</section>
<section id="vantagens-do-pacote-stringr" class="level2" data-number="10.4">
<h2 data-number="10.4" class="anchored" data-anchor-id="vantagens-do-pacote-stringr"><span class="header-section-number">10.4</span> Vantagens do pacote <code>stringr</code></h2>
<p>Os pacotes básicos da linguagem R oferecem algumas ferramentas para trabalharmos com <em>strings</em>, como a função <code>paste()</code> e a família <code>grep()</code>. Porém, essas ferramentas são em grande parte, inconsistentes em seus nomes e formas e, por isso, são mais difíceis de se lembrar. Mesmo com essa consideração, eu decidi mostrar a função <code>paste()</code> na seção anterior, pelo fato de que ela continua sendo uma função extremamente popular, e que você irá encontrar em todo lugar.</p>
<p>De qualquer forma, a partir de agora, vamos focar apenas nas funções do pacote <code>stringr</code>. As funções desse pacote, são em geral, mais rápidas do que as funções ofertadas pelos pacotes básicos. Além disso, os nomes de todas as funções do pacote <code>stringr</code> começam pela sequência <code>str_*()</code>, o que facilita muito a sua memorização de cada função.</p>
</section>
<section id="comprimento-de-strings-com-str_length" class="level2" data-number="10.5">
<h2 data-number="10.5" class="anchored" data-anchor-id="comprimento-de-strings-com-str_length"><span class="header-section-number">10.5</span> Comprimento de <em>strings</em> com <code>str_length()</code></h2>
<p>A função <code>str_length()</code> lhe permite contabilizar o número de caracteres presentes em uma <em>string</em>. Essa função é extremamente útil, quando desejamos aplicar operações que se baseiam em uma determinada posição de uma <em>string</em>, como extrair uma seção específica dessa <em>string</em>. Perceba abaixo, que ao se deparar com valores <code>NA</code>, a função nos retorna um valor <code>NA</code> correspondente. Repare também, pelo resultado do quarto elemento, referente a palavra “Partindo”, que espaços em branco também são contabilizados como caracteres, portanto, fique atento a este detalhe.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Fui ao Paraná, e encontrei o Varadá"</span>,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Abril"</span>, </span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"!"</span>,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Partindo "</span>,</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="cn">NA</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="fu">str_length</span>(vec)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 35  5  1  9 NA</code></pre>
</div>
</div>
</section>
<section id="lidando-com-capitalização-e-espaços-em-branco" class="level2" data-number="10.6">
<h2 data-number="10.6" class="anchored" data-anchor-id="lidando-com-capitalização-e-espaços-em-branco"><span class="header-section-number">10.6</span> Lidando com capitalização e espaços em branco</h2>
<p>Diversas empresas que utilizam formulários, ou outros sistemas de registro, precisam estar constantemente corrigindo <em>input</em>’s fornecidos por seus usuários. Talvez, os erros mais comumente gerados, sejam no uso da capitalização e de espaços em branco. Por exemplo, ao preenchermos formulários, é muito comum que: 1) esqueçamos a tecla <code>Caps Lock</code> ligada; 2) ou simplesmente ignoramos o uso de capitalização por simplesmente estarmos com pressa para finalizar o formulário; 3) acrescentar espaços desnecessários ao final ou no meio do <em>input</em>.</p>
<p>Como exemplo, suponha que você possua a tabela <code>usuarios</code>. Repare que os valores da coluna <code>cidade</code>, variam bastante quanto ao uso da capitalização. Repare também, que em alguns valores na coluna <code>nome</code>, temos para além de problemas com a capitalização, espaços em branco desnecessários, que as vezes se encontram a direita, ou a esquerda, ou em ambos os lados do nome.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">nome =</span> <span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">" Eduardo"</span>, <span class="st">" Cláudio   "</span>, <span class="st">"VerÔNiCA "</span>,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>           <span class="st">"  hugo    "</span>, <span class="st">"JULIANA"</span>, <span class="st">"  Vitor de paula   "</span>),</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cidade =</span> <span class="fu">c</span>(<span class="st">"BELÉM"</span>, <span class="st">"goiânia"</span>, <span class="st">"são paulo"</span>, <span class="st">"São paulo"</span>, <span class="st">"SÃO pAULO"</span>,</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>             <span class="st">"rIO DE janeiro"</span>, <span class="st">"rio de janeiro"</span>),</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">profissao =</span> <span class="fu">c</span>(<span class="st">"Bióloga"</span>, <span class="st">"Biólogo"</span>, <span class="st">"Químico"</span>, <span class="st">"Socióloga"</span>,</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Administrador"</span>, <span class="st">"Administradora"</span>, <span class="st">"Economista"</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>usuarios</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 3
  nome          cidade    profissao    
  &lt;chr&gt;         &lt;chr&gt;     &lt;chr&gt;        
1 "Ana"         BELÉM     Bióloga      
2 " Eduardo"    goiânia   Biólogo      
3 " Cláudio   " são paulo Químico      
4 "VerÔNiCA "   São paulo Socióloga    
5 "  hugo    "  SÃO pAULO Administrador
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>No Excel, você normalmente utilizaria a função <code>ARRUMAR()</code> para resolver os excessos de espaços, e as funções <code>MAIÚSCULA()</code>, <code>MINÚSCULA()</code> e <code>PRI.MAIÚSCULA()</code> para alterar a capitalização de todas as letras de cada nome. Sendo as funções <code>str_trim()</code>, <code>str_to_upper()</code>, <code>str_to_lower()</code> e <code>str_to_title()</code>, os seus equivalentes no pacote <code>stringr</code>, respectivamente.</p>
<p>Como os próprios nomes das funções <code>str_to_upper()</code> e <code>str_to_lower()</code> dão a entender, elas convertem todos as letras contidas em um vetor do tipo <code>character</code>, para letras maiúsculas (<em>upper</em>) e minúsculas (<em>lower</em>). Por exemplo, ao aplicarmos essas funções sobre a coluna <code>cidade</code>, temos o seguinte resultado:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">cidade =</span> <span class="fu">str_to_upper</span>(cidade))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 3
  nome          cidade    profissao    
  &lt;chr&gt;         &lt;chr&gt;     &lt;chr&gt;        
1 "Ana"         BELÉM     Bióloga      
2 " Eduardo"    GOIÂNIA   Biólogo      
3 " Cláudio   " SÃO PAULO Químico      
4 "VerÔNiCA "   SÃO PAULO Socióloga    
5 "  hugo    "  SÃO PAULO Administrador
# ℹ 2 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">cidade =</span> <span class="fu">str_to_lower</span>(cidade))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 3
  nome          cidade    profissao    
  &lt;chr&gt;         &lt;chr&gt;     &lt;chr&gt;        
1 "Ana"         belém     Bióloga      
2 " Eduardo"    goiânia   Biólogo      
3 " Cláudio   " são paulo Químico      
4 "VerÔNiCA "   são paulo Socióloga    
5 "  hugo    "  são paulo Administrador
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>Por outro lado, a função <code>str_to_title()</code> representa a alternativa do meio, ao converter a primeira letra de cada palavra, para maiúsculo, e as letras restantes, para minúsculo, como demonstrado abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">cidade =</span> <span class="fu">str_to_title</span>(cidade))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 3
  nome          cidade    profissao    
  &lt;chr&gt;         &lt;chr&gt;     &lt;chr&gt;        
1 "Ana"         Belém     Bióloga      
2 " Eduardo"    Goiânia   Biólogo      
3 " Cláudio   " São Paulo Químico      
4 "VerÔNiCA "   São Paulo Socióloga    
5 "  hugo    "  São Paulo Administrador
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>Quanto ao excedente de espaços na coluna <code>nome</code>, podemos aplicar a função <code>str_trim()</code>. Por padrão, essa função retira qualquer espaço remanescente em ambos os lados de sua <em>string</em>. Mas caso seja de seu desejo, você pode especificar um lado específico para retirar espaços, por meio do argumento <code>side</code>, que aceita os valores <code>"both"</code>, <code>"left"</code> ou <code>"right"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="ot">&lt;-</span> usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">nome =</span> <span class="fu">str_trim</span>(nome))</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>usuarios</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 3
  nome     cidade    profissao    
  &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;        
1 Ana      BELÉM     Bióloga      
2 Eduardo  goiânia   Biólogo      
3 Cláudio  são paulo Químico      
4 VerÔNiCA São paulo Socióloga    
5 hugo     SÃO pAULO Administrador
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>Vale destacar também, que <code>str_trim()</code> é capaz apenas de remover excessos de espaços que se encontram ao redor de seu texto. Logo, a forma mais direta de resolvermos esse tipo de excesso, seria utilizarmos o método mais “abrangente” da função <code>str_trim()</code>, aplicado pela função <code>str_squish()</code>. Além de remover os espaços ao redor da palavra, a função <code>str_squish()</code> também é capaz de remover espaços repetidos que se encontram entre palavras. Veja abaixo, o exemplo do texto <code>"  São Carlos de   Santana   "</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_trim</span>(<span class="st">"  São Carlos de   Santana   "</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "São Carlos de   Santana"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_squish</span>(<span class="st">"  São Carlos de   Santana   "</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "São Carlos de Santana"</code></pre>
</div>
</div>
</section>
<section id="extraindo-partes-ou-subsets-de-uma-string-com-str_sub" class="level2" data-number="10.7">
<h2 data-number="10.7" class="anchored" data-anchor-id="extraindo-partes-ou-subsets-de-uma-string-com-str_sub"><span class="header-section-number">10.7</span> Extraindo partes ou <em>subsets</em> de uma <em>string</em> com <code>str_sub()</code></h2>
<p>Para extrairmos partes de uma <em>string</em>, podemos utilizar a função <code>str_sub()</code>, que se baseia na posição dos caracteres que delimitam o intervalo que você deseja capturar. Ou seja, nessa função, precisamos definir as posições dos caracteres que iniciam e terminam o intervalo que estamos extraindo. Como exemplo, eu posso extrair do primeiro ao quarto caractere de cada texto presente na coluna <code>nome</code>, da seguinte maneira:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">parte =</span> <span class="fu">str_sub</span>(nome, <span class="at">start =</span> <span class="dv">1</span>, <span class="at">end =</span> <span class="dv">4</span>))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 4
  nome     cidade    profissao     parte
  &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;         &lt;chr&gt;
1 Ana      BELÉM     Bióloga       Ana  
2 Eduardo  goiânia   Biólogo       Edua 
3 Cláudio  são paulo Químico       Cláu 
4 VerÔNiCA São paulo Socióloga     VerÔ 
5 hugo     SÃO pAULO Administrador hugo 
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>De forma semelhante, podemos extrair do terceiro ao quinto caractere dessa mesma coluna, de acordo com o seguinte comando:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>usuarios <span class="sc">%&gt;%</span> </span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">parte =</span> <span class="fu">str_sub</span>(nome, <span class="at">start =</span> <span class="dv">3</span>, <span class="at">end =</span> <span class="dv">5</span>))</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7 × 4
  nome     cidade    profissao     parte
  &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;         &lt;chr&gt;
1 Ana      BELÉM     Bióloga       a    
2 Eduardo  goiânia   Biólogo       uar  
3 Cláudio  são paulo Químico       áud  
4 VerÔNiCA São paulo Socióloga     rÔN  
5 hugo     SÃO pAULO Administrador go   
# ℹ 2 more rows</code></pre>
</div>
</div>
<p>Além desses pontos, vale esclarecer que os textos inclusos em seu vetor, não precisam obrigatoriamente se encaixar no intervalo de caracteres que você delimitou. Por exemplo, veja abaixo que eu forneci um vetor contendo dois nomes (Ana e Eduardo), um possui 3 caracteres, enquanto o outro, possui 7. Logo, ao pedir à <code>str_sub()</code>, que retire do primeiro ao sexto caractere de cada texto contido no vetor, a função vai tentar extrair o máximo de caracteres possíveis que se encaixam nesse intervalo. Mesmo que algum desses textos não encaixe por completo nesse intervalo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_sub</span>(<span class="fu">c</span>(<span class="st">"Ana"</span>, <span class="st">"Eduardo"</span>), <span class="at">start =</span> <span class="dv">1</span>, <span class="at">end =</span> <span class="dv">6</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Ana"    "Eduard"</code></pre>
</div>
</div>
<section id="sec:str_sub_e_str_length" class="level3" data-number="10.7.1">
<h3 data-number="10.7.1" class="anchored" data-anchor-id="sec:str_sub_e_str_length"><span class="header-section-number">10.7.1</span> Aliando <code>str_sub()</code> com <code>str_length()</code> para extrair partes de tamanho variável</h3>
<p>Na seção <a href="18-purrr.html#sec:demanda_dist_ICMS">Um estudo de caso: uma demanda real sobre a distribuição de ICMS</a> oferecemos um caso de uso das funções <code>str_sub()</code> e <code>str_length</code>. Nessa seção, temos um sistema que coleta o nome de cada planilha que importamos para o R. Por que precisamos dessa informação? Porque o nome de cada planilha especifica o mês e o ano a que os seus dados se referem. Logo, os dados presentes na planilha <code>Abril_2019.xlsx</code> diziam respeito ao mês de abril do ano de 2019.</p>
<p>Portanto, ao final da coleta desses nomes, inserimos esses nomes em uma coluna de nosso <code>data.frame</code>, tendo como resultado algo parecido com a coluna <code>origem</code>, que se encontra na tabela <code>periodo</code>, e que pode ser recriada através dos comandos abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>meses <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Janeiro"</span>, <span class="st">"Fevereiro"</span>, <span class="st">"Março"</span>, <span class="st">"Abril"</span>,</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Maio"</span>, <span class="st">"Junho"</span>, <span class="st">"Julho"</span>, <span class="st">"Agosto"</span>,</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Setembro"</span>, <span class="st">"Outubro"</span>, <span class="st">"Novembro"</span>, <span class="st">"Dezembro"</span>)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>meses <span class="ot">&lt;-</span> <span class="fu">rep</span>(meses, <span class="at">times =</span> <span class="dv">6</span>)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>anos <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">2015</span><span class="sc">:</span><span class="dv">2020</span>, <span class="at">each =</span> <span class="dv">12</span>)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>periodo <span class="ot">&lt;-</span> <span class="fu">tibble</span>(</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">origem =</span> <span class="fu">str_c</span>(<span class="fu">str_c</span>(meses, anos, <span class="at">sep =</span> <span class="st">"_"</span>), <span class="st">".xslx"</span>)</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>periodo</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 72 × 1
  origem             
  &lt;chr&gt;              
1 Janeiro_2015.xslx  
2 Fevereiro_2015.xslx
3 Março_2015.xslx    
4 Abril_2015.xslx    
5 Maio_2015.xslx     
# ℹ 67 more rows</code></pre>
</div>
</div>
<p>Com essa informação, podemos facilmente rastrear a origem de cada linha de nossa tabela. Entretanto, mesmo com essa informação, ainda não somos capazes de ordenar a tabela de maneira útil. Pois da forma como as informações são apresentadas na coluna <code>origem</code>, uma ordenação alfabética seria empregada sobre a coluna. Logo, valores como <code>Abril_2018.xlsx</code> e <code>Abril_2017.xlsx</code>, viriam a aparecer antes de valores como <code>Março_2019.xlsx</code>.</p>
<p>Por isso, ainda temos a necessidade de extrair o mês e o ano desses nomes, e em seguida, alocar essas informações em colunas separadas. Com esse objetivo, utilizamos a função <code>str_sub()</code> para extrairmos a parte, ou a seção de cada nome, que corresponde ao mês que ele se refere. Porém, como você pode ver acima, o número de caracteres presentes em cada mês, ou em cada nome, varia de maneira drástica.</p>
<p>Em momentos como esse, você pode tentar identificar se a parte final ou a parte inicial dos textos inclusos em sua coluna, são de alguma maneira, constantes. Ou seja, mesmo que o número de caracteres varie muito ao longo da coluna, talvez exista uma parte específica desses textos que sempre possui a mesma <strong>quantidade de caracteres</strong>.</p>
<p>No caso da coluna <code>origem</code>, temos três partes que são sempre constantes, que são a parte dos anos (mesmo que os anos variem, eles sempre são formados por 4 números, ou 4 caracteres), a parte da extensão do arquivo (<code>.xlsx</code>), e o <em>underscore</em> (<code>_</code>), que sempre separa as duas partes anteriores do mês em cada nome. Somando os caracteres dessas três partes, temos sempre 10 caracteres ao final do nome do arquivo, ao qual podemos eliminar para chegarmos à seção do texto que contém o nome do mês. Com isso, podemos utilizar a função <code>str_length()</code> para calcular o número total de caracteres de cada texto, e subtrair 10 desse valor, para chegarmos ao caractere que delimita o fim do mês em cada texto.</p>
<p>Podemos empregar a mesma linha de raciocínio, para chegarmos aos limites do intervalo que contém o ano em cada texto. Contudo, tanto o limite inicial quanto o limite final desse intervalo, variam. Logo, temos que utilizar o resultado de <code>str_length()</code> para descobrirmos os dois limites dessa seção. Como estamos empregando os valores produzidos por <code>str_length()</code> em três locais diferentes, eu guardo o resultado dessa função em uma coluna denominada <code>num</code>, para não ter o trabalho de digitar repetidamente a função <code>str_length()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>periodo <span class="sc">%&gt;%</span> </span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">num =</span> <span class="fu">str_length</span>(origem),</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">mes =</span> <span class="fu">str_sub</span>(origem, <span class="at">start =</span> <span class="dv">1</span>, <span class="at">end =</span> num <span class="sc">-</span> <span class="dv">10</span>),</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">ano =</span> <span class="fu">str_sub</span>(origem, <span class="at">start =</span> num <span class="sc">-</span> <span class="dv">8</span>, <span class="at">end =</span> num <span class="sc">-</span> <span class="dv">5</span>) <span class="sc">%&gt;%</span> <span class="fu">as.integer</span>()</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 72 × 4
  origem                num mes         ano
  &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;     &lt;int&gt;
1 Janeiro_2015.xslx      17 Janeiro    2015
2 Fevereiro_2015.xslx    19 Fevereiro  2015
3 Março_2015.xslx        15 Março      2015
4 Abril_2015.xslx        15 Abril      2015
5 Maio_2015.xslx         14 Maio       2015
# ℹ 67 more rows</code></pre>
</div>
</div>
</section>
</section>
<section id="sec:stringr_regex" class="level2" data-number="10.8">
<h2 data-number="10.8" class="anchored" data-anchor-id="sec:stringr_regex"><span class="header-section-number">10.8</span> Expressões regulares (ou <em>regex</em>) com <code>str_detect()</code></h2>
<p>Expressões regulares (<em>regular expressions</em>), ou simplesmente <em>regex</em>, são uma ferramenta extremamente poderosa para processamento de texto. Por essa característica, praticamente toda linguagem de programação possui em algum nível, uma implementação dessa funcionalidade. Você talvez não saiba ainda, mas expressões regulares estão em todo lugar. Como exemplo, quando você pesquisa por uma palavra em um PDF, você está aplicando uma expressão regular ao longo do arquivo.</p>
<p>Em síntese, expressões regulares são como uma mini linguagem que lhe permite descrever de maneira concisa, um pedaço de texto <span class="citation" data-cites="friedl2006">(<a href="#ref-friedl2006" role="doc-biblioref">FRIEDL, 2006</a>)</span>. Para utilizar uma expressão regular, você precisa utilizar uma função que possa aplicar esse tipo de mecanismo. Nos pacotes básicos do R, essa funcionalidade está disponível através das funções da família <code>grep()</code> (sendo <code>grep()</code>, <code>grepl()</code> e <code>gsub()</code>, as principais funções dessa família).</p>
<p>Por outro lado, o pacote <code>stringr</code> oferece uma família um pouco maior de funções que são capazes de aplicar tal mecanismo. Sendo as funções <code>str_which()</code>, <code>str_detect()</code>, <code>str_replace()</code> e <code>str_split()</code>, as principais representantes dessa família.</p>
<p>Em grande parte desse capítulo, estaremos utilizando a função <code>str_detect()</code> como a nossa ponte de acesso ao mundo das expressões regulares. Assim como todas as funções <code>str_*()</code> que citamos no parágrafo anterior, a função <code>str_detect()</code> aceita um vetor contendo os textos a serem pesquisados como primeiro argumento (<code>string</code>), e uma expressão regular como seu segundo argumento (<code>pattern</code>).</p>
<p>A função <code>str_which()</code> é praticamente idêntica à <code>str_detect()</code>. Pois ambas as funções vão pesquisar pelos textos que são descritos pela expressão regular que você forneceu, e ambas as funções vão gerar um vetor contendo índices, que definem quais foram os textos encontrados. Entretanto, as funções se divergem no tipo de resultado gerado. A função <code>str_which()</code> nos retorna um vetor contendo índices numéricos. Em contrapartida, a função <code>str_detect()</code> gera um vetor de valores lógicos. Portanto, você pode utilizar o resultado de ambas as funções dentro da função de <em>subsetting</em> (<code>[</code>) para filtrar os textos encontrados, sendo a única diferença, o tipo de índice empregado no filtro.</p>
<section id="a-expressão-regular-mais-simples-de-todas" class="level3" data-number="10.8.1">
<h3 data-number="10.8.1" class="anchored" data-anchor-id="a-expressão-regular-mais-simples-de-todas"><span class="header-section-number">10.8.1</span> A expressão regular mais simples de todas</h3>
<p>A maneira mais simples de utilizarmos uma expressão regular, seria pesquisarmos por uma sequência específica de letras. Por exemplo, suponha que eu possua o conjunto de palavras presentes em <code>vec</code>, e desejasse encontrar a palavra “emissão”.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"permissão"</span>, <span class="st">"demissão"</span>, <span class="st">"emissão"</span>, <span class="st">"penitência"</span>,</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"jurisdição"</span>, <span class="st">"ordenação"</span>, <span class="st">"concluio"</span>, <span class="st">"vantagem"</span>,</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"natação"</span>, <span class="st">"satisfação"</span>, <span class="st">"conclusão"</span>, <span class="st">"ilusão"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Com o conhecimento que você já possui, você provavelmente tentaria algo como o comando abaixo para encontrar essa palavra.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>vec[vec <span class="sc">==</span> <span class="st">"emissão"</span>]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"</code></pre>
</div>
</div>
<p>Porém, você também poderia encontrar essa palavra inclusa no vetor <code>vec</code>, ao fornecer uma expressão regular que seja capaz de descrever o texto “emissão”. Em seu primeiro instinto, você provavelmente aplicaria o simples texto <code>"emissão"</code>, todavia, como vemos abaixo, esse não é exatamente o resultado que desejamos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"emissão"</span>)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "demissão" "emissão" </code></pre>
</div>
</div>
<p>O erro acima, está no fato de que estamos interpretando a <strong>expressão regular</strong> <code>"emissão"</code>, como a palavra “emissão”. Você rapidamente irá descobrir, que expressões regulares não possuem qualquer noção do que é uma palavra, muito menos de onde uma começa ou termina. Ou seja, quando estiver utilizando expressões regulares, a menos que você defina explicitamente os limites físicos da pesquisa, o mecanismo estará procurando por uma sequência específica de caracteres, independentemente do local em que essa sequência seja detectada.</p>
<p>Por isso, é importante que você comece a interpretar qualquer expressão regular, como uma descrição de uma sequência específica de caracteres, ao invés de uma palavra. Logo, quando fornecemos o texto <code>"emissão"</code> à <code>str_detect()</code> acima, estamos na verdade, buscando qualquer texto que contenha os caracteres “e-m-i-s-s-ã-o”, precisamente nessa ordem. Com isso, a palavra “demissão” foi incluída no resultado acima, pelo fato de possuir tal sequência de caracteres, mesmo que essa sequência esteja acompanhada por um “d”, o qual não faz parte da expressão regular definida.</p>
<p>Como um outro exemplo, suponha que eu utilize a expressão <code>"is"</code>. Lembre-se que nós não estamos procurando pela palavra <em>is</em>, mas sim, por qualquer texto que contenha um “i” imediatamente seguido por um “s”. Marcando de negrito, apenas as partes dos textos abaixo, que foram de fato encontradas pela expressão <code>"is"</code>, temos: sat<strong>is</strong>fação, dem<strong>is</strong>são, perm<strong>is</strong>são, em<strong>is</strong>são, jur<strong>is</strong>dição.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"is"</span>)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "permissão"  "demissão"   "emissão"    "jurisdição" "satisfação"</code></pre>
</div>
</div>
<p>Porém, a partir do momento em que acrescento um segundo “s” à expressão, as palavras “jurisdição” e “satisfação” não mais se encaixam na descrição fornecida pela expressão. Pois nenhuma dessas duas palavras possuem, <strong>em algum lugar</strong>, um “i” imediatamente seguido por duas letras “s”. Com isso, temos que as partes localizadas pela expressão são: perm<strong>iss</strong>ão, dem<strong>iss</strong>ão, em<strong>iss</strong>ão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"iss"</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "permissão" "demissão"  "emissão"  </code></pre>
</div>
</div>
<p>Apenas para que os pontos abordados fiquem claros, a <a href="#fig-regex-simples" class="quarto-xref">Figura&nbsp;<span>10.2</span></a> lhe permite visualizar as correspondências (marcadas em cinza) encontradas por cada uma das expressões regulares mostradas anteriormente.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-regex-simples" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-regex-simples-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/regex_simples.png" class="img-fluid figure-img" style="width:90.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-regex-simples-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;10.2: Correspondências encontradas por cada expressão regular, além de suas respectivas descrições.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="conhecendo-a-função-str_view" class="level3" data-number="10.8.2">
<h3 data-number="10.8.2" class="anchored" data-anchor-id="conhecendo-a-função-str_view"><span class="header-section-number">10.8.2</span> Conhecendo a função <code>str_view()</code></h3>
<p>Nas próximas seções, irei descrever os padrões mais importantes de expressão regulares. Porém, mesmo que eu explique em detalhes, a prática pode ser um pouco difícil no início. Muitas vezes, você imagina que a sua expressão regular representa um texto x, quando na realidade, ela representa um texto y. Como resultado, você pode acabar encontrando textos que você não queria encontrar, ou ainda, não encontrar nenhum texto sequer.</p>
<p>Sempre que eu me vejo nessa situação, em que não sei exatamente o que está errado em minha expressão regular, eu costumo utilizar as funções <code>str_view()</code> e <code>str_view_all()</code> para visualizar em mais detalhes, o texto encontrado (ou que deixou de ser encontrado) por essa expressão regular.</p>
<p>Em resumo, as funções <code>str_view()</code> e <code>str_view_all()</code> aceitam um vetor do tipo <code>character</code> e uma expressão regular como <em>inputs</em>. Como <em>output</em>, essas funções retornam um arquivo HTML que expõe as partes exatas dos textos contidos no vetor de <em>input</em>, que foram encontradas pela expressão regular que você forneceu. Como diferença, <code>str_view()</code> mostra apenas a primeira correspondência encontrada pela expressão regular em cada texto, enquanto <code>str_view_all()</code> mostra todas as correspondências encontradas em cada texto.</p>
<p>Como exemplo, o comando <code>str_view("banana", "an")</code> retorna a visualização abaixo como resultado. Segundo essa visualização, a expressão regular <code>"an"</code> consegue encontrar o texto b<strong>an</strong>ana.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(<span class="st">"banana"</span>, <span class="st">"an"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view1.png" class="img-fluid figure-img" style="width:50.0%"></p>
</figure>
</div>
</div>
</div>
<p>Caso eu utilize a função <code>str_view_all()</code>, podemos perceber que mais partes da palavra “banana” podem ser encontrados pela mesma expressão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view_all</span>(<span class="st">"banana"</span>, <span class="st">"an"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view2.png" class="img-fluid figure-img" style="width:30.0%" data-fig-pos="h"></p>
</figure>
</div>
</div>
</div>
<p>Apesar dos exemplos acima serem bastante simples, o real valor dessas funções se mostra quando estamos tentando construir uma expressão regular razoavelmente longa e complexa. Por exemplo, durante a construção e manutenção deste livro, eu utilizo algumas expressões regulares para transformar citações do formato Latex para o formato universal de citações do Rmarkdown. Logo abaixo, temos um exemplo dessas expressões regulares.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>expre <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\\\</span><span class="st">citeonline</span><span class="sc">\\</span><span class="st">[([p. ]+)([0-9]+)</span><span class="sc">\\</span><span class="st">{([a-zA-Z0-9_]+)</span><span class="sc">\\</span><span class="st">}"</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para testarmos essa expressão regular, construí abaixo, um objeto contendo alguns exemplos de citações em formato Latex. Logo, é esperado que essa expressão regular encontre (ou cubra) todos os exemplos de citação abaixo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>exemplos <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Segundo </span><span class="sc">\\</span><span class="st">citeonline[p. 45]{wickham2017}, algo importante"</span>,</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"</span><span class="sc">\\</span><span class="st">citeonline[p. 3]{alvaro_2011} refutou tal modelo"</span>,</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Apresentado por </span><span class="sc">\\</span><span class="st">citeonline[p. 842]{silva21}"</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Entretanto, quando fornecemos o objeto de exemplos, e a expressão regular à <code>str_view()</code>, vemos que nenhum texto é encontrado nos três exemplos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(exemplos, expre)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view3.png" class="img-fluid figure-img" style="width:60.0%"></p>
</figure>
</div>
</div>
</div>
<p>O que tem de errado com essa expressão? Primeiro, precisamos descobrir <strong>onde</strong> está o problema. Será que é uma parte específica da expressão que está quebrando a busca? Ou será que toda essa expressão é inválida, e não serve de nada para o nosso objetivo?</p>
<p>A melhor maneira de respondermos a essas questões é testar cada parte dessa expressão de forma separada. Se uma parte específica da expressão consegue encontrar o texto que nós esperávamos que essa parte encontrasse, temos um sinal de que o problema está em um outro lugar da expressão.</p>
<p>Como exemplo, vamos testar primeiro a parte <code>\\\\citeonline</code> da expressão. Repare abaixo, que a expressão consegue localizar todos os exemplos de <code>\citeonline</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(exemplos, <span class="st">"</span><span class="sc">\\\\</span><span class="st">citeonline"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view4.png" class="img-fluid figure-img" style="width:60.0%" data-fig-pos="h"></p>
</figure>
</div>
</div>
</div>
<p>Agora, vamos adicionar as partes <code>\\[</code>, <code>([p. ]+)</code> e <code>([0-9]+)</code> da expressão. Perceba novamente abaixo, que ainda não conseguimos encontrar o problema, pois as partes que nós esperávamos encontrar foram de fato encontradas.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>expre <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\\\</span><span class="st">citeonline</span><span class="sc">\\</span><span class="st">[([p. ]+)([0-9]+)"</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(exemplos, expre)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view5.png" class="img-fluid figure-img" style="width:60.0%" data-fig-pos="h"></p>
</figure>
</div>
</div>
</div>
<p>Porém, perceba agora, que, ao inserirmos a próxima parte da expressão (<code>\\{</code>), nenhum texto é encontrado. Por esse efeito, podemos inferir que há algo de errado nessa parte da expressão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>expre <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\\\</span><span class="st">citeonline</span><span class="sc">\\</span><span class="st">[([p. ]+)([0-9]+)</span><span class="sc">\\</span><span class="st">{"</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(exemplos, expre)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view3.png" class="img-fluid figure-img" style="width:60.0%" data-fig-pos="h"></p>
</figure>
</div>
</div>
</div>
<p>Após analisarmos por um tempo esse problema, podemos identificar que está faltando uma parte <code>\\]</code> antes de <code>\\{</code>. Pois o colchete aberto (identificado por <code>\\[</code>) precisa ser fechado (identificado por <code>\\]</code>). Ao adicionarmos essa parte à expressão, todo o problema é solucionado, e a expressão passa a encontrar corretamente todas as citações.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>expre <span class="ot">&lt;-</span> <span class="st">"</span><span class="sc">\\\\</span><span class="st">citeonline</span><span class="sc">\\</span><span class="st">[([p. ]+)([0-9]+)</span><span class="sc">\\</span><span class="st">]"</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>expre <span class="ot">&lt;-</span> <span class="fu">str_c</span>(expre, <span class="st">"</span><span class="sc">\\</span><span class="st">{([a-zA-Z0-9_]+)</span><span class="sc">\\</span><span class="st">}"</span>)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str_view</span>(exemplos, expre)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="./../Figuras/regex_view6.png" class="img-fluid figure-img" style="width:60.0%" data-fig-pos="h"></p>
</figure>
</div>
</div>
</div>
<p>Portanto, sempre que você enfrentar alguma dificuldade com as suas expressões regulares, tente utilizar as funções <code>str_view()</code> e <code>str_view_all()</code> para identificar onde o problema está ocorrendo. Essas funções também podem ser muito úteis, quando você ainda não sabe exatamente como construir a expressão que você necessita. Nesse caso, você pode utilizar essas funções para testar várias possibilidades diferentes, atrás da primeira que funcione.</p>
</section>
<section id="caracteres-literais-e-metacharacters" class="level3" data-number="10.8.3">
<h3 data-number="10.8.3" class="anchored" data-anchor-id="caracteres-literais-e-metacharacters"><span class="header-section-number">10.8.3</span> Caracteres literais e <em>metacharacters</em></h3>
<p>Expressões regulares são uma linguagem formada por duas categorias de caracteres <span class="citation" data-cites="friedl2006">(<a href="#ref-friedl2006" role="doc-biblioref">FRIEDL, 2006</a>)</span>: 1) Caracteres literais, ou simples letras e números pelos quais pesquisamos; e 2) <em>metacharacters</em>, que são um conjunto de caracteres especiais que delimitam o escopo de sua pesquisa, ou a maneira como ela será executada.</p>
<p>Até o momento, utilizamos apenas caracteres literais, ao pesquisarmos pelas sequências <code>"emissão"</code> ou <code>"is"</code>. Ou seja, qualquer número ou letra que formam uma sequência de caracteres são considerados caracteres literais. Alguns símbolos também são considerados caracteres literais, pois não possuem nenhum comportamento especial que altere o comportamento da pesquisa. Como exemplo, a expressão <code>"A1_z-4!D8"</code> é formada apenas por caracteres literais, mesmo que ela descreva uma sequência bem esquisita (e provavelmente inútil) de caracteres.</p>
<p>Qualquer expressão que utilize apenas caracteres literais, busca efetuar uma simples pesquisa por uma sequência particular de caracteres. Consequentemente, a expressão <code>"1"</code> é capaz de detectar o texto “Álvaro chegou em <strong>1</strong>° lugar!”, assim como “O aluguel chegou a R$3250,<strong>1</strong>0 nesse mês”. Como um outro exemplo, ao empregarmos a expressão <code>"regi"</code>, ela é capaz de encontrar os textos “<strong>regi</strong>ão” e “<strong>regi</strong>stro”, mas não é capaz de detectar o nome “Reginaldo”, pelo simples fato de que a primeira letra do nome é um “r” maiúsculo, ao invés de um “r” minúsculo.</p>
<p>Em síntese, expressões regulares já são uma ferramenta útil apenas com o uso de caracteres literais. Contudo, elas se tornam bastante limitadas sem o uso de <em>metacharacters</em>, que ampliam em muito as suas funcionalidades, e mudam drasticamente a forma como a pesquisa ocorre. Neste ponto, também reside uma importante dificuldade no domínio de expressões regulares. Pois são muitos <em>metacharacters</em> disponíveis e, por isso, memorizar o que cada um deles fazem, e quais são as suas aplicações mais úteis, não se trata de uma tarefa simples.</p>
<p>Apesar disso, haverá momentos em que você deseja encontrar ou incluir em sua expressão regular o caractere literal que um certo <em>metacharacter</em> representa. Em outras palavras, há ocasiões em que você deseja que certos <em>metacharacters</em> se comportem como caracteres literais. Por exemplo, um dos <em>metacharacters</em> que vamos mostrar nas próximas seções é <code>?</code> (ponto de interrogação). Portanto, o caractere <code>?</code> possui um comportamento especial em expressões regulares, mas se quisermos encontrar o caractere <code>?</code> em si, ao longo do texto, nós precisamos contornar o comportamento especial desse <em>metacharacter</em>. Para isso, basta anteceder esse caractere por uma barra inclinada à esquerda (<code>\?</code>).</p>
<p>Porém, lembre-se que para escrevermos uma barra inclinada à esquerda, nós temos que digitar duas barras inclinadas à esquerda! Logo, para escrever em sua expressão regular, o termo <code>\?</code>, você deve na verdade, digitar o termo <code>\\?</code>. Isso funciona para praticamente qualquer <em>metacharacter</em>. Logo, sempre que você precisar utilizar um certo <em>metacharacter</em> como um caractere literal, tente antecedê-lo por duas barras inclinadas à esquerda.</p>
</section>
<section id="sec:regex_ancoras" class="level3" data-number="10.8.4">
<h3 data-number="10.8.4" class="anchored" data-anchor-id="sec:regex_ancoras"><span class="header-section-number">10.8.4</span> Âncoras (<em>anchors</em>)</h3>
<p>O primeiro tipo de <em>metacharacters</em> que vou apresentar, são os do tipo “âncora”. Esse conjunto é composto pelos caracteres <code>^</code> e <code>$</code>, que são responsáveis por delimitar o início e o fim de uma linha, respectivamente.</p>
<p>Logo, ao utilizar a expressão <code>"^emissão$"</code>, eu estou pedindo à <code>str_detect()</code> que localize um texto que contém: o início de uma linha imediatamente seguido pela sequência “e-m-i-s-s-ã-o” de caracteres, que por sua vez, deve ser imediatamente seguido pelo fim dessa mesma linha. Com essa expressão, somos capazes de encontrar apenas a palavra “emissão” que está entre os valores do vetor <code>vec</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"^emissão$"</span>)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"</code></pre>
</div>
</div>
<p>É importante destacar, que os caracteres <code>^</code> e <code>$</code> são capazes de encontrar os limites de uma linha, e não de uma palavra. Por isso, a partir do momento em que a sequência “e-m-i-s-s-ã-o” não estiver encostando em pelo menos um dos limites da linha, <code>str_detect()</code> não será mais capaz de encontrar tal conjunto de caracteres. Como exemplo, perceba abaixo, que apenas o primeiro elemento de <code>text</code> pôde corresponder à expressão empregada em <code>str_detect()</code>. Ou seja, mesmo que o quarto, quinto e sexto elementos de <code>text</code> possuam a palavra “emissão”, eles não puderam ser encontrados pela expressão <code>"^emissão$"</code>, devido ao fato de não estarem localizados em pelo menos um dos limites da linha.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>text <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"emissão"</span>,</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"A Ford Brasil executou recentemente uma demissão em massa"</span>,</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"remissão"</span>,</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Para mais, a emissão de CO2 cresceu no Brasil"</span>,</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"emissão de S02 faz parte do processo"</span>,</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"A firma foi processada por tal emissão"</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(text, <span class="st">"^emissão$"</span>)</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>text[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"</code></pre>
</div>
</div>
<p>Vale destacar que você não precisa necessariamente utilizar os dois <em>metacharacters</em> ao mesmo tempo. Logo, temos a opção de construir uma expressão que possa encontrar uma certa sequência de caracteres ao final ou no início de uma linha. Por exemplo, a expressão abaixo, busca encontrar a sequência “e-m-i-s-s-ã-o” de caracteres quando ela é imediatamente seguida pelo final da linha.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(text, <span class="st">"emissão$"</span>)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>text[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"                               
[2] "remissão"                              
[3] "A firma foi processada por tal emissão"</code></pre>
</div>
</div>
<p>Alguns outros exemplos de expressões regulares que empregam <em>metacharacters</em> do tipo âncora, além de uma rápida reflexão sobre os caracteres <code>^</code> e <code>$</code>, são oferecidos na <a href="#fig-regex-ancoras" class="quarto-xref">Figura&nbsp;<span>10.3</span></a>. Repare que todas as partes do texto que foram detectadas pela expressão regular, foram novamente marcadas de cinza. Perceba também, que cada seta presente na figura, busca conectar cada uma das partes detectadas do texto, ao componente específico da expressão regular que foi responsável por detectá-la.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-regex-ancoras" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-regex-ancoras-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./../Figuras/ancoras.png" class="img-fluid figure-img" style="width:100.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-regex-ancoras-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;10.3: Exemplos e uma reflexão sobre as correspondências encontradas por metacharacters do tipo âncora.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="classes-de-caracteres-character-classes" class="level3" data-number="10.8.5">
<h3 data-number="10.8.5" class="anchored" data-anchor-id="classes-de-caracteres-character-classes"><span class="header-section-number">10.8.5</span> Classes de caracteres (<em>character classes</em>)</h3>
<p>Uma estrutura muito importante em expressões regulares são as classes de caracteres, ou <em>character classes</em>. Sendo construída a partir de um par de colchetes (<code>[]</code>), essa estrutura lhe permite listar os possíveis caracteres que você deseja encontrar em um ponto da sequência descrita por sua expressão regular.</p>
<p>Por exemplo, suponha que você esteja lendo um livro-texto sobre a linguagem R, e que você queira encontrar todas as instâncias do livro que se referem ao termo <em>regex</em>. Você sabe que as regiões que descrevem o assunto no qual você está interessado, vão conter o termo <em>regex</em>, mas você não sabe como o termo <em>regex</em> está citado no texto. Digo, será que o autor está colocando a primeira letra em maiúsculo (Regex)? Ou será que todo o termo está em maiúsculo (REGEX)?</p>
<p>Tendo essa dúvida em mente, você pode criar uma expressão regular, que permita certas variações da palavra <em>regex</em>, ao listar todas as possibilidades em uma dada posição do termo. Primeiro, vamos imaginar que você deseja permitir que a primeira letra do termo seja tanto maiúscula quanto minúscula. No exemplo abaixo, ao incluirmos as letras “r” e “R” dentro da classe de caracteres (<code>[]</code>), estamos estabelecendo que no primeiro caractere da sequência, podemos ter uma letra “r” ou uma letra “R”.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>texto <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Cada letra, número, ou símbolo presente no texto é um caractere."</span>,</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Textos são criados ao contornados por aspas (duplas ou simples)."</span>,</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"O termo regex é uma abreviação para regular expressions."</span>,</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Regex é um termo comum no mundo da computação."</span>,</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Metacharacters alteram consideravelmente o comportamento de um REGEX."</span>,</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ReGEx? Ou reGex? Talvez RegEX?."</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(texto, <span class="st">"[Rr]egex"</span>)</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>texto[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "O termo regex é uma abreviação para regular expressions."
[2] "Regex é um termo comum no mundo da computação."          </code></pre>
</div>
</div>
<p>Ou seja, uma classe de caracteres busca descrever os caracteres possíveis para uma única e particular posição da sequência. Logo, a expressão <code>"[Rr]egex"</code> não está descrevendo a sequência “[-R-r-]-e-g-e-x”, mas está afirmando que “r-e-g-e-x” e “R-e-g-e-x” são duas sequências de caracteres que queremos encontrar em nossa pesquisa. Com isso, se tivéssemos de permitir todas as possibilidades de capitalização em cada letra do termo, poderíamos fornecer a seguinte expressão à <code>str_detect()</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(texto, <span class="st">"[Rr][Ee][Gg][Ee][Xx]"</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>texto[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "O termo regex é uma abreviação para regular expressions."             
[2] "Regex é um termo comum no mundo da computação."                       
[3] "Metacharacters alteram consideravelmente o comportamento de um REGEX."
[4] "ReGEx? Ou reGex? Talvez RegEX?."                                      </code></pre>
</div>
</div>
<p>Dessa maneira, estamos permitindo que <code>str_detect()</code> encontre todas as possibilidades do termo <em>regex</em>, quanto ao uso de capitalização (regex, Regex, REGEX, rEgex, reGex, regEx, regeX, …).</p>
<p>As classes de caracteres também são muito utilizadas para criar um intervalo de caracteres possíveis em um determinado ponto. Esses intervalos são rapidamente formados pelo <em>metacharacter</em> - (sinal de menos). Como exemplo, podemos utilizar o atalho <code>[0-9]</code> para listarmos todos os números de 0 a 9 dentro da classe. Esse atalho é extremamente útil quando desejamos encontrar alguma parte numérica em nosso texto, mas nós não sabemos previamente quais números em particular vão estar presentes nesse item.</p>
<p>Por exemplo, suponha que uma comissão nacional tenha divulgado as colocações de diversos participantes em um torneio de xadrez. Você deseja analisar os participantes e suas respectivas colocações, entretanto, a comissão divulgou os dados como um texto simples em sua página da internet, ao invés de guardar esses dados em uma tabela, ou em alguma outra estrutura que fosse de fácil transposição para o R.</p>
<p>Com isso, você precisa utilizar uma expressão regular que possa encontrar essas colocações ao longo do texto. Uma possibilidade, seria tentarmos localizar as ocorrências de um número seguido do símbolo de grau (°), ao longo do texto. No exemplo abaixo, as colocações variam de 1 a 6 e, por isso, precisamos listar todos os números neste intervalo dentro de uma classe, e acrescentar o símbolo de grau, formando assim, a expressão <code>"[123456]°"</code>. Porém, ao invés de listarmos número por número, podemos aplicar o atalho <code>[1-6]</code> para criarmos uma lista contendo todos os números de 1 a 6.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>colocacoes <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"1°: Álvaro"</span>,</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"2°: Melissa"</span>,</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"3°: Ana"</span>,</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"4°: Eduardo"</span>,</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"5°: Daniela"</span>,</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"6°: Matheus"</span>,</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Não é uma colocação"</span>,</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Também não é uma colocação"</span>,</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">"31°C"</span>,</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>  <span class="st">"24°F"</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(colocacoes, <span class="st">"[1-6]°"</span>)</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>colocacoes[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1°: Álvaro"  "2°: Melissa" "3°: Ana"     "4°: Eduardo" "5°: Daniela"
[6] "6°: Matheus" "31°C"        "24°F"       </code></pre>
</div>
</div>
<p>Como podemos ver acima, conseguimos localizar todas as colocações. No entanto, perceba que a expressão <code>"[1-6]°"</code> também pôde encontrar informações que se referem a temperaturas (celsius e fahrenheit). Portanto, a expressão <code>"[1-6]°"</code> é muito abrangente para o nosso caso e, em função disso, precisamos descrever em mais detalhes o texto que desejamos. Tudo o que precisamos fazer para corrigir o resultado acima, é incluir uma expressão que encontre um número seguido por um símbolo de grau, <strong>exceto</strong> quando as letras C ou F estão logo após o símbolo de grau.</p>
<p>Para essa tarefa, podemos utilizar o comportamento negativo de uma classe. Em outras palavras, além de listar os caracteres aceitos em uma certa posição, nós também temos a capacidade de utilizar uma classe de caracteres para listar todos os caracteres que <strong>não podem</strong> estar situados em uma determinada posição da sequência.</p>
<p>Para definir os caracteres não desejados em uma posição, você deve iniciar a sua classe, por um acento circunflexo, logo antes de listar os caracteres em questão (<code>[^...]</code>). Com isso, se desejamos evitar as letras C e F (independente de sua capitalização) precisaríamos da sub expressão <code>[^CcFf]</code> logo após o símbolo de grau, formando assim, a expressão regular abaixo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(colocacoes, <span class="st">"[1-6]°[^CcFf]"</span>)</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>colocacoes[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "1°: Álvaro"  "2°: Melissa" "3°: Ana"     "4°: Eduardo" "5°: Daniela"
[6] "6°: Matheus"</code></pre>
</div>
</div>
<p>Portanto, sempre que você encontrar uma classe que contém um acento circunflexo como seu primeiro item, você sabe que essa classe está negando os caracteres listados dentro dela (exemplo: <code>"[^1-6_!]"</code>, não são permitidos nessa posição qualquer número entre 1 e 6, o símbolo <em>underscore</em> ou um ponto de exclamação). Logo, na posição que essa classe representa, não devem ser encontrados os caracteres que estão listados dentro dela. Mas se essa classe não possui tal acento, ou se esse acento circunflexo se encontra a partir do segundo caractere listado, a classe em análise está utilizando seu comportamento positivo (ou afirmativo), de modo que os caracteres listados em seu interior, podem sim estar naquela posição.</p>
<p>Como um outro exemplo, veja abaixo, as correspondências geradas pela expressão <code>"[0-9][^Ffh]"</code>, que utiliza ambos os modos de classe (negativa e positiva). Essa expressão, busca encontrar um número entre 0 e 9, que é imediatamente seguido por um caractere qualquer (que não seja as letras “F”, “f”e “h”). Repare no caso do texto <code>"A5"</code>, no qual a expressão não é capaz de localizá-lo pelo simples fato de que o texto acaba no dígito 5. Lembre-se que cada classe de caracteres representa um caractere a ser encontrado em uma determinada posição da sequência. Logo, mesmo que a parte <code>[^Ffh]</code> esteje listando os caracteres que não podem ser encontrados, ela está automaticamente definindo que <strong>algum caractere deve ser encontrado na segunda posição da sequência</strong>.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./../Figuras/classes_caractere.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Um exemplo de expressão regular que emprega ambos os modos de classes de caractere (positiva e negativa)</figcaption>
</figure>
</div>
</div>
</div>
<p>Além desses pontos, repare acima, que o <em>metacharacter</em> <code>^</code> (acento circunflexo) tem um papel completamente diferente dentro de uma classe de caracteres, se comparado ao papel que ele exerce fora dela. Em resumo, o caractere <code>^</code> fora de uma classe, é um <em>metacharacter</em> do tipo âncora, sendo capaz de definir o início de uma linha; mas dentro de uma classe, ele está determinando o comportamento adotado pela classe em questão, de forma que os caracteres listados nessa classe não devem ser encontrados na posição que essa classe simboliza.</p>
<p>Logo, é muito importante destacar o fato de que diversos caracteres possuem um comportamento profundamente diferente, quando inseridos em uma classe de caracteres. Fique atento a isso! Se algum <em>metacharacter</em> estiver se comportando de maneira inesperada, é possível que essa diferença entre os mundos de dentro e de fora de uma classe seja a fonte de sua surpresa. De certo modo, você pode compreender essa situação, como se as classes possuíssem a sua própria mini linguagem, com o seu próprio conjunto de <em>metacharacters</em>, separados da realidade de fora delas <span class="citation" data-cites="friedl2006">(<a href="#ref-friedl2006" role="doc-biblioref">FRIEDL, 2006</a>)</span>.</p>
<p>Por outro lado, e se você desejasse incluir os <em>metacharacters</em> <code>-</code> e <code>^</code> como possíveis caracteres para uma determinada posição? Como o caractere <code>-</code> cria uma sequência, você precisa listá-lo logo no início de sua classe (ex: <code>"[-1-6]"</code>, que permite um número entre 1 e 6, além de um sinal de menos). Em contrapartida, o caractere <code>^</code> exerce o seu comportamento especial quando é posicionado como o primeiro item de uma classe. Por essa razão, você precisaria listá-lo em uma outra posição qualquer da classe, para que ele se comportasse como um simples acento circunflexo (ex: <code>"[ABC^]"</code>, que permite as letras A, B e C, além de um acento circunflexo).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"A-B"</span>, <span class="st">"CDE-F"</span>, <span class="st">"12^54"</span>, <span class="st">"R$1230,2"</span>, <span class="st">"BRA"</span>)</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(a, <span class="st">"[-^]"</span>)</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>a[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "A-B"   "CDE-F" "12^54"</code></pre>
</div>
</div>
<p>Até o momento, mostramos apenas o atalho para listar uma sequência numérica (ex: <code>"[0-9]"</code>). Mas também temos um outro atalho para listarmos um intervalo específico (ou todas as letras) do alfabeto. Para isso, podemos utilizar o atalho <code>[a-z]</code> para letras minúsculas, e <code>[A-Z]</code> para letras maiúsculas. Por exemplo, suponha que você possua o conjunto de códigos mostrados no objeto <code>codes</code>. Suponha também, que os códigos que contém letras de “A” a “F”, correspondem a unidades manufaturadas em Belo Horizonte, enquanto os códigos que contém letras de “G” a “Z” dizem respeito a unidades fabricadas na região de São Paulo.</p>
<p>Com isso em mente, para reunirmos todos os códigos de produtos construídos em Belo Horizonte, precisaríamos apenas encontrar os códigos que contém qualquer letra dentro do intervalo de “A” e “F”. Todavia, repare que a capitalização das letras presentes nos códigos, varia. Por isso, precisamos combinar o mesmo intervalo de letras em ambos os estilos de capitalização. Dessa maneira, geramos a expressão abaixo, que contém ambos os intervalos (<code>"[a-fA-F]"</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>codes <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"AeF15"</span>, <span class="st">"CCd31"</span>, <span class="st">"17GHJ"</span>, <span class="st">"Lmm96"</span>, <span class="st">"ee3f8"</span>, <span class="st">"BA45B"</span>,</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"EccF2"</span>, <span class="st">"675Cc"</span>, <span class="st">"hkJ78"</span>, <span class="st">"q401Q"</span>, <span class="st">"iop67"</span>, <span class="st">"DCa98"</span>)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(codes, <span class="st">"[a-fA-F]"</span>)</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>codes[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "AeF15" "CCd31" "ee3f8" "BA45B" "EccF2" "675Cc" "DCa98"</code></pre>
</div>
</div>
<section id="conclusão-e-algumas-dicas-extras" class="level4" data-number="10.8.5.1">
<h4 data-number="10.8.5.1" class="anchored" data-anchor-id="conclusão-e-algumas-dicas-extras"><span class="header-section-number">10.8.5.1</span> Conclusão e algumas dicas extras</h4>
<p>Portanto, uma classe de caracteres busca listar os caracteres que podem ou não ser encontrados na posição da sequência que essa classe representa. Em síntese, podemos interpretar o seu uso da seguinte maneira:</p>
<ul>
<li><p><code>[abc]</code>: encontre <code>a</code> ou <code>b</code> ou <code>c</code>.</p></li>
<li><p><code>[^abc]</code>: encontre qualquer caractere, exceto <code>a</code>, <code>b</code> ou <code>c</code>.</p></li>
</ul>
<p>Além disso, uma classe de caracteres lhe permite criar <em>ranges</em>, ou intervalos de caracteres possíveis, como:</p>
<ul>
<li><p><code>[0-9]</code>: encontre qualquer número entre 0 e 9.</p></li>
<li><p><code>[a-z]</code>: encontre qualquer letra (minúscula) entre <code>a</code> e <code>z</code>.</p></li>
<li><p><code>[A-Z]</code>: encontre qualquer letra (maiúscula) entre <code>A</code> e <code>Z</code>.</p></li>
</ul>
<p>Porém, para além dos usos apresentados até aqui, o R nos oferece alguns atalhos para essas construções, sendo os principais:</p>
<ul>
<li><p><code>\d</code>: encontre um dígito (atalho para <code>[0-9]</code>).</p></li>
<li><p><code>\s</code>: encontre qualquer espaço em branco (atalho para <code>[ \t\n]</code>).</p></li>
<li><p><code>\w</code>: encontre um caractere alfanumérico ou um <em>underline</em> (atalho para <code>[a-zA-Z0-9_]</code>)</p></li>
</ul>
<p>Lembre-se que, no R, para inserirmos uma barra inclinada à esquerda em uma <em>string</em>, nós precisamos escrever duas barras inclinadas à esquerda. Logo, para inserirmos, por exemplo, o atalho <code>\d</code> em alguma de nossas expressões regulares, somos obrigados a digitar <code>\\d</code>.</p>
</section>
</section>
<section id="representando-qualquer-caractere-com-um-ponto" class="level3" data-number="10.8.6">
<h3 data-number="10.8.6" class="anchored" data-anchor-id="representando-qualquer-caractere-com-um-ponto"><span class="header-section-number">10.8.6</span> Representando qualquer caractere com um ponto</h3>
<p>Você pode representar qualquer caractere em uma expressão regular, por meio do <em>metacharacter</em> <code>.</code> (ponto final). Ou seja, um ponto final em uma expressão regular é capaz de encontrar qualquer caractere (seja ele um número, um símbolo ou uma letra) na posição que ele representa. Logo, a expressão <code>"B.3"</code> significa na prática: uma letra “B”, imediatamente seguida por um caractere qualquer, que por sua vez, é imediatamente seguido por um número 3.</p>
<p>Por exemplo, suponha que você queira encontrar a data “20/02/2019”, mas você sabe que essa data pode se encontrar em diferentes formatos, como 20.02.2019, ou 20-02-2019. Tendo isso em mente, você provavelmente tentaria uma expressão como <code>"20[-/.]02[-/.]2019"</code>. Por outro lado, poderíamos atingir o mesmo resultado ao substituirmos as classes de caracteres por pontos finais, gerando assim, a expressão <code>"20.02.2019"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"20.02.2019"</span>, <span class="st">"20-02-2019"</span>, <span class="st">"20/02/2019"</span>,</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"A senha é 2060212019"</span>, <span class="st">"20$02#2019"</span>)</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"20.02.2019"</span>)</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "20.02.2019"           "20-02-2019"           "20/02/2019"          
[4] "A senha é 2060212019" "20$02#2019"          </code></pre>
</div>
</div>
<p>Porém, é importante que você tenha cuidado ao utilizar esse <em>metacharacter</em>. Pois como podemos ver acima, a expressão <code>"20.02.2019"</code> também é capaz de encontrar o texto “<strong>20$02#2019</strong>”, assim como o texto “A senha é <strong>2060212019</strong>”. Portanto, as chances de você encontrar o que você não deseja, podem aumentar a depender da maneira em que você aplica esse <em>metacharacter</em> em sua expressão.</p>
</section>
<section id="criando-alternativas-alternation" class="level3" data-number="10.8.7">
<h3 data-number="10.8.7" class="anchored" data-anchor-id="criando-alternativas-alternation"><span class="header-section-number">10.8.7</span> Criando alternativas (<em>alternation</em>)</h3>
<p>Há certos momentos, em que não conseguimos expor todos os nossos desejos com uma única expressão. Por essa razão, temos o <em>metacharacter</em> <code>|</code> (barra vertical) que nos permite combinar diferentes sub expressões em uma só. Dessa maneira, a função responsável pela pesquisa, irá procurar por qualquer texto que atenda a pelo menos uma dessas sub expressões. Sendo este efeito, comumente denominado de alternação (ou <em>alternation</em>).</p>
<p>Como exemplo, na seção anterior estávamos tentando encontrar o termo <em>regex</em>, ao longo de várias sentenças, que estão reproduzidas logo abaixo, no vetor <code>texto</code>. Na primeira instância, fizemos uso de uma classe de caracter para permitirmos uma letra “r” tanto minúscula quanto maiúscula, no primeiro caractere da sequência de nossa expressão (<code>"[Rr]egex"</code>).</p>
<p>Porém, temos a capacidade de atingir o mesmo resultado, com o uso de alternação. Basta separarmos os dois casos que estamos tentando representar, pelo <em>metacharacter</em> <code>|</code>, formando assim, a expressão abaixo (<code>"Regex|regex"</code>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>texto <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Cada letra, número, ou símbolo presente no texto é um caractere."</span>,</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Textos são criados ao contornados por aspas (duplas ou simples)."</span>,</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"O termo regex é uma abreviação para regular expressions."</span>,</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Regex é um termo comum no mundo da computação."</span>,</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Metacharacters alteram consideravelmente o comportamento de um REGEX."</span>,</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"ReGEx? Ou reGex? Talvez RegEX?."</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(texto, <span class="st">"Regex|regex"</span>)</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>texto[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "O termo regex é uma abreviação para regular expressions."
[2] "Regex é um termo comum no mundo da computação."          </code></pre>
</div>
</div>
<p>Lembre-se que a realidade dentro de uma classe de caracteres é completamente diferente de seu exterior. Logo, dentro de uma classe de caracteres, o caractere <code>|</code> é simplesmente um caractere literal, assim como as letras “x” e “r”. Por isso, uma expressão como <code>"Rege[x|r]egex"</code>, estaria na verdade procurando por sequências como “R-e-g-e-x-e-g-e-x”, “R-e-g-e-|-e-g-e-x” e “R-e-g-e-r-e-g-e-x”.</p>
<p>Para mais, é importante que você entenda que cada sub expressão conectada pelo <em>metacharacter</em> <code>|</code>, representa uma expressão regular diferente das demais.</p>
<p>Veja como exemplo, a expressão abaixo. A primeira sub expressão (<code>"[3-6]°"</code>) seleciona um texto que contenha um número entre 3 e 6 imediatamente seguido de um símbolo de grau. A segunda sub expressão (<code>"is[ao]"</code>) seleciona um texto que contenha a sequência “i-s-a” ou “i-s-o” de caracteres. Já a terceira sub expressão (<code>R\\$[0-9]+(,[0-9][0-9])?</code>), que é bem mais elaborada do que as outras duas, busca selecionar um texto que contenha um valor monetário. Com isso, qualquer texto que se encaixe em alguma dessas condições, será selecionado pela função.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"1230"</span>, <span class="st">"Tenho consulta no dia 25"</span>, <span class="st">"R$12,45"</span>, </span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"Essa máquina custa R$320,21"</span>, <span class="st">"Márcia"</span>, <span class="st">"Isotônico"</span>,</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"Álcool isopropílico"</span>, <span class="st">"Hoje fez 30°"</span>, <span class="st">"4° é muito frio!"</span>)</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"[3-6]°|is[ao]|R</span><span class="sc">\\</span><span class="st">$[0-9]+(,[0-9][0-9])?"</span>)</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "R$12,45"                     "Essa máquina custa R$320,21"
[3] "Álcool isopropílico"         "4° é muito frio!"           </code></pre>
</div>
</div>
<p>Um outro detalhe importante, é que você pode limitar o alcance das alternativas, ao contorná-las com parênteses. Em outras palavras, ao invés de fornecer várias sub expressões, você pode fornecer diferentes sub expressões <strong>dentro</strong> de uma expressão “geral”.</p>
<p>Por exemplo, vamos voltar à expressão <code>"Regex|regex"</code>. Se nós isolarmos a seção <code>"ex|re"</code>, temos um resultado completamente diferente do que vimos anteriormente, pois as sub expressões passam a ser “e-x” e “r-e”, e não “r-e-g-e-x” e “R-e-g-e-x” como anteriormente. Dessa maneira, estamos na verdade procurando por textos que contenham a sequência “R-e-g-e-x-g-e-x” ou a sequência “R-e-g-r-e-g-e-x”.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"regex"</span>, <span class="st">"Regex"</span>, <span class="st">"ISORegex-18930"</span>, <span class="st">"Regexgexgexgexgex"</span>)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"Reg(ex|re)gex"</span>)</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Regexgexgexgexgex"</code></pre>
</div>
</div>
<p>Dessa vez, importando um exemplo diretamente da obra de <span class="citation" data-cites="friedl2006">FRIEDL (<a href="#ref-friedl2006" role="doc-biblioref">2006</a>)</span>, suponha que você possua um arquivo de texto, contendo uma lista de todos os e-mails de sua caixa de entrada. Com esse arquivo, poderíamos utilizar a expressão <code>"^(From|Subject|Date):"</code> para extraírmos apenas as linhas do arquivo que contém a referência do remetente (<code>From:</code>), do assunto (<code>Subject:</code>) e da data de envio (<code>Date:</code>) de cada e-mail. Perceba também, que a expressão <code>"^(From|Subject|Date):"</code> é equivalente à expressão <code>"^From:|^Subject:|^Date:"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>email <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_lines</span>(<span class="st">"</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="st">From: elena_campaio@gmail.com Jun 15 2019 07:05</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="st">Received: from elena_campaio@gmail.com</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="st">To: pedropark99@gmail.com</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="st">Date: Thu, Jun 15 2019 07:05</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="st">Message-Id: &lt;20190322145154232.elena_campaio@gmail.com&gt;</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="st">Subject: Nova reunião</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="st">X-Mailer: by mailbox (Version 8.5.1) BellM Company, Copyright 2005-2019</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="st">Bom dia Pedro, poderíamos nos encontrar às 10hrs?</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a><span class="st">From: pedropark99@gmail.com Jun 15 2019 08:10 </span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a><span class="st">Received: from elena_campaio@gmail.com</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a><span class="st">To: elena_campaio@gmail.com</span></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a><span class="st">Date: Thu, Jun 15 2019 08:10</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a><span class="st">Message-Id: &lt;20190322145155198.elena_campaio@gmail.com&gt;</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a><span class="st">Subject: Re: Nova reunião</span></span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a><span class="st">Reply-To: elena_campaio@gmail.com &lt;20190322145154232.elena_campaio@gmail&gt;</span></span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a><span class="st">X-Mailer: by mailbox (Version 8.5.1) BellM Company, Copyright 2005-2019</span></span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a><span class="st">Ok Elena! Podemos nos encontrar esse horário."</span>)</span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-24"><a href="#cb106-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-25"><a href="#cb106-25" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(email, <span class="st">"^(From|Subject|Date):"</span>)</span>
<span id="cb106-26"><a href="#cb106-26" aria-hidden="true" tabindex="-1"></a>email[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<pre><code>## [1] "From: elena_campaio@gmail.com Jun 15 2019 07:05"
## [2] "Date: Thu, Jun 15 2019 07:05"
## [3] "Subject: Nova reunião"
## [4] "From: pedropark99@gmail.com Jun 15 2019 08:10 "
## [5] "Date: Thu, Jun 15 2019 08:10"
## [6] "Subject: Re: Nova reunião"</code></pre>
</section>
<section id="quantificadores-quantifiers-ou-definindo-repetições" class="level3" data-number="10.8.8">
<h3 data-number="10.8.8" class="anchored" data-anchor-id="quantificadores-quantifiers-ou-definindo-repetições"><span class="header-section-number">10.8.8</span> Quantificadores (<em>quantifiers</em>) ou definindo repetições</h3>
<p>Há certos momentos em que precisamos permitir que um certo conjunto de caracteres sejam encontrados múltiplas vezes em uma mesma sequência de caracteres. Um bom exemplo disso, é a expressão que utilizamos na seção anterior <code>"R\\$[0-9]+(,[0-9][0-9])?"</code> para encontrarmos um valor monetário. Temos três partes principais nessa expressão, sendo elas: 1) <code>R\\$</code>; 2) <code>[0-9]+</code>; e 3) <code>(,[0-9][0-9])?</code>.</p>
<p>Primeiro, o que seria um valor monetário? Certamente seria um valor numérico. Porém, um número pode significar qualquer coisa! Talvez uma medida de peso (Kg), idade (anos), volume (L) ou qualquer outra variável contínua que você imaginar. Logo, precisamos de algum item que possa identificar esse número como uma medida de valor, e esse item se trata do símbolo da moeda brasileira (R$). Qualquer valor numérico presente em seu texto que estiver acompanhado desse símbolo é um valor monetário.</p>
<p>Com isso, teríamos a expressão <code>"R\\$[0-9]"</code> como uma tentativa inicial. Perceba que eu tive de contornar o comportamento especial do <em>metacharacter</em> <code>$</code>, ao antecedê-lo por duas barras inclinadas. Dessa maneira, a expressão <code>"\\$"</code> significa de fato o caractere <code>$</code> (cifrão), e não o fim de uma linha como definimos na seção <a href="#sec:regex_ancoras">Âncoras (<em>anchors</em>)</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Eu peso em torno de 65Kg"</span>, <span class="st">"Tenho consulta no dia 25"</span>,</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"R$1630,45"</span>, <span class="st">"Eu possuo uma conta de R$74,85 a pagar"</span>, </span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>         <span class="st">"R$400"</span>, <span class="st">"R21"</span>, <span class="st">"Hoje, R$30 equivale a $5,77 dólares"</span>)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"R</span><span class="sc">\\</span><span class="st">$[0-9]"</span>)</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "R$1630,45"                             
[2] "Eu possuo uma conta de R$74,85 a pagar"
[3] "R$400"                                 
[4] "Hoje, R$30 equivale a $5,77 dólares"   </code></pre>
</div>
</div>
<p>Entretanto, não há um limite específico para o número que um valor monetário pode atingir. Em outras palavras, podemos estar nos referindo a míseros centavos ou a milhões de reais. Traduzindo essa afirmação na prática, podemos ter uma quantidade variável de dígitos em nosso valor monetário. O valor R$5 possui apenas 1 dígito, enquanto o valor R$1245 possui 4 dígitos.</p>
<p>A princípio, essa questão não é tão importante, já que fomos capazes de encontrar todos os textos que contém algum valor monetário, com apenas a expressão <code>"R\\$[0-9]"</code>. Ou seja, mesmo que alguns desses valores possuam 3, 4 ou 6 dígitos, precisamos apenas detectar o seu primeiro dígito antecedido pelo símbolo R$.</p>
<p>Todavia, essa questão passa a ser crucial, na hipótese de aplicarmos alguma transformação sobre os valores monetários encontrados. Ou seja, se vamos, por exemplo, extrair os valores encontrados; ou substituí-los por algum outro texto; ou utilizá-los como pontos de quebra do texto que os contém; ou empregá-los em algum cálculo, é de extrema importância que possamos detectar todo o valor com a nossa expressão. Apenas para que fique claro, veja a representação abaixo, que mostra os resultados de ambas as expressões mostradas até aqui sobre o valor R$6530,58.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./../Figuras/regex_1.png" class="img-fluid figure-img" style="width:90.0%"></p>
<figcaption>Expressões regulares sobre valores monetários</figcaption>
</figure>
</div>
</div>
</div>
<p>Tendo como início, a expressão <code>"R\\$[0-9]"</code>, precisamos permitir uma quantidade variável de dígitos, mais especificamente na parte <code>"[0-9]"</code>. Em ocasiões como essa, nós podemos utilizar os <em>metacharacters</em> do tipo quantificadores, que incluem os caracteres <code>?</code> (ponto de interrogação), <code>+</code> (sinal de mais), <code>*</code> (asterisco) e <code>{}</code> (par de chaves). Como o próprio nome do tipo dá a entender, esses <em>metacharacters</em> buscam delimitar a quantidade de vezes que podemos encontrar um certo caractere em nossa sequência. Em outras palavras, esses <em>metacharacters</em> definem o número mínimo e máximo de ocorrências possíveis para um caractere específico de nossa expressão.</p>
<p>Primeiro, o <em>metacharacter</em> <code>*</code> representa 0 ocorrências como mínimo e infinitas ocorrências como máximo. Com isso, podemos dizer que o <em>metacharacter</em> <code>*</code> significa: “tente encontrar esse caractere, o maior número de vezes possíveis, contudo, está tudo bem se não conseguirmos encontrá-lo em algum lugar”. Logo, a expressão <code>"A6*"</code> nos permite encontrar uma letra “A”, quando acompanhada, por exemplo, pelo “número do diabo” (“<strong>A666</strong>”), ou por qualquer outra quantidade do número 6, como o texto “<strong>A6</strong>”, ou “<strong>A6666666</strong>”. Porém, o <em>metacharacter</em> <code>*</code> também nos dá a possibilidade de não encontrarmos o número 6. Por isso, a expressão <code>"A6*"</code> também é capaz de encontrar o texto “<strong>A</strong>na Luísa”, mesmo que ele não possua um número 6.</p>
<p>Segundo, o <em>metacharacter</em> <code>+</code> representa 1 ocorrência como mínimo e infinitas ocorrências como máximo. Por consequência, o <em>metacharacter</em> <code>+</code> expressa: “tente encontrar esse caractere pelo menos uma vez!”. Como exemplo, a expressão <code>"Isa+"</code> é capaz de encontrar os textos “<strong>Isa</strong>dora”, “<strong>Isaa</strong>c Newton” e “<strong>Isaaaaaa</strong>3210”. Mas não é capaz de encontrar o texto “Isótopo”, pois esse texto não possui pelo menos um “a” logo após os caracteres “Is”.</p>
<p>Terceiro, o <em>metacharacter</em> <code>?</code> representa 0 repetições como mínimo e 1 repetição como máximo. Isto é, o <em>metacharacter</em> <code>?</code> busca tornar um caractere completamente opcional. Em outras palavras, ao conectarmos um caractere ou uma sub expressão ao <em>metacharacter</em> <code>?</code> estamos dizendo algo como: “se esse caractere for encontrado, ótimo! Se não, sem problemas!”. Como exemplo, a expressão <code>"dr?a"</code> busca encontrar uma letra “d” imediatamente seguida pelos caracteres “ra”. Mas pelo fato de termos incluído o <em>metacharacter</em> <code>?</code> logo à frente da letra “r”, tornamos essa letra opcional. Por isso, a expressão <code>"dr?a"</code> é capaz de encontrar textos como “engen<strong>dra</strong>r”, “<strong>dra</strong>gão” ou “<strong>dra</strong>min”, assim como os textos “A<strong>da</strong>ga” e “reciproci<strong>da</strong>de”.</p>
<p>Quarto, o <em>metacharacter</em> <code>{}</code> representa a forma geral de um quantificador. Pois ele nos permite especificar exatamente quais as quantidades mínima e máxima que desejamos para um determinado caractere. Basta preencher o par de chaves com essas duas quantidades, separadas por uma vírgula (<code>{min, max}</code>). Por exemplo, a expressão <code>"31[0-9]{4,5}"</code> é capaz de encontrar um código do IBGE referente a um município do estado de Minas Gerais (os dígitos <code>31</code> representam o código do estado de MG). Esses códigos do IBGE possuem uma versão curta, que pode variar de 2 a 4 dígitos, entretanto, suas versões mais comumente utilizadas são as de 6 e de 7 dígitos. Como exemplo, os códigos 310620 e 3106200 se referem ao município de Belo Horizonte. Com isso, ao estabelecermos 4 e 5 dígitos como os limites do intervalo representado pela sub expressão <code>[0-9]{4,5}</code>, somos capazes de detectar códigos como <strong>310620</strong> e <strong>3106200</strong>, e ao mesmo tempo, descartar códigos como 31062, que possui menos de 4 dígitos após os dígitos 31.</p>
<p>Além disso, vale destacar que o objetivo de qualquer <em>metacharacter</em> do tipo quantificador, não é o de determinar o número de vezes que um caractere pode aparecer ao <strong>longo do texto</strong>, mas sim, o número de vezes que um caractere pode ocorrer <strong>em sequência</strong>. Por exemplo, a expressão <code>"(25){2,3}"</code> busca detectar um número arbitrário de 25’s. Assim sendo, essa expressão é capaz de detectar valores como <strong>25</strong>, <strong>25</strong>2, e <strong>2525</strong>, da mesma maneira que o texto “Estive na <strong>25</strong> de Março no último dia 25”.</p>
<p>Porém, muitas pessoas interpretam que os dois 25’s presentes no texto “Estive na 25 de Março no último dia 25” são detectados pela expressão <code>"(25){2,3}"</code>, quando na verdade, apenas o primeiro 25 é localizado. Pois o segundo 25 no texto, se encontra a mais de 20 caracteres a frente do primeiro 25. Logo, ao utilizarmos um <em>metacharacter</em> do tipo quantificador, estamos geralmente preocupados com a possibilidade de o mesmo caractere aparecer múltiplas vezes em sequência (um atrás do outro).</p>
<p>Voltando à expressão <code>"R\\$[0-9]"</code>, com tudo o que descrevi nos parágrafos anteriores, nós podemos adicionar um <code>+</code> logo após <code>[0-9]</code>. Dessa maneira, estamos desejando encontrar <strong>pelo menos</strong> um número qualquer entre 0 e 9, logo após o símbolo monetário R$. Com isso, temos a expressão <code>"R\\$[0-9]+"</code>, que é capaz de encontrar tanto “R$3” quanto “R$3050”.</p>
<p>No entanto, ainda temos a possibilidade de encontrarmos um valor monetário que inclui centavos. Ou seja, podemos encontrar um número que seja seguido por uma vírgula e dois outros dígitos que definem os centavos. Por isso, podemos ainda acrescentar a parte <code>",[0-9][0-9]"</code> para captar essa possível parte de nosso valor monetário.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"8730"</span>, <span class="st">"R$21"</span>, <span class="st">"R$3120,50"</span>, <span class="st">"R$43026"</span>, <span class="st">"R$45,10"</span>)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"R</span><span class="sc">\\</span><span class="st">$[0-9]+,[0-9][0-9]"</span>)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "R$3120,50" "R$45,10"  </code></pre>
</div>
</div>
<p>Porém, repare ainda, que ao adicionarmos a seção <code>",[0-9][0-9]"</code>, a nossa expressão regular não é mais capaz de detectar valores que não possuem uma parte para os centavos, como R$21 e R$43026. É por essa razão, que eu contorno essa seção por parênteses, e adiciono o <em>metacharacter</em> <code>?</code> logo em seguida. Pois dessa forma, essa seção passa a ser opcional. Ou seja, a parte dos centavos deixa de ser obrigatória.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"8730"</span>, <span class="st">"R$21"</span>, <span class="st">"R$3120,50"</span>, <span class="st">"R$43026"</span>, <span class="st">"R$45,10"</span>)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(vec, <span class="st">"R</span><span class="sc">\\</span><span class="st">$[0-9]+(,[0-9][0-9])?"</span>)</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>vec[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "R$21"      "R$3120,50" "R$43026"   "R$45,10"  </code></pre>
</div>
</div>
<section id="conclusão-e-algumas-dicas-extras-1" class="level4" data-number="10.8.8.1">
<h4 data-number="10.8.8.1" class="anchored" data-anchor-id="conclusão-e-algumas-dicas-extras-1"><span class="header-section-number">10.8.8.1</span> Conclusão e algumas dicas extras</h4>
<p>Recapitulando o que vimos até aqui, temos que os números de ocorrências representados por cada <em>metacharacter</em> do tipo “quantificador” são:</p>
<ul>
<li><p><code>?</code>: 0 ou 1 ocorrência.</p></li>
<li><p><code>+</code>: 1 ou mais ocorrências.</p></li>
<li><p><code>*</code>: 0 ou mais ocorrências.</p></li>
<li><p><code>{min, max}</code>: entre <code>min</code> e <code>max</code> ocorrências.</p></li>
</ul>
<p>Para além do que ainda não foi comentado nessa seção, você pode utilizar novamente o <em>metacharacter</em> <code>{}</code>, para especificar um número específico de ocorrências que você deseja para um caractere, ou então, definir apenas o número mínimo ou o número máximo de repetições. Com isso, temos que:</p>
<ul>
<li><p><code>{n}</code>: exatamente <code>n</code> ocorrências.</p></li>
<li><p><code>{min,}</code>: pelo menos <code>min</code> ocorrências.</p></li>
<li><p><code>{,max}</code>: até <code>max</code> ocorrências.</p></li>
</ul>
</section>
</section>
<section id="determinando-os-limites-de-uma-palavra" class="level3" data-number="10.8.9">
<h3 data-number="10.8.9" class="anchored" data-anchor-id="determinando-os-limites-de-uma-palavra"><span class="header-section-number">10.8.9</span> Determinando os limites de uma palavra</h3>
<p>Como estabelecemos anteriormente, expressões regulares não tem a capacidade de diferenciar palavras, e muito menos, de identificar os seus limites. Por essa razão, para termos garantia de que vamos encontrar uma palavra específica no resultado de uma expressão regular, precisamos estabelecer limites para a pesquisa.</p>
<p>Na seção sobre <a href="#sec:regex_ancoras">Âncoras (<em>anchors</em>)</a>, utilizamos os <em>metacharacters</em> do tipo âncora (<code>^</code> e <code>$</code>) para estipularmos os limites da palavra a ser pesquisada. Porém, esses <em>metacharacters</em> <strong>não foram criados para esse objetivo</strong>. Essa afirmação fica clara, ao retornarmos ao exemplo utilizado na seção supracitada.</p>
<p>Naquela ocasião, estávamos tentando encontrar todos os textos contidos no vetor <code>text</code>, que possuíssem a palavra “emissão”. Entretanto, ao utilizarmos a expressão <code>"^emissão$"</code>, fomos capazes de encontrar apenas o primeiro elemento de <code>text</code>. Sendo que, de acordo com o nosso objetivo, também desejamos localizar o quarto, quinto e sexto elementos de <code>text</code>. Pois eles também possuem a palavra “emissão” em alguma instância.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>text <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"emissão"</span>,</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"A Ford Brasil executou recentemente uma demissão em massa"</span>,</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"remissão"</span>,</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Para mais, a emissão de CO2 cresceu no Brasil"</span>,</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"emissão de S02 faz parte do processo"</span>,</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">"A firma foi processada por tal emissão"</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(text, <span class="st">"^emissão$"</span>)</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>text[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"</code></pre>
</div>
</div>
<p>Por isso, precisamos de uma nova estratégia para estipularmos esses limites. Lembre-se que uma expressão regular, nada mais é, do que uma descrição concisa de uma sequência específica de caracteres. Logo, precisamos encontrar alguma forma de descrevermos os caracteres que podem representar os limites de uma palavra.</p>
<p>Todavia, para isso, nós precisamos primeiro identificar o que é o limite de uma palavra. Ou redefinindo a questão, o que exatamente separa uma palavra das demais? Com algum tempo de reflexão, você talvez chegue a conclusão de que o que separa uma palavra da outra, são espaços em branco, ou então, símbolos de pontuação, como um ponto final, ou uma vírgula.</p>
<p>Portanto, precisamos incluir em ambos os lados da palavra “emissão” alguma expressão que possa descrever especificamente esses caracteres, como a expressão <code>"(\\s|[!.,?])"</code>. Repare que o par de parênteses nessa expressão, busca apenas limitar o alcance do <em>metacharacter</em> <code>|</code>, que está separando duas alternativas, ou duas sub expressões (<code>\\s</code> e <code>[!.,?]</code>) que podem descrever os caracteres de nosso interesse. Lembre-se que o termo <code>\\s</code> representa o comando <code>\s</code>, que é um atalho para uma classe de caracteres que busca localizar qualquer tipo de espaço em branco.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(text, <span class="st">"(</span><span class="sc">\\</span><span class="st">s|[!.,?])emissão(</span><span class="sc">\\</span><span class="st">s|[!.,?])"</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>text[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Para mais, a emissão de CO2 cresceu no Brasil"</code></pre>
</div>
</div>
<p>Contudo, perceba acima, que o resultado de nossa pesquisa continua incorreta. Há algum outro detalhe que estamos esquecendo de incluir em nossa expressão. Pois dessa vez, apenas o quarto elemento de <code>text</code> foi retornado. Isso ocorre, porque estamos ignorando a possibilidade da palavra de nosso interesse, ser a responsável por iniciar ou terminar uma linha do texto. Logo, precisamos acrescentar os <em>metacharacters</em> <code>^</code> e <code>$</code>, em nossa descrição dos limites de uma palavra. Com isso, temos as expressões <code>(^|\\s|[!.,?])</code> e <code>($|\\s|[!.,?])</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(text, <span class="st">"(^|</span><span class="sc">\\</span><span class="st">s|[!.,?])emissão($|</span><span class="sc">\\</span><span class="st">s|[!.,?])"</span>)</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>text[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "emissão"                                      
[2] "Para mais, a emissão de CO2 cresceu no Brasil"
[3] "emissão de S02 faz parte do processo"         
[4] "A firma foi processada por tal emissão"       </code></pre>
</div>
</div>
<p>Agora sim, fomos capazes de encontrar todos os textos presentes em <code>text</code> que possuem a palavra “emissão”.</p>
<section id="conclusão-e-algumas-dicas-extras-2" class="level4" data-number="10.8.9.1">
<h4 data-number="10.8.9.1" class="anchored" data-anchor-id="conclusão-e-algumas-dicas-extras-2"><span class="header-section-number">10.8.9.1</span> Conclusão e algumas dicas extras</h4>
<p>Para pesquisarmos por palavras específicas em uma expressão regular, nós precisamos incluir uma descrição dos caracteres que podem representar os limites físicos de uma palavra. Os limites de uma palavra geralmente assumem no formato de:</p>
<ul>
<li><p>Um espaço em branco (descrito por <code>[ ]</code> ou por <code>\\s</code>).</p></li>
<li><p>Pontuações (vírgulas, ponto final, etc.; descrito por <code>[!.,?]</code>).</p></li>
<li><p>Início ou o fim de uma linha (descrito por <code>^</code> e <code>$</code>).</p></li>
</ul>
<p>Vale ainda destacar, o fato de que o R nos oferece um atalho para indicarmos o limite de uma palavra, que se trata do comando <code>\b</code>, ou como deve ser escrito no R, <code>\\b</code>. Consequentemente, se você desejasse encontrar, por exemplo, a palavra “camisa”, você poderia utilizar a expressão <code>"\\bcamisa\\b"</code>.</p>
</section>
</section>
<section id="agrupamentos-e-backreferencing" class="level3" data-number="10.8.10">
<h3 data-number="10.8.10" class="anchored" data-anchor-id="agrupamentos-e-backreferencing"><span class="header-section-number">10.8.10</span> Agrupamentos e <em>backreferencing</em></h3>
<p>Em vários estilos de expressões regulares, parênteses são capazes de “lembrar” o texto encontrado pela sub expressão que eles encapsulam <span class="citation" data-cites="friedl2006">(<a href="#ref-friedl2006" role="doc-biblioref">FRIEDL, 2006</a>, pp.&nbsp;21)</span>. Em expressões regulares, esse mecanismo é comumente denominado de <em>backreferencing</em>.</p>
<p>Em resumo, ao contornarmos uma sub expressão com um par de parênteses, nós estamos formando um “grupo”, e qualquer que seja o pedaço de texto encontrado especificamente por esse grupo, nós somos capazes de reutilizar esse texto dentro da mesma expressão que o localizou, por meio de suas referências numéricas, como <code>\\1</code>, <code>\\2</code>, <code>\\3</code>, e assim por diante. Entenda que essas referências numéricas, nada mais são do que índices de cada par de parênteses, ou de cada grupo presente em sua expressão regular. Logo, o índice <code>\\1</code> se refere ao texto localizado pela sub expressão do primeiro par de parênteses. Já o índice <code>\\2</code>, se refere ao texto descrito pela sub expressão do segundo par de parênteses. E assim segue.</p>
<p>O exemplo clássico desse tipo de operação, está na localização de letras ou palavras repetidas, em uma determinada cadeia de texto. Por exemplo, a expressão abaixo (<code>"(..)\\1"</code>), citada por <span class="citation" data-cites="wickham2017">(<a href="#ref-wickham2017" role="doc-biblioref">WICKHAM; GROLEMUND, 2017</a>, pp.&nbsp;206)</span>, busca encontrar dentro do vetor <code>fruit</code>, alguma palavra que possua um par de letras repetido em sequência. Por isso, palavras como “b<strong>anan</strong>a” e “<strong>coco</strong>nut” são encontradas por essa expressão.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>teste <span class="ot">&lt;-</span> <span class="fu">str_detect</span>(fruit, <span class="st">"(..)</span><span class="sc">\\</span><span class="st">1"</span>)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>fruit[teste]</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "banana"      "coconut"     "cucumber"    "jujube"      "papaya"     
[6] "salal berry"</code></pre>
</div>
</div>
<p>Portanto, dentro da expressão <code>"(..)\\1"</code>, o índice <code>\\1</code> está fazendo alusão ao par de caracteres encontrados pela sub expressão <code>"(..)"</code>. Entretanto, é importante que você tenha cuidado aqui. Pois o índice <code>\\1</code> <strong>não corresponde</strong> à expressão regular <code>"(..)"</code>. Ou seja, a expressão <code>"(..)\\1"</code> <strong>não é equivalente</strong> à expressão <code>"(..)(..)"</code>. Perceba que caso essas expressões fossem iguais, estaríamos simplesmente pesquisando por uma sequência de 4 caracteres quaisquer. Logo, não apenas a correspondência detectada pela expressão seria “<strong>bana</strong>na”, mas também, palavras como “<strong>rasp</strong>berry” e “<strong>pome</strong>granate” estariam inclusas no resultado (o que não ocorre acima).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./../Figuras/backreferencing1.png" class="img-fluid figure-img" style="width:70.0%"></p>
<figcaption>Como o mecanismo de pesquisa funciona quando utilizamos <em>backreferencing</em></figcaption>
</figure>
</div>
</div>
</div>
<p>Por isso, utilizamos o índice <code>\\1</code> quando desejamos encontrar o mesmo pedaço de texto, ou a mesma sequência de caracteres encontrada pelo grupo a que se refere. Com isso, <em>backreferencing</em> se torna um mecanismo útil quando ainda não conhecemos o texto repetido a ser encontrado, ou quando sabemos que esse texto pode variar violentamente ao longo do texto. Por exemplo, suponha que exista em nosso texto, três casos de palavras repetidas (“que que”, “da da” e “ele ele”). Para encontrar esses casos, você talvez tentaria a expressão <code>"\\bque que\\b|\\bda da\\b|\\bele ele\\b"</code>. Porém, seria muito desgastante escrever uma alternativa para cada variação.</p>
<p>Por esse motivo, poderíamos resumir esses casos com o uso de <em>backreferencing</em>. Um exemplo de expressão seria <code>"\\b(.+) \\1\\b"</code>. Dessa forma, a expressão <code>"(.+)"</code> busca encontrar uma sequência qualquer de caracteres, e o índice <code>\\1</code> tenta encontrar essa mesma sequência de caracteres logo após um espaço em branco.</p>
<p>Além desses pontos, repare que utilizamos o atalho <code>\\b</code> (que apresentamos ao final da seção anterior) para definirmos os limites de palavras, ao longo de várias dessas expressões. Se você está querendo descobrir palavras repetidas em seus textos, você com certeza deseja definir esses limites de palavras. Pois caso você não o faça, as repetições de uma sequência específica de caracteres, pelas quais você estaria pesquisando, poderiam ocorrer em qualquer lugar e invadir o espaço de outras palavras.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./../Figuras/backreferencing2.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>A importância de se incluir os limites de palavras em pesquisas que utilizam <em>backreferencing</em></figcaption>
</figure>
</div>
</div>
</div>
<p>Isso significa, que a expressão <code>"(que) \\1"</code> seria capaz de encontrar o texto “A imagem de Naka<strong>que que</strong>ima em meu corpo”, ou o texto “É claro <strong>que que</strong>ro!”. Ampliando esse exemplo para uma expressão mais geral, poderíamos rapidamente realizar que a expressão <code>"(.+) \\1"</code> seria capaz de encontrar textos como “Sut<strong>il il</strong>ustração”, assim como “fez-s<strong>e e</strong>ngendrado”. Dessa forma, o atalho <code>\\b</code> impõe limites a nossa pesquisa, que evitam esse tipo de inconveniência.</p>
</section>
<section id="mais-sobre-padrões" class="level3" data-number="10.8.11">
<h3 data-number="10.8.11" class="anchored" data-anchor-id="mais-sobre-padrões"><span class="header-section-number">10.8.11</span> Mais sobre padrões</h3>
<p>Mesmo estando presente em diversos programas e linguagens, as expressões regulares possuem certa variabilidade, ou apresentam diferentes “gostos” ou “estilos” em cada uma dessas plataformas.</p>
<p>Dito de outra forma, as linguagens JavaScript, Python e R, oferecem um mecanismo próprio de expressões regulares, porém, a forma como esse mecanismo é implementado e quais são as funcionalidades que ele oferece em cada linguagem, pode variar.</p>
<p>Portanto, existem alguns padrões diferentes estabelecidos de expressões regulares. Apesar disso, a maior parte dos programas e linguagens de programação utilizam o padrão mais popular e completo de todos, que é o padrão criado pela linguagem Perl. Todas as linguagens acima oferecem pacotes e módulos que te permitem utilizar esse padrão.</p>
<p>Contudo, por padrão, as funções da família <code>grep()</code> adotam um padrão diferente de expressões regulares estendidas (<em>extended regular expressions</em>), chamado de POSIX 1003.2, o qual é equivalente ao estilo oferecido pelo programa <code>egrep</code>. Entretanto, essas funções também permitem o uso de expressões regulares no estilo adotado pela linguagem Perl. Basta configurar o seu argumento <code>perl</code> para <code>TRUE</code>.</p>
<p>Por outro lado, as funções do pacote <code>stringr</code> utilizam as bibliotecas em C do projeto <em>ICU</em> (<em>International Components for Unicode</em>), que oferecem um estilo de expressões regulares muito próximo do padrão da linguagem Perl. Para mais detalhes sobre essa biblioteca, além de uma lista bem útil de todos os <em>metacharacters</em> disponíveis, você pode consultar o <a href="https://unicode-org.github.io/icu/userguide/strings/regexp.html">site do projeto</a>.</p>
</section>
</section>
<section id="substituindo-partes-de-um-texto-com-str_replace" class="level2" data-number="10.9">
<h2 data-number="10.9" class="anchored" data-anchor-id="substituindo-partes-de-um-texto-com-str_replace"><span class="header-section-number">10.9</span> Substituindo partes de um texto com <code>str_replace()</code></h2>
<p>A função <code>str_replace()</code> e sua variante <code>str_replace_all()</code>, lhe permite aplicar uma expressão regular sobre o seu texto, e substituir a área encontrada (ou áreas encontradas) por um novo valor de seu interesse. Por exemplo, se eu possuo o conjunto de palavras abaixo, e desejo substituir qualquer vogal por um <em>underline</em>, eu precisaria do seguinte comando.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>palavras <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"arquivo"</span>, <span class="st">"estante"</span>, <span class="st">"livro"</span>, <span class="st">"estiagem"</span>,</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>              <span class="st">"dinheiro"</span>, <span class="st">"paz"</span>)</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>palavras <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(palavras, <span class="st">"[aeiou]"</span>, <span class="st">"_"</span>)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>palavras</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "_rquivo"  "_stante"  "l_vro"    "_stiagem" "d_nheiro" "p_z"     </code></pre>
</div>
</div>
<p>Entretanto, perceba acima, que apenas a primeira vogal é alterada. Isso não apenas é um comportamento natural da função <code>str_replace()</code>, mas também é um padrão adotado por muitos dos sistemas de expressão regular. Como foi colocado por <span class="citation" data-cites="friedl2006">(<a href="#ref-friedl2006" role="doc-biblioref">FRIEDL, 2006</a>, pp.&nbsp;148)</span>: <em>“any match that begins earlier (leftmost) in the string is always preferred over any plausible match that begins later”</em>. Com isso, o autor quis destacar que o ato de parar a pesquisa na primeira correspondência encontrada, faz parte dos princípios de muitas expressões regulares.</p>
<p>Porém, em muitos momentos, haverá a necessidade de sobrepor esse comportamento, de forma que a sua expressão possa encontrar todas as correspondências presentes em uma <em>string</em>. Por esse motivo, o pacote <code>stringr</code> oferece diversas funções variantes que terminam com o padrão <code>*_all()</code>. Essas funções buscam justamente solucionar esse problema e, por isso, aplicam a expressão regular sobre todo o texto, com o objetivo de encontrar o maior número possível de correspondências.</p>
<p>Portanto, ao empregarmos a variante <code>str_replace_all()</code>, desejamos substituir todas as correspondências encontradas por uma expressão regular em cada <em>string</em>, por um novo valor textual. Veja que o exemplo abaixo é praticamente idêntico ao anterior, apenas a função <code>str_replace()</code> foi alterada para <code>str_replace_all()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>palavras <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(palavras, <span class="st">"[aeiou]"</span>, <span class="st">"_"</span>)</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>palavras</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "_rq__v_"  "_st_nt_"  "l_vr_"    "_st__g_m" "d_nh__r_" "p_z"     </code></pre>
</div>
</div>
<p>Como um outro exemplo, poderíamos simular o trabalho executado pela função <code>str_trim()</code>, com as funções <code>str_replace()</code> e <code>str_replace_all()</code>. O comando <code>str_replace(vec, "^( )+", "")</code> estaria procurando por qualquer linha que se inicia por uma quantidade <span class="math inline">\(y\)</span> (sendo <span class="math inline">\(y &gt; 0\)</span>) de espaços em branco, e substituindo esses espaços por nada (<code>""</code>). Dessa maneira, este comando equivale à <code>str_trim(vec, side = "left)</code>. Já o comando <code>str_replace_all(vec, "^( )+|( )+$", "")</code>, buscaria qualquer linha que se inicia ou termina por uma quantidade x de espaços em branco, e em seguida, substituiria esses espaços por nada. Sendo assim, esse comando equivale à <code>str_trim(vec, side = "both")</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"  Russo é a língua oficial da Rússia   "</span>,</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"   Japão se encontra na Ásia"</span>,</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Português nunca foi tão difícil!   "</span>,</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"  224,90 "</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace</span>(vec, <span class="st">"^( )+"</span>, <span class="st">""</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Russo é a língua oficial da Rússia   "
[2] "Japão se encontra na Ásia"            
[3] "Português nunca foi tão difícil!   "  
[4] "224,90 "                              </code></pre>
</div>
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace_all</span>(vec, <span class="st">"^( )+|( )+$"</span>, <span class="st">""</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Russo é a língua oficial da Rússia" "Japão se encontra na Ásia"         
[3] "Português nunca foi tão difícil!"   "224,90"                            </code></pre>
</div>
</div>
<p>Para mais, <em>backreferencing</em> se torna uma ferramenta extremamente útil em conjunto com <code>str_replace()</code>. Por exemplo, suponha que você tenha se esquecido de adicionar o símbolo da moeda brasileira em cada valor numérico. Com a expressão regular <code>"([0-9]+(,[0-9]+)?)"</code> podemos encontrar esses valores numéricos. Repare que toda a expressão está contornada por parênteses, logo, todo o número é salvo para o índice <code>\\1</code>. Dessa maneira, basta antecedermos esse índice pelo símbolo que desejamos inserir (<code>"R$\\1"</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"O litro de leite custa 3,50"</span>, <span class="st">"O ingresso foi caro. Mais de 500 reais!"</span>, </span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"230015"</span>)</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_replace</span>(vec, <span class="st">"([0-9]+(,[0-9]+)?)"</span>, <span class="st">"R$</span><span class="sc">\\</span><span class="st">1"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "O litro de leite custa R$3,50"            
[2] "O ingresso foi caro. Mais de R$500 reais!"
[3] "R$230015"                                 </code></pre>
</div>
</div>
</section>
<section id="dividindo-strings-com-str_split" class="level2" data-number="10.10">
<h2 data-number="10.10" class="anchored" data-anchor-id="dividindo-strings-com-str_split"><span class="header-section-number">10.10</span> Dividindo <em>strings</em> com <code>str_split()</code></h2>
<p>Você também pode utilizar uma expressão regular para detectar “pontos de quebra” em uma cadeia de texto e, em seguida, quebrar essa cadeia nesses pontos determinados. Repare no exemplo abaixo, que a função <code>str_split()</code> nos retorna como resultado, uma lista de vetores, onde cada elemento dessa lista, contém os “pedaços” de cada elemento do vetor original (<code>vec</code>). Logo, se você está aplicando <code>str_split()</code> sobre um vetor com 34 elementos, você terá uma lista com 34 elementos em seu produto final.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"1 : 2 : 3 : 4 : 5 : 6 : 7"</span>,</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Faria, Pedro Duarte : 1290321_1"</span>,</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Objeto não localizado : 10_0x341167"</span>,</span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"A732 : B3 : 24 : C1 : 90 : 89 : QUA : ABD : AQZ29 : C11 : 01ER"</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="fu">str_split</span>(vec, <span class="st">" : "</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] "1" "2" "3" "4" "5" "6" "7"

[[2]]
[1] "Faria, Pedro Duarte" "1290321_1"          

[[3]]
[1] "Objeto não localizado" "10_0x341167"          

[[4]]
 [1] "A732"  "B3"    "24"    "C1"    "90"    "89"    "QUA"   "ABD"   "AQZ29"
[10] "C11"   "01ER" </code></pre>
</div>
</div>
<p>Contudo, a depender do que você planeja fazer em seguida, pode ser difícil trabalhar com uma lista. Por isso, a função <code>str_split()</code> nos oferece o argumento <code>simplify</code>, no qual podemos requisitar a função que simplifique o resultado para uma matriz.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_split</span>(vec, <span class="st">" : "</span>, <span class="at">simplify =</span> <span class="cn">TRUE</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1]                    [,2]          [,3] [,4] [,5] [,6] [,7]  [,8] 
[1,] "1"                     "2"           "3"  "4"  "5"  "6"  "7"   ""   
[2,] "Faria, Pedro Duarte"   "1290321_1"   ""   ""   ""   ""   ""    ""   
[3,] "Objeto não localizado" "10_0x341167" ""   ""   ""   ""   ""    ""   
[4,] "A732"                  "B3"          "24" "C1" "90" "89" "QUA" "ABD"
     [,9]    [,10] [,11] 
[1,] ""      ""    ""    
[2,] ""      ""    ""    
[3,] ""      ""    ""    
[4,] "AQZ29" "C11" "01ER"</code></pre>
</div>
</div>
</section>
<section id="extraindo-apenas-a-correspondência-de-sua-expressão-regular-com-str_extract" class="level2" data-number="10.11">
<h2 data-number="10.11" class="anchored" data-anchor-id="extraindo-apenas-a-correspondência-de-sua-expressão-regular-com-str_extract"><span class="header-section-number">10.11</span> Extraindo apenas a correspondência de sua expressão regular com <code>str_extract()</code></h2>
<p>Assim como substituir suas correspondências por novos valores, você também tem a capacidade de extrair essas correspondências isoladamente, por meio da função <code>str_extract()</code>. Essa funcionalidade se torna extremamente importante quando não apenas a estrutura de cada elemento de seu vetor difere, mas também, quando a posição de seu alvo ao longo da cadeia de texto varia. Essas características tornam impossível a extração de nosso alvo com a função <code>str_sub()</code> (que apresentamos anteriormente), que se baseia diretamente na posição dos caracteres ao longo do texto.</p>
<p>Por isso, a melhor alternativa para superarmos esse empecilho, é empregar uma expressão regular que possa detectar os nossos alvos e, com isso, extraí-los por meio da função <code>str_extract()</code>. Como exemplo, podemos extrair todos os anos presentes em cada elemento do vetor <code>per</code>, através do seguinte comando:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>per <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Janeiro_2020"</span>, <span class="st">"Visitei Pará de Minas em Fevereiro de 2019"</span>,</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>         <span class="st">"2020 foi um ano terrível"</span>, <span class="st">"O Brasil era a 11° economia do mundo em 2005"</span>)</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(per, <span class="st">"</span><span class="sc">\\</span><span class="st">d{4}"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "2020" "2019" "2020" "2005"</code></pre>
</div>
</div>
<p>Ou melhor, podemos colocar o texto original e a parte extraída em uma tabela:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tibble</span>(</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">text =</span> per,</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">ano =</span> <span class="fu">str_extract</span>(per, <span class="st">"</span><span class="sc">\\</span><span class="st">d{4}"</span>)</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4 × 2
  text                                         ano  
  &lt;chr&gt;                                        &lt;chr&gt;
1 Janeiro_2020                                 2020 
2 Visitei Pará de Minas em Fevereiro de 2019   2019 
3 2020 foi um ano terrível                     2020 
4 O Brasil era a 11° economia do mundo em 2005 2005 </code></pre>
</div>
</div>
<p>Assim como <code>str_replace()</code>, <code>str_extract()</code> é capaz de extrair apenas a primeira correspondência encontrada por sua expressão regular. Por esse motivo, você irá precisar de sua variante, <code>str_extract_all()</code>, em todas as ocasiões em que você tiver mais de um alvo a ser extraído em cada texto. Por exemplo, podemos extrair o valor de cada medida presente em <code>medidas</code>, por meio da expressão <code>"([0-9]+)([.][0-9]+)?"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Largura X Altura X Profundidade (Peso, Classe)</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>medidas <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"8.15 m X 2.23 m X 4.5 m (240 Kg, B)"</span>,</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"1.14 m X 3.1 m X 0.9 m (15 Kg, A)"</span>,</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"4.98 m X 9.2 m X 5.25 m (120 Kg, A)"</span>,</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"3.14 m X 3.89 m X 3.41 m (86 Kg, C)"</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>tab <span class="ot">&lt;-</span> <span class="fu">str_extract_all</span>(</span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>  medidas,</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>  <span class="st">"([0-9]+)([.][0-9]+)?"</span>,</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">simplify =</span> <span class="cn">TRUE</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(tab) <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Largura"</span>, <span class="st">"Altura"</span>, <span class="st">"Profundidade"</span>, <span class="st">"Peso"</span></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a>tab</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Largura Altura Profundidade Peso 
[1,] "8.15"  "2.23" "4.5"        "240"
[2,] "1.14"  "3.1"  "0.9"        "15" 
[3,] "4.98"  "9.2"  "5.25"       "120"
[4,] "3.14"  "3.89" "3.41"       "86" </code></pre>
</div>
</div>


<div id="refs" class="references csl-bib-body" data-entry-spacing="1" role="list">
<div id="ref-friedl2006" class="csl-entry" role="listitem">
FRIEDL, J. E. F. <strong>Mastering Regular Expressions</strong>. 3. ed. Sebastopol, CA: O’Reilly Media, Inc., 2006.
</div>
<div id="ref-haralambous2007" class="csl-entry" role="listitem">
HARALAMBOUS, Y. <strong>Fonts &amp; Encodings</strong>. Sebastopol, CA: O’Reilly Media, Inc., 2007.
</div>
<div id="ref-wickham2017" class="csl-entry" role="listitem">
WICKHAM, H.; GROLEMUND, G. <strong><a href="https://r4ds.had.co.nz">R for Data Science</a></strong>. Sebastopol, CA: O’Reilly Media, Inc., 2017.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiada");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiada");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Capítulos/09-theme-ggplot.html" class="pagination-link" aria-label="Configurando componentes estéticos do gráfico no `ggplot2`">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Configurando componentes estéticos do gráfico no <code>ggplot2</code></span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../Capítulos/11-factors.html" class="pagination-link" aria-label="Introduzindo fatores (*factor*'s) com `forcats`">
        <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Introduzindo fatores (<em>factor</em>’s) com <code>forcats</code></span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>